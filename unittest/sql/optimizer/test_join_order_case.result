***************   Case 1   ***************

SQL: select t1.c1 from t1, t2 limit 100; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |LIMIT                        |        |100      |414 |
|1 | NESTED-LOOP JOIN CARTESIAN  |        |100      |413 |
|2 |  SUBPLAN SCAN               |VIEW1   |1        |228 |
|3 |   LIMIT                     |        |1        |227 |
|4 |    PX COORDINATOR           |        |1        |227 |
|5 |     EXCHANGE OUT DISTR      |:EX10000|1        |227 |
|6 |      LIMIT                  |        |1        |227 |
|7 |       PX PARTITION ITERATOR |        |1        |227 |
|8 |        TABLE SCAN           |t1      |1        |227 |
|9 |  MATERIAL                   |        |100      |160 |
|10|   SUBPLAN SCAN              |VIEW2   |100      |159 |
|11|    LIMIT                    |        |100      |158 |
|12|     PX COORDINATOR          |        |100      |156 |
|13|      EXCHANGE OUT DISTR     |:EX20000|100      |150 |
|14|       LIMIT                 |        |100      |140 |
|15|        PX PARTITION ITERATOR|        |100      |138 |
|16|         TABLE SCAN          |t2      |100      |138 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([VIEW1.t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  3 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  7 - output([t1.c1]), filter(nil), 
      force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output(nil), filter(nil)
  10 - output(nil), filter(nil), 
      access(nil)
  11 - output([1]), filter(nil), limit(100), offset(nil)
  12 - output(nil), filter(nil)
  13 - output(nil), filter(nil), dop=1
  14 - output(nil), filter(nil), limit(100), offset(nil)
  15 - output(nil), filter(nil), 
      force partition granule.
  16 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 1(end)  ************** 

***************   Case 2   ***************

SQL: select c1 from t1 group by c1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 2(end)  ************** 

***************   Case 3   ***************

SQL: select distinct t4.c1, t4.c2, t2.c2 from t4, t2 where t4.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |482 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |466 |
|2 |  HASH JOIN                  |        |90       |434 |
|3 |   EXCHANGE IN DISTR         |        |100      |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|5 |     TABLE SCAN              |t4      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |300      |233 |
|7 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t2.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t2.c2)]), filter(nil), dop=1
  2 - output([t4.c1], [t4.c2], [t2.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1], [t4.c2]), filter(nil), is_single, dop=1
  5 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      affinitize, force partition granule.
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 3(end)  ************** 

***************   Case 4   ***************

SQL: select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |LIMIT                          |        |100      |633 |
|1 | PX COORDINATOR                |        |100      |631 |
|2 |  EXCHANGE OUT DISTR           |:EX10001|100      |621 |
|3 |   LIMIT                       |        |100      |603 |
|4 |    HASH JOIN                  |        |100      |601 |
|5 |     PX PARTITION ITERATOR     |        |300      |233 |
|6 |      TABLE SCAN               |t2      |300      |233 |
|7 |     EXCHANGE IN DISTR         |        |167      |257 |
|8 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|167      |247 |
|9 |       PX PARTITION ITERATOR   |        |167      |230 |
|10|        TABLE SCAN             |t1      |167      |230 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil)
  8 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  9 - output([t1.c1]), filter(nil), 
      force partition granule.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 4(end)  ************** 

***************   Case 5   ***************

SQL: select t1.c2 + t2.c1 from t1, t2 where t1.c1 = t2.c2 and t1.c1 and t1.c1 = 1 and t2.c1 = 2; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |55  |
|1 | PX COORDINATOR           |        |1        |46  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t2      |1        |46  |
|4 | PX COORDINATOR           |        |1        |46  |
|5 |  EXCHANGE OUT DISTR      |:EX20000|1        |46  |
|6 |   TABLE GET              |t1      |1        |46  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2 + ?]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil)
  2 - output(nil), filter(nil), is_single, dop=1
  3 - output(nil), filter([? = t2.c2]), 
      access([t2.c2]), partitions(p2), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c2]), filter(nil)
  5 - output([t1.c2]), filter(nil), is_single, dop=1
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 5(end)  ************** 

***************   Case 6   ***************

SQL: select t1.c1 from t1, t2, t3 where t1.c1=t2.c1       and t1.c2>t2.c2       and t2.c3=t3.c3       and t3.c1>10; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |HASH JOIN                     |        |82       |1300|
|1 | PX COORDINATOR               |        |100      |158 |
|2 |  EXCHANGE OUT DISTR          |:EX10000|100      |137 |
|3 |   PX PARTITION ITERATOR      |        |100      |93  |
|4 |    TABLE SCAN                |t3      |100      |93  |
|5 | PX COORDINATOR               |        |100      |1056|
|6 |  EXCHANGE OUT DISTR          |:EX20001|100      |1024|
|7 |   HASH JOIN                  |        |100      |954 |
|8 |    EXCHANGE IN DISTR         |        |500      |528 |
|9 |     EXCHANGE OUT DISTR (PKEY)|:EX20000|500      |481 |
|10|      PX PARTITION ITERATOR   |        |500      |387 |
|11|       TABLE SCAN             |t1      |500      |387 |
|12|    PX PARTITION ITERATOR     |        |300      |233 |
|13|     TABLE SCAN               |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t3.c3]), filter(nil)
  2 - output([t3.c3]), filter(nil), dop=1
  3 - output([t3.c3]), filter(nil), 
      force partition granule.
  4 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(10 ; MAX), 
      range_cond([t3.c1 > ?])
  5 - output([t1.c1], [t2.c3]), filter(nil)
  6 - output([t1.c1], [t2.c3]), filter(nil), dop=1
  7 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 6(end)  ************** 

***************   Case 7   ***************

SQL: select opt.t3.c2 from opt.t1,t2,t3 where t1.c1+t2.c1=t3.c1; 

==============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST  |
--------------------------------------------------------------
|0 |PX COORDINATOR                 |        |150000   |166619|
|1 | EXCHANGE OUT DISTR            |:EX10003|150000   |141301|
|2 |  HASH JOIN                    |        |150000   |87585 |
|3 |   PX PARTITION ITERATOR       |        |200      |155   |
|4 |    TABLE SCAN                 |t3      |200      |155   |
|5 |   EXCHANGE IN DISTR           |        |150000   |50629 |
|6 |    EXCHANGE OUT DISTR (PKEY)  |:EX10002|150000   |36655 |
|7 |     NESTED-LOOP JOIN CARTESIAN|        |150000   |8483  |
|8 |      EXCHANGE IN DISTR        |        |300      |280   |
|9 |       EXCHANGE OUT DISTR      |:EX10000|300      |263   |
|10|        PX PARTITION ITERATOR  |        |300      |233   |
|11|         TABLE SCAN            |t2      |300      |233   |
|12|      MATERIAL                 |        |500      |468   |
|13|       EXCHANGE IN DISTR       |        |500      |466   |
|14|        EXCHANGE OUT DISTR     |:EX10001|500      |439   |
|15|         PX PARTITION ITERATOR |        |500      |387   |
|16|          TABLE SCAN           |t1      |500      |387   |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t3.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t3.c2)]), filter(nil), dop=1
  2 - output([t3.c2]), filter(nil), 
      equal_conds([t1.c1 + t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1], [t3.c2]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1 + t2.c1]), filter(nil)
  6 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1 + t2.c1]), filter(nil), is_single, dop=1
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), dop=1
  10 - output([t2.c1]), filter(nil), 
      force partition granule.
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1]), filter(nil)
  13 - output([t1.c1]), filter(nil)
  14 - output([t1.c1]), filter(nil), dop=1
  15 - output([t1.c1]), filter(nil), 
      force partition granule.
  16 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 7(end)  ************** 

***************   Case 8   ***************

SQL: select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |HASH JOIN                     |        |4        |1673|
|1 | PX COORDINATOR               |        |200      |1022|
|2 |  EXCHANGE OUT DISTR          |:EX10001|200      |965 |
|3 |   HASH JOIN                  |        |200      |842 |
|4 |    PX PARTITION ITERATOR     |        |500      |387 |
|5 |     TABLE SCAN               |t1      |500      |387 |
|6 |    EXCHANGE IN DISTR         |        |200      |285 |
|7 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |244 |
|8 |      PX PARTITION ITERATOR   |        |200      |155 |
|9 |       TABLE SCAN             |t3      |200      |155 |
|10| PX COORDINATOR               |        |300      |428 |
|11|  EXCHANGE OUT DISTR          |:EX20000|300      |366 |
|12|   PX PARTITION ITERATOR      |        |300      |233 |
|13|    TABLE SCAN                |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t3.c1], [t3.c3]), filter(nil)
  7 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c3]), filter(nil), 
      force partition granule.
  9 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c2], [t2.c3]), filter(nil), dop=1
  12 - output([t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  13 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 8(end)  ************** 

***************   Case 9   ***************

SQL: select t1.c1 from t1,t2,t3 where t1.c1=t2.c1 and t1.c1+t2.c1=t3.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |300      |1342|
|1 | EXCHANGE OUT DISTR             |:EX10002|300      |1303|
|2 |  HASH JOIN                     |        |300      |1221|
|3 |   PX PARTITION ITERATOR        |        |200      |155 |
|4 |    TABLE SCAN                  |t3      |200      |155 |
|5 |   EXCHANGE IN DISTR            |        |300      |943 |
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|300      |915 |
|7 |     HASH JOIN                  |        |300      |859 |
|8 |      EXCHANGE IN DISTR         |        |300      |280 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|10|        PX PARTITION ITERATOR   |        |300      |233 |
|11|         TABLE SCAN             |t2      |300      |233 |
|12|      PX PARTITION ITERATOR     |        |500      |387 |
|13|       TABLE SCAN               |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 + t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c1 + t2.c1]), filter(nil)
  6 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1], [t1.c1 + t2.c1]), filter(nil), dop=1
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t2.c1]), filter(nil)
  9 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  10 - output([t2.c1]), filter(nil), 
      force partition granule.
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 9(end)  ************** 

***************   Case 10   ***************

SQL: select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN               |        |487      |7244|
|1 | HASH JOIN                     |        |811      |1519|
|2 |  PX COORDINATOR               |        |200      |822 |
|3 |   EXCHANGE OUT DISTR          |:EX10001|200      |796 |
|4 |    HASH JOIN                  |        |200      |741 |
|5 |     EXCHANGE IN DISTR         |        |200      |187 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |176 |
|7 |       PX PARTITION ITERATOR   |        |200      |155 |
|8 |        TABLE SCAN             |t3      |200      |155 |
|9 |     PX PARTITION ITERATOR     |        |500      |387 |
|10|      TABLE SCAN               |t1      |500      |387 |
|11|  PX COORDINATOR               |        |500      |528 |
|12|   EXCHANGE OUT DISTR          |:EX20000|500      |481 |
|13|    PX PARTITION ITERATOR      |        |500      |387 |
|14|     TABLE SCAN                |tt      |500      |387 |
|15| MATERIAL                      |        |300      |281 |
|16|  PX COORDINATOR               |        |300      |280 |
|17|   EXCHANGE OUT DISTR          |:EX30000|300      |263 |
|18|    PX PARTITION ITERATOR      |        |300      |233 |
|19|     TABLE SCAN                |t2      |300      |233 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil)
  6 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  7 - output([t3.c1]), filter(nil), 
      force partition granule.
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([tt.c1], [tt.c2]), filter(nil)
  12 - output([tt.c1], [tt.c2]), filter(nil), dop=1
  13 - output([tt.c1], [tt.c2]), filter(nil), 
      force partition granule.
  14 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c1]), range(MIN ; MAX)always true
  15 - output([t2.c1]), filter(nil)
  16 - output([t2.c1]), filter(nil)
  17 - output([t2.c1]), filter(nil), dop=1
  18 - output([t2.c1]), filter(nil), 
      force partition granule.
  19 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 10(end)  ************** 

***************   Case 11   ***************

SQL: select t1.c1 from t1, (select * from t2) as t where t1.c1=t.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |943 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |915 |
|2 |  HASH JOIN                  |        |300      |859 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t2      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |500      |387 |
|8 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 11(end)  ************** 

***************   Case 12   ***************

SQL: select t1.c1 from t1, (select * from t2 where c2>1 order by c1 limit 10) as t where t1.c1=t.c1; 

================================================================
|ID|OPERATOR                           |NAME    |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                     |        |10       |213 |
|1 | EXCHANGE OUT DISTR                |:EX10002|10       |212 |
|2 |  NESTED-LOOP JOIN                 |        |10       |210 |
|3 |   EXCHANGE IN DISTR               |        |10       |144 |
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10001|10       |143 |
|5 |     SUBPLAN SCAN                  |t       |10       |142 |
|6 |      LIMIT                        |        |10       |142 |
|7 |       EXCHANGE IN MERGE SORT DISTR|        |10       |142 |
|8 |        EXCHANGE OUT DISTR         |:EX10000|10       |141 |
|9 |         TOP-N SORT                |        |10       |139 |
|10|          PX PARTITION ITERATOR    |        |10       |137 |
|11|           TABLE SCAN              |t2      |10       |137 |
|12|   PX PARTITION ITERATOR           |        |1        |29  |
|13|    TABLE GET                      |t1      |1        |29  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t.c1]), batch_join=false
  3 - output([PARTITION_ID], [t.c1]), filter(nil)
  4 - (#keys=1, [t.c1]), output([PARTITION_ID], [t.c1]), filter(nil), is_single, dop=1
  5 - output([t.c1]), filter(nil), 
      access([t.c1])
  6 - output([t2.c1]), filter(nil), limit(10), offset(nil)
  7 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  8 - output([t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), topn(10), local merge sort
  10 - output([t2.c1]), filter(nil), 
      force partition granule.
  11 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      limit(10), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 12(end)  ************** 

***************   Case 13   ***************

SQL: select c1, c1+c2 from t1 where c1 > 100 order by c2 + c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |1        |228 |
|1 | EXCHANGE OUT DISTR       |:EX10000|1        |228 |
|2 |  SORT                    |        |1        |227 |
|3 |   PX PARTITION ITERATOR  |        |1        |227 |
|4 |    TABLE SCAN            |t1      |1        |227 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 + t1.c2)]), filter(nil), sort_keys([t1.c2 + t1.c1, ASC])
  1 - output([t1.c2 + t1.c1], [INTERNAL_FUNCTION(t1.c1, t1.c1 + t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2 + t1.c1], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2 + t1.c1, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(100 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 13(end)  ************** 

***************   Case 14   ***************

SQL: select * from t1,t2 where t1.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 14(end)  ************** 

***************   Case 15   ***************

SQL: select t1.c1, t2.c2, t2.c3 from t1,t2 where t1.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1160|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1075|
|2 |  HASH JOIN                  |        |300      |891 |
|3 |   EXCHANGE IN DISTR         |        |500      |466 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |439 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 15(end)  ************** 

***************   Case 16   ***************

SQL: select c2 from t1 order by c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |631 |
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |584 |
|2 |  SORT                    |        |500      |490 |
|3 |   PX PARTITION ITERATOR  |        |500      |387 |
|4 |    TABLE SCAN            |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 16(end)  ************** 

***************   Case 17   ***************

SQL: select t1.c1, t2.c2, t2.c3 from t1,t2 where t1.c1 = t2.c1 order by t1.c2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |300      |1471|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1375|
|2 |  SORT                        |        |300      |1165|
|3 |   HASH JOIN                  |        |300      |954 |
|4 |    EXCHANGE IN DISTR         |        |500      |528 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|6 |      PX PARTITION ITERATOR   |        |500      |387 |
|7 |       TABLE SCAN             |t1      |500      |387 |
|8 |    PX PARTITION ITERATOR     |        |300      |233 |
|9 |     TABLE SCAN               |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2], [INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c2], [t1.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c2], [t1.c1]), filter(nil)
  5 - (#keys=1, [t1.c1]), output([t1.c2], [t1.c1]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 17(end)  ************** 

***************   Case 18   ***************

SQL: select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |23       |699 |
|1 | EXCHANGE OUT DISTR          |:EX10001|23       |689 |
|2 |  HASH JOIN                  |        |23       |665 |
|3 |   EXCHANGE IN DISTR         |        |200      |310 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |261 |
|5 |     PX PARTITION ITERATOR   |        |200      |155 |
|6 |      TABLE SCAN             |t3      |200      |155 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t3.c1], [t2.c3], [t3.c3], [t2.c2], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  3 - output([t3.c1], [t3.c3], [t3.c2]), filter(nil)
  4 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c3], [t3.c2]), filter(nil), dop=1
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 18(end)  ************** 

***************   Case 19   ***************

SQL: select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |257      |981 |
|1 | EXCHANGE OUT DISTR          |:EX10001|257      |947 |
|2 |  HASH JOIN                  |        |257      |877 |
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |257      |308 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|257      |284 |
|7 |     PX PARTITION ITERATOR   |        |257      |236 |
|8 |      TABLE SCAN             |t2      |257      |236 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  7 - output([t2.c1]), filter(nil), 
      force partition granule.
  8 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 19(end)  ************** 

***************   Case 20   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |1460|
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |1300|
|2 |  HASH OUTER JOIN            |        |500      |950 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |285      |232 |
|8 |    TABLE SCAN               |t2      |285      |232 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c1 > ?])
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(1 ; MAX), 
      range_cond([t2.c1 > ?])

*************** Case 20(end)  ************** 

***************   Case 21   ***************

SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is null; 

=========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST|
---------------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN       |        |25       |803 |
|1 | PX COORDINATOR             |        |500      |528 |
|2 |  EXCHANGE OUT DISTR        |:EX10000|500      |481 |
|3 |   PX PARTITION ITERATOR    |        |500      |387 |
|4 |    TABLE SCAN              |t1      |500      |387 |
|5 | MATERIAL                   |        |1        |137 |
|6 |  SUBPLAN SCAN              |VIEW1   |1        |137 |
|7 |   LIMIT                    |        |1        |137 |
|8 |    PX COORDINATOR          |        |1        |137 |
|9 |     EXCHANGE OUT DISTR     |:EX20000|1        |137 |
|10|      LIMIT                 |        |1        |137 |
|11|       PX PARTITION ITERATOR|        |1        |137 |
|12|        TABLE SCAN          |t2      |1        |137 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [?], [?], [?]), filter(nil), 
      conds([t1.c1 > ?]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output(nil), filter(nil)
  6 - output(nil), filter(nil), 
      access(nil)
  7 - output([1]), filter(nil), limit(1), offset(nil)
  8 - output(nil), filter(nil)
  9 - output(nil), filter(nil), dop=1
  10 - output(nil), filter(nil), limit(1), offset(nil)
  11 - output(nil), filter(nil), 
      force partition granule.
  12 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 21(end)  ************** 

***************   Case 22   ***************

SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |150000   |8729|
|1 | PX COORDINATOR           |        |300      |464 |
|2 |  EXCHANGE OUT DISTR      |:EX10000|300      |391 |
|3 |   PX PARTITION ITERATOR  |        |300      |233 |
|4 |    TABLE SCAN            |t2      |300      |233 |
|5 | MATERIAL                 |        |500      |531 |
|6 |  PX COORDINATOR          |        |500      |528 |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500      |481 |
|8 |    PX PARTITION ITERATOR |        |500      |387 |
|9 |     TABLE SCAN           |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 22(end)  ************** 

***************   Case 23   ***************

SQL: select /*+no_use_px*/ t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1198|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1183|
|2 |  HASH JOIN                     |        |120      |1150|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |798 |
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |779 |
|7 |     HASH JOIN                  |        |200      |741 |
|8 |      EXCHANGE IN DISTR         |        |200      |187 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |176 |
|10|        PX PARTITION ITERATOR   |        |200      |155 |
|11|         TABLE SCAN             |t3      |200      |155 |
|12|      PX PARTITION ITERATOR     |        |500      |387 |
|13|       TABLE SCAN               |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  7 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil)
  9 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  10 - output([t3.c1]), filter(nil), 
      force partition granule.
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 23(end)  ************** 

***************   Case 24   ***************

SQL: select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN               |        |487      |7244|
|1 | HASH JOIN                     |        |811      |1519|
|2 |  PX COORDINATOR               |        |200      |822 |
|3 |   EXCHANGE OUT DISTR          |:EX10001|200      |796 |
|4 |    HASH JOIN                  |        |200      |741 |
|5 |     EXCHANGE IN DISTR         |        |200      |187 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |176 |
|7 |       PX PARTITION ITERATOR   |        |200      |155 |
|8 |        TABLE SCAN             |t3      |200      |155 |
|9 |     PX PARTITION ITERATOR     |        |500      |387 |
|10|      TABLE SCAN               |t1      |500      |387 |
|11|  PX COORDINATOR               |        |500      |528 |
|12|   EXCHANGE OUT DISTR          |:EX20000|500      |481 |
|13|    PX PARTITION ITERATOR      |        |500      |387 |
|14|     TABLE SCAN                |tt      |500      |387 |
|15| MATERIAL                      |        |300      |281 |
|16|  PX COORDINATOR               |        |300      |280 |
|17|   EXCHANGE OUT DISTR          |:EX30000|300      |263 |
|18|    PX PARTITION ITERATOR      |        |300      |233 |
|19|     TABLE SCAN                |t2      |300      |233 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil)
  6 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  7 - output([t3.c1]), filter(nil), 
      force partition granule.
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([tt.c1], [tt.c2]), filter(nil)
  12 - output([tt.c1], [tt.c2]), filter(nil), dop=1
  13 - output([tt.c1], [tt.c2]), filter(nil), 
      force partition granule.
  14 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c1]), range(MIN ; MAX)always true
  15 - output([t2.c1]), filter(nil)
  16 - output([t2.c1]), filter(nil)
  17 - output([t2.c1]), filter(nil), dop=1
  18 - output([t2.c1]), filter(nil), 
      force partition granule.
  19 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 24(end)  ************** 

***************   Case 25   ***************

SQL: select /*+no_use_px*/ t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

================================================================
|ID|OPERATOR                           |NAME    |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                     |        |1        |1596|
|1 | EXCHANGE OUT DISTR                |:EX10003|1        |1596|
|2 |  NESTED-LOOP JOIN                 |        |1        |1595|
|3 |   EXCHANGE IN DISTR               |        |3        |1579|
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10002|3        |1579|
|5 |     HASH JOIN                     |        |3        |1578|
|6 |      EXCHANGE IN DISTR            |        |300      |980 |
|7 |       EXCHANGE OUT DISTR (PKEY)   |:EX10001|300      |941 |
|8 |        HASH JOIN                  |        |300      |859 |
|9 |         EXCHANGE IN DISTR         |        |300      |280 |
|10|          EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|11|           PX PARTITION ITERATOR   |        |300      |233 |
|12|            TABLE SCAN             |t2      |300      |233 |
|13|         PX PARTITION ITERATOR     |        |500      |387 |
|14|          TABLE SCAN               |t1      |500      |387 |
|15|      PX PARTITION ITERATOR        |        |500      |387 |
|16|       TABLE SCAN                  |tt      |500      |387 |
|17|   PX PARTITION ITERATOR           |        |1        |12  |
|18|    TABLE GET                      |t3      |1        |12  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 + t2.c1 = tt.c1], [t1.c2 = tt.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c1 + t2.c1], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1], [t1.c1 + t2.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t2.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  9 - output([t2.c1]), filter(nil)
  10 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  11 - output([t2.c1]), filter(nil), 
      force partition granule.
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  15 - output([tt.c1], [tt.c2]), filter(nil), 
      affinitize, force partition granule.
  16 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c1]), range(MIN ; MAX)always true
  17 - output(nil), filter(nil), 
      affinitize, force partition granule.
  18 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([? = t3.c1])

*************** Case 25(end)  ************** 

***************   Case 26   ***************

SQL: select /*+ leading(t2 t1 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1756|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1691|
|2 |  HASH JOIN                     |        |120      |1545|
|3 |   EXCHANGE IN DISTR            |        |300      |1263|
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|300      |1167|
|5 |     HASH JOIN                  |        |300      |957 |
|6 |      PX PARTITION ITERATOR     |        |300      |233 |
|7 |       TABLE SCAN               |t2      |300      |233 |
|8 |      EXCHANGE IN DISTR         |        |500      |528 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|10|        PX PARTITION ITERATOR   |        |500      |387 |
|11|         TABLE SCAN             |t1      |500      |387 |
|12|   PX PARTITION ITERATOR        |        |200      |155 |
|13|    TABLE SCAN                  |t3      |200      |155 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t3.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 26(end)  ************** 

***************   Case 27   ***************

SQL: select /*+ leading(t2)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1743|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1677|
|2 |  HASH JOIN                     |        |120      |1532|
|3 |   EXCHANGE IN DISTR            |        |200      |970 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |875 |
|5 |     HASH JOIN                  |        |200      |668 |
|6 |      PX PARTITION ITERATOR     |        |300      |233 |
|7 |       TABLE SCAN               |t2      |300      |233 |
|8 |      EXCHANGE IN DISTR         |        |200      |310 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |261 |
|10|        PX PARTITION ITERATOR   |        |200      |155 |
|11|         TABLE SCAN             |t3      |200      |155 |
|12|   PX PARTITION ITERATOR        |        |500      |387 |
|13|    TABLE SCAN                  |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t3.c1], [t2.c2], [t2.c3], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t3.c1], [t2.c2], [t2.c3], [t3.c2], [t3.c3]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t3.c1], [t2.c2], [t2.c3], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t3.c1], [t2.c2], [t2.c3], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  10 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 27(end)  ************** 

***************   Case 28   ***************

SQL: select /*+ use_merge(t2)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1625|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1560|
|2 |  HASH JOIN                     |        |120      |1414|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1057|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |993 |
|7 |     HASH JOIN                  |        |200      |853 |
|8 |      EXCHANGE IN DISTR         |        |500      |528 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|10|        PX PARTITION ITERATOR   |        |500      |387 |
|11|         TABLE SCAN             |t1      |500      |387 |
|12|      PX PARTITION ITERATOR     |        |200      |155 |
|13|       TABLE SCAN               |t3      |200      |155 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 28(end)  ************** 

***************   Case 29   ***************

SQL: select /*+ use_merge(t1)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1625|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1559|
|2 |  HASH JOIN                     |        |120      |1414|
|3 |   EXCHANGE IN DISTR            |        |200      |1057|
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |993 |
|5 |     HASH JOIN                  |        |200      |853 |
|6 |      EXCHANGE IN DISTR         |        |500      |528 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|8 |        PX PARTITION ITERATOR   |        |500      |387 |
|9 |         TABLE SCAN             |t1      |500      |387 |
|10|      PX PARTITION ITERATOR     |        |200      |155 |
|11|       TABLE SCAN               |t3      |200      |155 |
|12|   PX PARTITION ITERATOR        |        |300      |233 |
|13|    TABLE SCAN                  |t2      |300      |233 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 29(end)  ************** 

***************   Case 30   ***************

SQL: select /*+ use_merge(t2 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1626|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1561|
|2 |  HASH JOIN                     |        |120      |1415|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1058|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |994 |
|7 |     HASH JOIN                  |        |200      |854 |
|8 |      PX PARTITION ITERATOR     |        |200      |155 |
|9 |       TABLE SCAN               |t3      |200      |155 |
|10|      EXCHANGE IN DISTR         |        |500      |528 |
|11|       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|12|        PX PARTITION ITERATOR   |        |500      |387 |
|13|         TABLE SCAN             |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 30(end)  ************** 

***************   Case 31   ***************

SQL: select /*+ use_nl(t2 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1626|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1561|
|2 |  HASH JOIN                     |        |120      |1415|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1058|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |994 |
|7 |     HASH JOIN                  |        |200      |854 |
|8 |      PX PARTITION ITERATOR     |        |200      |155 |
|9 |       TABLE SCAN               |t3      |200      |155 |
|10|      EXCHANGE IN DISTR         |        |500      |528 |
|11|       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|12|        PX PARTITION ITERATOR   |        |500      |387 |
|13|         TABLE SCAN             |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 31(end)  ************** 

***************   Case 32   ***************

SQL: select /*+ use_merge(t2), use_nl(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1626|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1561|
|2 |  HASH JOIN                     |        |120      |1415|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1058|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |994 |
|7 |     HASH JOIN                  |        |200      |854 |
|8 |      PX PARTITION ITERATOR     |        |200      |155 |
|9 |       TABLE SCAN               |t3      |200      |155 |
|10|      EXCHANGE IN DISTR         |        |500      |528 |
|11|       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|12|        PX PARTITION ITERATOR   |        |500      |387 |
|13|         TABLE SCAN             |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 32(end)  ************** 

***************   Case 33   ***************

SQL: select /*+ ordered, use_merge(t2), use_nl(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |120      |3527|
|1 | EXCHANGE OUT DISTR               |:EX10002|120      |3461|
|2 |  NESTED-LOOP JOIN                |        |120      |3316|
|3 |   EXCHANGE IN DISTR              |        |300      |1304|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300      |1208|
|5 |     MERGE JOIN                   |        |300      |998 |
|6 |      EXCHANGE IN MERGE SORT DISTR|        |500      |528 |
|7 |       EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |481 |
|8 |        PX PARTITION ITERATOR     |        |500      |387 |
|9 |         TABLE SCAN               |t1      |500      |387 |
|10|      SORT                        |        |300      |299 |
|11|       PX PARTITION ITERATOR      |        |300      |233 |
|12|        TABLE SCAN                |t2      |300      |233 |
|13|   PX PARTITION ITERATOR          |        |1        |12  |
|14|    TABLE GET                     |t3      |1        |12  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [PARTITION_ID], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([? = t3.c1])

*************** Case 33(end)  ************** 

***************   Case 34   ***************

SQL: select /*+ use_nl(t2), use_merge(t3)*/ * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1626|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1561|
|2 |  HASH JOIN                     |        |120      |1415|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1058|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |994 |
|7 |     HASH JOIN                  |        |200      |854 |
|8 |      PX PARTITION ITERATOR     |        |200      |155 |
|9 |       TABLE SCAN               |t3      |200      |155 |
|10|      EXCHANGE IN DISTR         |        |500      |528 |
|11|       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|12|        PX PARTITION ITERATOR   |        |500      |387 |
|13|         TABLE SCAN             |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t3.c1 = t1.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 34(end)  ************** 

***************   Case 35   ***************

SQL: select /*+ use_nl(t2), use_merge(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1626|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1561|
|2 |  HASH JOIN                     |        |120      |1415|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1058|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |994 |
|7 |     HASH JOIN                  |        |200      |854 |
|8 |      PX PARTITION ITERATOR     |        |200      |155 |
|9 |       TABLE SCAN               |t3      |200      |155 |
|10|      EXCHANGE IN DISTR         |        |500      |528 |
|11|       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|12|        PX PARTITION ITERATOR   |        |500      |387 |
|13|         TABLE SCAN             |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 35(end)  ************** 

***************   Case 36   ***************

SQL: select /*+ ordered, use_nl(t2), use_merge(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |4674|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |4609|
|2 |  MERGE JOIN                    |        |120      |4464|
|3 |   EXCHANGE IN MERGE SORT DISTR |        |300      |4167|
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|300      |4071|
|5 |     NESTED-LOOP JOIN           |        |300      |3861|
|6 |      EXCHANGE IN DISTR         |        |500      |528 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|8 |        PX PARTITION ITERATOR   |        |500      |387 |
|9 |         TABLE SCAN             |t1      |500      |387 |
|10|      PX PARTITION ITERATOR     |        |1        |18  |
|11|       TABLE GET                |t2      |1        |18  |
|12|   SORT                         |        |200      |199 |
|13|    PX PARTITION ITERATOR       |        |200      |155 |
|14|     TABLE SCAN                 |t3      |200      |155 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t3.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  6 - output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 36(end)  ************** 

***************   Case 37   ***************

SQL: select /*+ ordered, use_merge(t3) */ * from t2, t3 where t2.c2 = t3.c1 and t2.c1 = 0 and t3.c1 = 0; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |50  |
|1 | TABLE GET                |t2  |1        |46  |
|2 | TABLE GET                |t3  |1        |46  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[0 ; 0], 
      range_cond([t2.c1 = ?])
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t3.c1]), range[0 ; 0], 
      range_cond([t3.c1 = ?])

*************** Case 37(end)  ************** 

***************   Case 38   ***************

SQL: select /*+ use_merge(t3) */ * from t2, t3 where t2.c1 = t3.c2 and t2.c1 = 0 and t3.c1 = 0; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |50  |
|1 | TABLE GET                |t3  |1        |46  |
|2 | TABLE GET                |t2  |1        |46  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter([? = t3.c2]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t3.c1]), range[0 ; 0], 
      range_cond([t3.c1 = ?])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t2.c1]), range[0 ; 0], 
      range_cond([t2.c1 = ?])

*************** Case 38(end)  ************** 

***************   Case 39   ***************

SQL: select /*+ index(t5 idx_t5_c2) */ t5.c2 from t5, t1 where t5.c2 = t1.c2; 

==========================================================
|ID|OPERATOR                |NAME         |EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH JOIN               |             |1216     |938 |
|1 | PX COORDINATOR         |             |300      |280 |
|2 |  EXCHANGE OUT DISTR    |:EX10000     |300      |263 |
|3 |   PX PARTITION ITERATOR|             |300      |233 |
|4 |    TABLE SCAN          |t5(idx_t5_c2)|300      |233 |
|5 | PX COORDINATOR         |             |500      |466 |
|6 |  EXCHANGE OUT DISTR    |:EX20000     |500      |439 |
|7 |   PX PARTITION ITERATOR|             |500      |387 |
|8 |    TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c2]), filter(nil), 
      equal_conds([t5.c2 = t1.c2]), other_conds(nil)
  1 - output([t5.c2]), filter(nil)
  2 - output([t5.c2]), filter(nil), dop=1
  3 - output([t5.c2]), filter(nil), 
      force partition granule.
  4 - output([t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t1.c2]), filter(nil)
  6 - output([t1.c2]), filter(nil), dop=1
  7 - output([t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 39(end)  ************** 

***************   Case 40   ***************

SQL: select c1, c2 from t1 ignore index (idx_t1_c2) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |402 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |401 |
|2 |  PX PARTITION ITERATOR|        |6        |400 |
|3 |   TABLE SCAN          |t1      |6        |400 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = ? OR t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 40(end)  ************** 

***************   Case 41   ***************

SQL: select t5.c2 from t5, t1 ignore index (idx_t5_c2) where t5.c2 = t1.c2; 

==========================================================
|ID|OPERATOR                |NAME         |EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH JOIN               |             |1216     |938 |
|1 | PX COORDINATOR         |             |300      |280 |
|2 |  EXCHANGE OUT DISTR    |:EX10000     |300      |263 |
|3 |   PX PARTITION ITERATOR|             |300      |233 |
|4 |    TABLE SCAN          |t5(idx_t5_c2)|300      |233 |
|5 | PX COORDINATOR         |             |500      |466 |
|6 |  EXCHANGE OUT DISTR    |:EX20000     |500      |439 |
|7 |   PX PARTITION ITERATOR|             |500      |387 |
|8 |    TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c2]), filter(nil), 
      equal_conds([t5.c2 = t1.c2]), other_conds(nil)
  1 - output([t5.c2]), filter(nil)
  2 - output([t5.c2]), filter(nil), dop=1
  3 - output([t5.c2]), filter(nil), 
      force partition granule.
  4 - output([t5.c2]), filter(nil), 
      access([t5.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t1.c2]), filter(nil)
  6 - output([t1.c2]), filter(nil), dop=1
  7 - output([t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 41(end)  ************** 

***************   Case 42   ***************

SQL: select * from t1 right join t2 on t1.c1=t2.c1 and t1.c1>1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1246|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1150|
|2 |  HASH RIGHT OUTER JOIN      |        |300      |941 |
|3 |   EXCHANGE IN DISTR         |        |475      |520 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|475      |476 |
|5 |     PX PARTITION ITERATOR   |        |475      |387 |
|6 |      TABLE SCAN             |t1      |475      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(1 ; MAX), 
      range_cond([t1.c1 > ?])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 42(end)  ************** 

***************   Case 43   ***************

SQL: select * from t1 full join t2 on t1.c1=t2.c1 and t1.c1>1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |1464|
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |1304|
|2 |  HASH FULL OUTER JOIN       |        |500      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c1 > ?])
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 43(end)  ************** 

***************   Case 44   ***************

SQL: select * from t1 where c1 in (select c1 from t2); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |980 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |941 |
|2 |  HASH JOIN                  |        |300      |859 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t2      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |500      |387 |
|8 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 44(end)  ************** 

***************   Case 45   ***************

SQL: select c1, c2 from t1 where exists (select * from t2 where  t2.c1 = t1.c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |980 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |941 |
|2 |  HASH JOIN                  |        |300      |859 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t2      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |500      |387 |
|8 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 45(end)  ************** 

***************   Case 46   ***************

SQL: select * from t1 where c1 not in (select c1 from t2); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |200      |961 |
|1 | EXCHANGE OUT DISTR          |:EX10001|200      |942 |
|2 |  HASH RIGHT ANTI JOIN       |        |200      |904 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t2      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |500      |387 |
|8 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 46(end)  ************** 

***************   Case 47   ***************

SQL: select c1, c2 from t1 where not exists (select * from t2 where  t2.c1 = t1.c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |200      |961 |
|1 | EXCHANGE OUT DISTR          |:EX10001|200      |942 |
|2 |  HASH RIGHT ANTI JOIN       |        |200      |904 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t2      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |500      |387 |
|8 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 47(end)  ************** 

***************   Case 48   ***************

SQL: select t1.c1 from t1, t2 where t1.c1 + t2.c1 = 5; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |NESTED-LOOP JOIN         |        |750      |3180|
|1 | PX COORDINATOR          |        |300      |280 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|300      |263 |
|3 |   PX PARTITION ITERATOR |        |300      |233 |
|4 |    TABLE SCAN           |t2      |300      |233 |
|5 | MATERIAL                |        |500      |468 |
|6 |  PX COORDINATOR         |        |500      |466 |
|7 |   EXCHANGE OUT DISTR    |:EX20000|500      |439 |
|8 |    PX PARTITION ITERATOR|        |500      |387 |
|9 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = ?]), nl_params_(nil), batch_join=false
  1 - output([t2.c1]), filter(nil)
  2 - output([t2.c1]), filter(nil), dop=1
  3 - output([t2.c1]), filter(nil), 
      force partition granule.
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1]), filter(nil)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), 
      force partition granule.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 48(end)  ************** 

***************   Case 49   ***************

SQL: select /*+ use_nl(t2)*/ * from t1 , t2 where t1.c1= t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1263|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1167|
|2 |  HASH JOIN                  |        |300      |957 |
|3 |   PX PARTITION ITERATOR     |        |300      |233 |
|4 |    TABLE SCAN               |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR         |        |500      |528 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|7 |     PX PARTITION ITERATOR   |        |500      |387 |
|8 |      TABLE SCAN             |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 49(end)  ************** 

***************   Case 50   ***************

SQL: select /*+ use_nl(t2)*/ * from t1 join t2 on t2.c1 = 1 and t1.c1= t2.c1; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |EXCHANGE IN REMOTE          |    |1        |93  |
|1 | EXCHANGE OUT REMOTE        |    |1        |93  |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |92  |
|3 |   TABLE GET                |t1  |1        |46  |
|4 |   TABLE GET                |t2  |1        |46  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])

*************** Case 50(end)  ************** 

***************   Case 51   ***************

SQL: select /*+ use_nl(t2)*/ * from t1 , t2 where t1.c1 + t2.c1 = t2.c2; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |NESTED-LOOP JOIN         |        |1351     |3053|
|1 | PX COORDINATOR          |        |300      |464 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|300      |391 |
|3 |   PX PARTITION ITERATOR |        |300      |233 |
|4 |    TABLE SCAN           |t2      |300      |233 |
|5 | MATERIAL                |        |500      |531 |
|6 |  PX COORDINATOR         |        |500      |528 |
|7 |   EXCHANGE OUT DISTR    |:EX20000|500      |481 |
|8 |    PX PARTITION ITERATOR|        |500      |387 |
|9 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c1 + t2.c1 = t2.c2]), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 51(end)  ************** 

***************   Case 52   ***************

SQL: select /*+ use_nl(t2), use_nl(t3)*/ * from t1 , t2, t3 where t1.c1 + t2.c1 = t2.c2 and t1.c1 + t2.c1 = t3.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN               |        |1216     |5011|
|1 | PX COORDINATOR                |        |271      |2650|
|2 |  EXCHANGE OUT DISTR           |:EX10001|271      |2523|
|3 |   NESTED-LOOP JOIN            |        |271      |2242|
|4 |    PX PARTITION ITERATOR      |        |200      |155 |
|5 |     TABLE SCAN                |t3      |200      |155 |
|6 |    MATERIAL                   |        |300      |471 |
|7 |     EXCHANGE IN DISTR         |        |300      |464 |
|8 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |391 |
|9 |       PX PARTITION ITERATOR   |        |300      |233 |
|10|        TABLE SCAN             |t2      |300      |233 |
|11| MATERIAL                      |        |500      |531 |
|12|  PX COORDINATOR               |        |500      |528 |
|13|   EXCHANGE OUT DISTR          |:EX20000|500      |481 |
|14|    PX PARTITION ITERATOR      |        |500      |387 |
|15|     TABLE SCAN                |t1      |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t1.c1 + t2.c1 = t3.c1]), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds([t2.c2 = t3.c1]), nl_params_(nil), batch_join=false
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t1.c1], [t1.c2]), filter(nil)
  12 - output([t1.c1], [t1.c2]), filter(nil)
  13 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 52(end)  ************** 

***************   Case 53   ***************

SQL: select t1.c1 from t1 left join t2 on t1.c1 = t2.c1 where exists (select c1 from t3 limit 1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SUBPLAN FILTER            |        |500      |566 |
|1 | PX COORDINATOR           |        |500      |466 |
|2 |  EXCHANGE OUT DISTR      |:EX10000|500      |439 |
|3 |   PX PARTITION ITERATOR  |        |500      |387 |
|4 |    TABLE SCAN            |t1      |500      |387 |
|5 | LIMIT                    |        |1        |91  |
|6 |  PX COORDINATOR          |        |1        |91  |
|7 |   EXCHANGE OUT DISTR     |:EX20000|1        |91  |
|8 |    LIMIT                 |        |1        |91  |
|9 |     PX PARTITION ITERATOR|        |1        |91  |
|10|      TABLE SCAN          |t3      |1        |91  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), startup_filter([?]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), limit(1), offset(nil)
  6 - output(nil), filter(nil)
  7 - output(nil), filter(nil), dop=1
  8 - output(nil), filter(nil), limit(1), offset(nil)
  9 - output(nil), filter(nil), 
      force partition granule.
  10 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 53(end)  ************** 

***************   Case 54   ***************

SQL: select t1.c1 from t1 left join t2 on t2.c1 = 5; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN|        |500      |649 |
|1 | PX COORDINATOR                 |        |500      |466 |
|2 |  EXCHANGE OUT DISTR            |:EX10000|500      |439 |
|3 |   PX PARTITION ITERATOR        |        |500      |387 |
|4 |    TABLE SCAN                  |t1      |500      |387 |
|5 | MATERIAL                       |        |1        |46  |
|6 |  PX COORDINATOR                |        |1        |46  |
|7 |   EXCHANGE OUT DISTR           |:EX20000|1        |46  |
|8 |    TABLE GET                   |t2      |1        |46  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output(nil), filter(nil)
  6 - output(nil), filter(nil)
  7 - output(nil), filter(nil), is_single, dop=1
  8 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[5 ; 5], 
      range_cond([t2.c1 = ?])

*************** Case 54(end)  ************** 

***************   Case 55   ***************

SQL: select /*+no_use_px*/ t1.c1 from t1 left join t2 tt2  on t1.c1 = tt2.c1, t3 tt3 left join t4 on  tt3.c1=t4.c1 , t2 left join t3 on  t3.c1 = 5 ; 

==================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST   |
------------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN        |        |30000000 |1556011|
|1 | NESTED-LOOP JOIN CARTESIAN       |        |60000    |8522   |
|2 |  NESTED-LOOP OUTER JOIN CARTESIAN|        |300      |408    |
|3 |   PX COORDINATOR                 |        |300      |280    |
|4 |    EXCHANGE OUT DISTR            |:EX10000|300      |263    |
|5 |     PX PARTITION ITERATOR        |        |300      |233    |
|6 |      TABLE SCAN                  |t2      |300      |233    |
|7 |   MATERIAL                       |        |1        |46     |
|8 |    PX COORDINATOR                |        |1        |46     |
|9 |     EXCHANGE OUT DISTR           |:EX20000|1        |46     |
|10|      TABLE GET                   |t3      |1        |46     |
|11|  MATERIAL                        |        |200      |378    |
|12|   PX COORDINATOR                 |        |200      |377    |
|13|    EXCHANGE OUT DISTR            |:EX30001|200      |358    |
|14|     HASH RIGHT OUTER JOIN        |        |200      |320    |
|15|      EXCHANGE IN DISTR           |        |100      |94     |
|16|       EXCHANGE OUT DISTR (PKEY)  |:EX30000|100      |88     |
|17|        TABLE SCAN                |t4      |100      |78     |
|18|      PX PARTITION ITERATOR       |        |200      |155    |
|19|       TABLE SCAN                 |tt3     |200      |155    |
|20| MATERIAL                         |        |500      |468    |
|21|  PX COORDINATOR                  |        |500      |466    |
|22|   EXCHANGE OUT DISTR             |:EX40000|500      |439    |
|23|    PX PARTITION ITERATOR         |        |500      |387    |
|24|     TABLE SCAN                   |t1      |500      |387    |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output(nil), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), dop=1
  5 - output(nil), filter(nil), 
      force partition granule.
  6 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output(nil), filter(nil)
  8 - output(nil), filter(nil)
  9 - output(nil), filter(nil), is_single, dop=1
  10 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t3.c1]), range[5 ; 5], 
      range_cond([t3.c1 = ?])
  11 - output(nil), filter(nil)
  12 - output(nil), filter(nil)
  13 - output(nil), filter(nil), dop=1
  14 - output(nil), filter(nil), 
      equal_conds([tt3.c1 = t4.c1]), other_conds(nil)
  15 - output([t4.c1]), filter(nil)
  16 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  17 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  18 - output([tt3.c1]), filter(nil), 
      affinitize, force partition granule.
  19 - output([tt3.c1]), filter(nil), 
      access([tt3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([tt3.c1]), range(MIN ; MAX)always true
  20 - output([t1.c1]), filter(nil)
  21 - output([t1.c1]), filter(nil)
  22 - output([t1.c1]), filter(nil), dop=1
  23 - output([t1.c1]), filter(nil), 
      force partition granule.
  24 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 55(end)  ************** 

***************   Case 56   ***************

SQL: select t1.c1 from t1 left join  (select t2.c1 as a1, t3.c1 as a2 from t2 left join  t3 on t3.c1 = 5) as a on  a.a1 = 3; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN  |        |500      |745 |
|1 | PX COORDINATOR                   |        |500      |466 |
|2 |  EXCHANGE OUT DISTR              |:EX10000|500      |439 |
|3 |   PX PARTITION ITERATOR          |        |500      |387 |
|4 |    TABLE SCAN                    |t1      |500      |387 |
|5 | MATERIAL                         |        |1        |141 |
|6 |  NESTED-LOOP OUTER JOIN CARTESIAN|        |1        |141 |
|7 |   TABLE GET                      |t2      |1        |46  |
|8 |   PX COORDINATOR                 |        |1        |46  |
|9 |    EXCHANGE OUT DISTR            |:EX20000|1        |46  |
|10|     TABLE GET                    |t3      |1        |46  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output(nil), filter(nil)
  6 - output(nil), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  7 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t2.c1]), range[3 ; 3], 
      range_cond([t2.c1 = ?])
  8 - output(nil), filter(nil)
  9 - output(nil), filter(nil), is_single, dop=1
  10 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t3.c1]), range[5 ; 5], 
      range_cond([t3.c1 = ?])

*************** Case 56(end)  ************** 

***************   Case 57   ***************

SQL: select t1.c1 from t1 left join (t2 left join t3 on t2.c1 = t3.c1) on t2.c1 = 1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN|        |500      |649 |
|1 | PX COORDINATOR                 |        |500      |466 |
|2 |  EXCHANGE OUT DISTR            |:EX10000|500      |439 |
|3 |   PX PARTITION ITERATOR        |        |500      |387 |
|4 |    TABLE SCAN                  |t1      |500      |387 |
|5 | MATERIAL                       |        |1        |46  |
|6 |  PX COORDINATOR                |        |1        |46  |
|7 |   EXCHANGE OUT DISTR           |:EX20000|1        |46  |
|8 |    TABLE GET                   |t2      |1        |46  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output(nil), filter(nil)
  6 - output(nil), filter(nil)
  7 - output(nil), filter(nil), is_single, dop=1
  8 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])

*************** Case 57(end)  ************** 

***************   Case 58   ***************

SQL: select /*+leading(t1 t2)  use_mj(t1 t2)*/ t1.c1, t2.c1 from tr t1 inner join tr t2 on t1.c1 = t2.c1 order by t1.c1 desc; 

==========================================================
|ID|OPERATOR                  |NAME       |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |           |730      |864 |
|1 | EXCHANGE OUT DISTR       |:EX10000   |730      |796 |
|2 |  PX PARTITION ITERATOR   |           |730      |659 |
|3 |   MERGE JOIN             |           |730      |659 |
|4 |    TABLE SCAN            |t1(Reverse)|300      |233 |
|5 |    TABLE SCAN            |t2(Reverse)|300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t2.c1)]), filter(nil), sort_keys([t1.c1, DESC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1, t2.c1)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1]), filter(nil), 
      partition wise, force partition granule, desc.
  3 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t1.c1], [t1.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1], [t2.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 58(end)  ************** 

***************   Case 59   ***************

SQL: use oceanbase; 
***************   Case 60   ***************

SQL: select * from __all_virtual_zone_stat where zone='zone1'; 

=========================================================
|ID|OPERATOR  |NAME                   |EST. ROWS|COST   |
---------------------------------------------------------
|0 |TABLE SCAN|__all_virtual_zone_stat|100000   |2000000|
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([__all_virtual_zone_stat.zone], [__all_virtual_zone_stat.is_merging], [__all_virtual_zone_stat.status], [__all_virtual_zone_stat.server_count], [__all_virtual_zone_stat.resource_pool_count], [__all_virtual_zone_stat.unit_count], [__all_virtual_zone_stat.cluster], [__all_virtual_zone_stat.region], [__all_virtual_zone_stat.spare1], [__all_virtual_zone_stat.spare2], [__all_virtual_zone_stat.spare3], [__all_virtual_zone_stat.spare4], [__all_virtual_zone_stat.spare5], [__all_virtual_zone_stat.spare6]), filter([__all_virtual_zone_stat.zone = ?]), 
      access([__all_virtual_zone_stat.zone], [__all_virtual_zone_stat.is_merging], [__all_virtual_zone_stat.status], [__all_virtual_zone_stat.server_count], [__all_virtual_zone_stat.resource_pool_count], [__all_virtual_zone_stat.unit_count], [__all_virtual_zone_stat.cluster], [__all_virtual_zone_stat.region], [__all_virtual_zone_stat.spare1], [__all_virtual_zone_stat.spare2], [__all_virtual_zone_stat.spare3], [__all_virtual_zone_stat.spare4], [__all_virtual_zone_stat.spare5], [__all_virtual_zone_stat.spare6]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false]

*************** Case 60(end)  ************** 

***************   Case 61   ***************

SQL: select /*+leading(t2 t1) use_nl(t1 t2)*/ t1.c1, t2.c1 from opt.t4 t1 inner join  opt.t2 as t2 on t1.c1 = t2.c1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN        |        |90       |2479|
|1 | PX COORDINATOR         |        |300      |280 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|300      |263 |
|3 |   PX PARTITION ITERATOR|        |300      |233 |
|4 |    TABLE SCAN          |t2      |300      |233 |
|5 | TABLE SCAN             |t1      |9        |5   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=true
  1 - output([t2.c1]), filter(nil)
  2 - output([t2.c1]), filter(nil), dop=1
  3 - output([t2.c1]), filter(nil), 
      force partition granule.
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1], [t1.c2]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 61(end)  ************** 

***************   Case 62   ***************

SQL: select /*+leading(opt.t1 opt.t2) use_nl(t1 t2)*/ t1.c1, t2.c1 from  opt.t1  as t1 inner join  opt.t2 as t2 on t1.c1 = t2.c2 order by t1.c1 desc, t2.c1 desc; 

===============================================================
|ID|OPERATOR                       |NAME       |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |           |270      |5023|
|1 | EXCHANGE OUT DISTR            |:EX10001   |270      |4988|
|2 |  SORT                         |           |270      |4914|
|3 |   NESTED-LOOP JOIN            |           |270      |4727|
|4 |    PX PARTITION ITERATOR      |           |500      |387 |
|5 |     TABLE SCAN                |t1(Reverse)|500      |387 |
|6 |    MATERIAL                   |           |300      |319 |
|7 |     EXCHANGE IN DISTR         |           |300      |317 |
|8 |      EXCHANGE OUT DISTR (PKEY)|:EX10000   |300      |289 |
|9 |       PX PARTITION ITERATOR   |           |300      |233 |
|10|        TABLE SCAN             |t2         |300      |233 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t2.c1)]), filter(nil), sort_keys([t1.c1, DESC], [t2.c1, DESC])
  1 - output([t1.c1], [t2.c1], [INTERNAL_FUNCTION(t1.c1, t2.c1)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1]), filter(nil), sort_keys([t1.c1, DESC], [t2.c1, DESC])
  3 - output([t1.c1], [t2.c1]), filter(nil), 
      conds([t1.c1 = t2.c2]), nl_params_(nil), batch_join=false
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1], [t2.c2]), filter(nil)
  7 - output([t2.c1], [t2.c2]), filter(nil)
  8 - (#keys=1, [t2.c2]), output([t2.c1], [t2.c2]), filter(nil), dop=1
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 62(end)  ************** 

***************   Case 63   ***************

SQL: select /*+use_nl(opt.t1 opt.t2 opt.t3)*/ * from opt.t1 as t1 left join opt.t2 as t2 on t1.c1 = t2.c1 and t1.c1 = 1 and t2.c1 = 1 left join opt.t3 as t3 on t2.c1 = t3.c1 and t3.c1 in (1, 2) order by t1.c1; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT        |        |500      |1832|
|1 | EXCHANGE OUT DISTR              |:EX10002|500      |1559|
|2 |  SORT                           |        |500      |954 |
|3 |   HASH OUTER JOIN               |        |500      |562 |
|4 |    PX PARTITION ITERATOR        |        |500      |387 |
|5 |     TABLE SCAN                  |t1      |500      |387 |
|6 |    EXCHANGE IN DISTR            |        |1        |53  |
|7 |     EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |52  |
|8 |      NESTED-LOOP OUTER JOIN     |        |1        |51  |
|9 |       EXCHANGE IN DISTR         |        |1        |47  |
|10|        EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|11|         TABLE GET               |t2      |1        |46  |
|12|       PX PARTITION ITERATOR     |        |2        |7   |
|13|        TABLE GET                |t3      |2        |7   |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  9 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil)
  10 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil), is_single, dop=1
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?], [t2.c1 = ?])
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 IN (?, ?)], [? = t3.c1])

*************** Case 63(end)  ************** 

