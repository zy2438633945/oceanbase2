***************   Case 1   ***************

SQL: select * from t1 where c2 > 0 and c2 < 10; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(0,MAX ; 10,MIN), 
      range_cond([t1.c2 > ?], [t1.c2 < ?])

*************** Case 1(end)  ************** 

***************   Case 2   ***************

SQL: select/*+index(t1 idx_t1_c2)*/ * from t1 where c2 > 0 and c2 < 10; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(0,MAX ; 10,MIN), 
      range_cond([t1.c2 > ?], [t1.c2 < ?])

*************** Case 2(end)  ************** 

***************   Case 3   ***************

SQL: select c1 from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 3(end)  ************** 

***************   Case 4   ***************

SQL: select c2 from t1 order by c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |1        |1   |
|1 | EXCHANGE OUT DISTR       |:EX10000     |1        |1   |
|2 |  SORT                    |             |1        |1   |
|3 |   PX PARTITION ITERATOR  |             |1        |1   |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2], [INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  3 - output([t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 4(end)  ************** 

***************   Case 5   ***************

SQL: select c1, c2 from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 5(end)  ************** 

***************   Case 6   ***************

SQL: select c1 + c2 from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1 + t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1 + t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 6(end)  ************** 

***************   Case 7   ***************

SQL: select c1 from t1 limit 100; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |LIMIT                    |             |1        |1   |
|1 | PX COORDINATOR          |             |1        |1   |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |1   |
|3 |   LIMIT                 |             |1        |1   |
|4 |    PX PARTITION ITERATOR|             |1        |1   |
|5 |     TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 7(end)  ************** 

***************   Case 8   ***************

SQL: select * from t1 limit 100; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |LIMIT                    |             |1        |1   |
|1 | PX COORDINATOR          |             |1        |1   |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |1   |
|3 |   LIMIT                 |             |1        |1   |
|4 |    PX PARTITION ITERATOR|             |1        |1   |
|5 |     TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 8(end)  ************** 

***************   Case 9   ***************

SQL: select * from t1 order by c1,c2 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |1        |228 |
|1 | PX COORDINATOR MERGE SORT |        |1        |228 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|1        |228 |
|3 |   TOP-N SORT              |        |1        |228 |
|4 |    PX PARTITION ITERATOR  |        |1        |228 |
|5 |     TABLE SCAN            |t1      |1        |228 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), topn(100), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 9(end)  ************** 

***************   Case 10   ***************

SQL: select c1 from t1 order by c1 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |1        |228 |
|1 | PX COORDINATOR MERGE SORT |        |1        |228 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|1        |228 |
|3 |   TOP-N SORT              |        |1        |228 |
|4 |    PX PARTITION ITERATOR  |        |1        |228 |
|5 |     TABLE SCAN            |t1      |1        |228 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), topn(100), local merge sort
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 10(end)  ************** 

***************   Case 11   ***************

SQL: select c1 from t1 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |1        |1   |
|1 | PX COORDINATOR MERGE SORT |             |1        |1   |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |1        |1   |
|3 |   TOP-N SORT              |             |1        |1   |
|4 |    PX PARTITION ITERATOR  |             |1        |1   |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(100), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 11(end)  ************** 

***************   Case 12   ***************

SQL: select c1 from t1 where c1 > 0 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |1        |1   |
|1 | PX COORDINATOR MERGE SORT |             |1        |1   |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |1        |1   |
|3 |   TOP-N SORT              |             |1        |1   |
|4 |    PX PARTITION ITERATOR  |             |1        |1   |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(100), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 12(end)  ************** 

***************   Case 13   ***************

SQL: select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |1        |1   |
|1 | PX COORDINATOR MERGE SORT |             |1        |1   |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |1        |1   |
|3 |   TOP-N SORT              |             |1        |1   |
|4 |    PX PARTITION ITERATOR  |             |1        |1   |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(100), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(NULL,MAX ; 0,MIN), 
      range_cond([t1.c2 < ?])

*************** Case 13(end)  ************** 

***************   Case 14   ***************

SQL: select c1 from t1 group by c1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 14(end)  ************** 

***************   Case 15   ***************

SQL: select c2, sum(c1) from t1 group by c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
<<<<<<< HEAD
|0 |PX COORDINATOR                 |             |1        |229 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |229 |
|2 |  MERGE GROUP BY               |             |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|5 |     PX PARTITION ITERATOR     |             |1        |228 |
|6 |      MERGE GROUP BY           |             |1        |228 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |PX COORDINATOR                 |             |1        |1   |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |1   |
|2 |  MERGE GROUP BY               |             |1        |1   |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR     |             |1        |1   |
|6 |      TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 15(end)  ************** 

***************   Case 16   ***************

SQL: select c2, avg(c1) from t1 group by c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
<<<<<<< HEAD
|0 |PX COORDINATOR                 |             |1        |229 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |229 |
|2 |  MERGE GROUP BY               |             |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|5 |     PX PARTITION ITERATOR     |             |1        |228 |
|6 |      MERGE GROUP BY           |             |1        |228 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |PX COORDINATOR                 |             |1        |2   |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |1   |
|2 |  MERGE GROUP BY               |             |1        |1   |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR     |             |1        |1   |
|6 |      TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 16(end)  ************** 

***************   Case 17   ***************

SQL: select c1, c1 + c2 from t1 where c1 > 0 limit 100; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |LIMIT                    |        |1        |228 |
|1 | PX COORDINATOR          |        |1        |228 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |228 |
|3 |   LIMIT                 |        |1        |228 |
|4 |    PX PARTITION ITERATOR|        |1        |228 |
|5 |     TABLE SCAN          |t1      |1        |228 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 17(end)  ************** 

***************   Case 18   ***************

SQL: select c1 from t1 where c1 > 0; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |228 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |228 |
|2 |  PX PARTITION ITERATOR|        |1        |228 |
|3 |   TABLE SCAN          |t1      |1        |228 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 18(end)  ************** 

***************   Case 19   ***************

SQL: select c2 from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
<<<<<<< HEAD
|0 |LIMIT                            |             |1        |229 |
|1 | PX COORDINATOR MERGE SORT       |             |1        |229 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |228 |
|3 |   LIMIT                         |             |1        |228 |
|4 |    MERGE GROUP BY               |             |1        |228 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|7 |       PX PARTITION ITERATOR     |             |1        |228 |
|8 |        MERGE GROUP BY           |             |1        |228 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |LIMIT                            |             |1        |1   |
|1 | PX COORDINATOR MERGE SORT       |             |1        |1   |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |1   |
|3 |   LIMIT                         |             |1        |1   |
|4 |    MERGE GROUP BY               |             |1        |1   |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|7 |       PX PARTITION ITERATOR     |             |1        |1   |
|8 |        TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c2]), filter(nil), dop=1
  3 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  5 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  7 - output([t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 19(end)  ************** 

***************   Case 20   ***************

SQL: select sum(c1) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
<<<<<<< HEAD
|0 |LIMIT                            |             |1        |229 |
|1 | PX COORDINATOR MERGE SORT       |             |1        |229 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |229 |
|3 |   LIMIT                         |             |1        |228 |
|4 |    MERGE GROUP BY               |             |1        |228 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|7 |       PX PARTITION ITERATOR     |             |1        |228 |
|8 |        MERGE GROUP BY           |             |1        |228 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |LIMIT                            |             |1        |1   |
|1 | PX COORDINATOR MERGE SORT       |             |1        |1   |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |1   |
|3 |   LIMIT                         |             |1        |1   |
|4 |    MERGE GROUP BY               |             |1        |1   |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|7 |       PX PARTITION ITERATOR     |             |1        |1   |
|8 |        TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  7 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      force partition granule.
  8 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 20(end)  ************** 

***************   Case 21   ***************

SQL: select sum(c1) from t1 where c1 > 0 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
<<<<<<< HEAD
|0 |LIMIT                            |             |1        |229 |
|1 | PX COORDINATOR MERGE SORT       |             |1        |229 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |229 |
|3 |   LIMIT                         |             |1        |228 |
|4 |    MERGE GROUP BY               |             |1        |228 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|7 |       PX PARTITION ITERATOR     |             |1        |228 |
|8 |        MERGE GROUP BY           |             |1        |228 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |LIMIT                            |             |1        |1   |
|1 | PX COORDINATOR MERGE SORT       |             |1        |1   |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |1   |
|3 |   LIMIT                         |             |1        |1   |
|4 |    MERGE GROUP BY               |             |1        |1   |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|7 |       PX PARTITION ITERATOR     |             |1        |1   |
|8 |        TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  7 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      force partition granule.
  8 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 21(end)  ************** 

***************   Case 22   ***************

SQL: select count(c1) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
<<<<<<< HEAD
|0 |LIMIT                            |             |1        |229 |
|1 | PX COORDINATOR MERGE SORT       |             |1        |229 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |229 |
|3 |   LIMIT                         |             |1        |228 |
|4 |    MERGE GROUP BY               |             |1        |228 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|7 |       PX PARTITION ITERATOR     |             |1        |228 |
|8 |        MERGE GROUP BY           |             |1        |228 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |LIMIT                            |             |1        |1   |
|1 | PX COORDINATOR MERGE SORT       |             |1        |1   |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |1   |
|3 |   LIMIT                         |             |1        |1   |
|4 |    MERGE GROUP BY               |             |1        |1   |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|7 |       PX PARTITION ITERATOR     |             |1        |1   |
|8 |        TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  5 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  7 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  8 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 22(end)  ************** 

***************   Case 23   ***************

SQL: select count(*) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
<<<<<<< HEAD
|0 |LIMIT                            |             |1        |229 |
|1 | PX COORDINATOR MERGE SORT       |             |1        |229 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |228 |
|3 |   LIMIT                         |             |1        |228 |
|4 |    MERGE GROUP BY               |             |1        |228 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|7 |       PX PARTITION ITERATOR     |             |1        |228 |
|8 |        MERGE GROUP BY           |             |1        |228 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |LIMIT                            |             |1        |1   |
|1 | PX COORDINATOR MERGE SORT       |             |1        |1   |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |1   |
|3 |   LIMIT                         |             |1        |1   |
|4 |    MERGE GROUP BY               |             |1        |1   |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|7 |       PX PARTITION ITERATOR     |             |1        |1   |
|8 |        TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  5 - output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), dop=1
  7 - output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), 
      force partition granule.
  8 - output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(*)])
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 23(end)  ************** 

***************   Case 24   ***************

SQL: select sum(c1), count(*) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
<<<<<<< HEAD
|0 |LIMIT                            |             |1        |229 |
|1 | PX COORDINATOR MERGE SORT       |             |1        |229 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |229 |
|3 |   LIMIT                         |             |1        |228 |
|4 |    MERGE GROUP BY               |             |1        |228 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|7 |       PX PARTITION ITERATOR     |             |1        |228 |
|8 |        MERGE GROUP BY           |             |1        |228 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |LIMIT                            |             |1        |2   |
|1 | PX COORDINATOR MERGE SORT       |             |1        |2   |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |1   |
|3 |   LIMIT                         |             |1        |1   |
|4 |    MERGE GROUP BY               |             |1        |1   |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|7 |       PX PARTITION ITERATOR     |             |1        |1   |
|8 |        TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), dop=1
  7 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), 
      force partition granule.
  8 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 24(end)  ************** 

***************   Case 25   ***************

SQL: select c2, count(c1) from t1 group by c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
<<<<<<< HEAD
|0 |PX COORDINATOR                 |             |1        |229 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |229 |
|2 |  MERGE GROUP BY               |             |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|5 |     PX PARTITION ITERATOR     |             |1        |228 |
|6 |      MERGE GROUP BY           |             |1        |228 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |PX COORDINATOR                 |             |1        |1   |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |1   |
|2 |  MERGE GROUP BY               |             |1        |1   |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR     |             |1        |1   |
|6 |      TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 25(end)  ************** 

***************   Case 26   ***************

SQL: select t1.c1 from t1, t2 limit 100; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |LIMIT                        |             |1        |138 |
|1 | NESTED-LOOP JOIN CARTESIAN  |             |1        |138 |
|2 |  SUBPLAN SCAN               |VIEW1        |1        |1   |
|3 |   LIMIT                     |             |1        |1   |
|4 |    PX COORDINATOR           |             |1        |1   |
|5 |     EXCHANGE OUT DISTR      |:EX10000     |1        |1   |
|6 |      LIMIT                  |             |1        |1   |
|7 |       PX PARTITION ITERATOR |             |1        |1   |
|8 |        TABLE SCAN           |t1(idx_t1_c2)|1        |1   |
|9 |  MATERIAL                   |             |1        |137 |
|10|   SUBPLAN SCAN              |VIEW2        |1        |137 |
|11|    LIMIT                    |             |1        |137 |
|12|     PX COORDINATOR          |             |1        |137 |
|13|      EXCHANGE OUT DISTR     |:EX20000     |1        |137 |
|14|       LIMIT                 |             |1        |137 |
|15|        PX PARTITION ITERATOR|             |1        |137 |
|16|         TABLE SCAN          |t2           |1        |137 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([VIEW1.t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  3 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  7 - output([t1.c1]), filter(nil), 
      force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  9 - output(nil), filter(nil)
  10 - output(nil), filter(nil), 
      access(nil)
  11 - output([1]), filter(nil), limit(100), offset(nil)
  12 - output(nil), filter(nil)
  13 - output(nil), filter(nil), dop=1
  14 - output(nil), filter(nil), limit(100), offset(nil)
  15 - output(nil), filter(nil), 
      force partition granule.
  16 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 26(end)  ************** 

***************   Case 27   ***************

SQL: select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |LIMIT                          |        |1        |173 |
|1 | PX COORDINATOR                |        |1        |173 |
|2 |  EXCHANGE OUT DISTR           |:EX10001|1        |173 |
|3 |   LIMIT                       |        |1        |173 |
|4 |    NESTED-LOOP JOIN           |        |1        |173 |
|5 |     EXCHANGE IN DISTR         |        |1        |137 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|7 |       PX PARTITION ITERATOR   |        |1        |137 |
|8 |        TABLE SCAN             |t2      |1        |137 |
|9 |     PX PARTITION ITERATOR     |        |1        |30  |
|10|      TABLE GET                |t1      |1        |30  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  5 - output([PARTITION_ID], [t2.c1]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([PARTITION_ID], [t2.c1]), filter(nil), dop=1
  7 - output([t2.c1]), filter(nil), 
      force partition granule.
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 27(end)  ************** 

***************   Case 28   ***************

SQL: select t1.c1 from t1, t2, t3 where t1.c1=t2.c1       and t1.c2>t2.c2       and t2.c3=t3.c3       and t3.c1>10; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |HASH JOIN                     |        |1        |237 |
|1 | PX COORDINATOR               |        |1        |145 |
|2 |  EXCHANGE OUT DISTR          |:EX10001|1        |145 |
|3 |   NESTED-LOOP JOIN           |        |1        |145 |
|4 |    EXCHANGE IN DISTR         |        |1        |138 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |138 |
|6 |      PX PARTITION ITERATOR   |        |1        |137 |
|7 |       TABLE SCAN             |t2      |1        |137 |
|8 |    PX PARTITION ITERATOR     |        |1        |30  |
|9 |     TABLE GET                |t1      |1        |30  |
|10| PX COORDINATOR               |        |1        |92  |
|11|  EXCHANGE OUT DISTR          |:EX20000|1        |92  |
|12|   PX PARTITION ITERATOR      |        |1        |92  |
|13|    TABLE SCAN                |t3      |1        |92  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t1.c1], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t2.c3]), filter(nil), dop=1
  3 - output([t1.c1], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c2], [t2.c1]), batch_join=false
  4 - output([PARTITION_ID], [t2.c2], [t2.c1], [t2.c3]), filter(nil)
  5 - (#keys=1, [t2.c1]), output([PARTITION_ID], [t2.c2], [t2.c1], [t2.c3]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  8 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t1.c1]), filter([t1.c2 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])
  10 - output([t3.c3]), filter(nil)
  11 - output([t3.c3]), filter(nil), dop=1
  12 - output([t3.c3]), filter(nil), 
      force partition granule.
  13 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(10 ; MAX), 
      range_cond([t3.c1 > ?])

*************** Case 28(end)  ************** 

***************   Case 29   ***************

SQL: select opt.t3.c2 from opt.t1,t2,t3 where t1.c1+t2.c1=t3.c1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |1        |145 |
|1 | EXCHANGE OUT DISTR            |:EX10003     |1        |145 |
|2 |  NESTED-LOOP JOIN             |             |1        |145 |
|3 |   EXCHANGE IN DISTR           |             |1        |138 |
|4 |    EXCHANGE OUT DISTR (PKEY)  |:EX10002     |1        |138 |
|5 |     NESTED-LOOP JOIN CARTESIAN|             |1        |137 |
|6 |      EXCHANGE IN DISTR        |             |1        |137 |
|7 |       EXCHANGE OUT DISTR      |:EX10000     |1        |137 |
|8 |        PX PARTITION ITERATOR  |             |1        |137 |
|9 |         TABLE SCAN            |t2           |1        |137 |
|10|      MATERIAL                 |             |1        |1   |
|11|       EXCHANGE IN DISTR       |             |1        |1   |
|12|        EXCHANGE OUT DISTR     |:EX10001     |1        |1   |
|13|         PX PARTITION ITERATOR |             |1        |1   |
|14|          TABLE SCAN           |t1(idx_t1_c2)|1        |1   |
|15|   PX PARTITION ITERATOR       |             |1        |12  |
|16|    TABLE GET                  |t3           |1        |12  |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t3.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t3.c2)]), filter(nil), dop=1
  2 - output([t3.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1 + t2.c1]), batch_join=false
  3 - output([PARTITION_ID], [t1.c1 + t2.c1]), filter(nil)
  4 - (#keys=1, [t1.c1 + t2.c1]), output([PARTITION_ID], [t1.c1 + t2.c1]), filter(nil), is_single, dop=1
  5 - output([t2.c1], [t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), dop=1
  13 - output([t1.c1]), filter(nil), 
      force partition granule.
  14 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  15 - output([t3.c2]), filter(nil), 
      affinitize, force partition granule.
  16 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([? = t3.c1])

*************** Case 29(end)  ************** 

***************   Case 30   ***************

SQL: select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3; 

================================================================
|ID|OPERATOR                      |NAME         |EST. ROWS|COST|
----------------------------------------------------------------
|0 |HASH JOIN                     |             |1        |147 |
|1 | PX COORDINATOR               |             |1        |138 |
|2 |  EXCHANGE OUT DISTR          |:EX10000     |1        |137 |
|3 |   PX PARTITION ITERATOR      |             |1        |137 |
|4 |    TABLE SCAN                |t2           |1        |137 |
|5 | PX COORDINATOR               |             |1        |9   |
|6 |  EXCHANGE OUT DISTR          |:EX20001     |1        |8   |
|7 |   NESTED-LOOP JOIN           |             |1        |8   |
|8 |    EXCHANGE IN DISTR         |             |1        |1   |
|9 |     EXCHANGE OUT DISTR (PKEY)|:EX20000     |1        |1   |
|10|      PX PARTITION ITERATOR   |             |1        |1   |
|11|       TABLE SCAN             |t1(idx_t1_c2)|1        |1   |
|12|    PX PARTITION ITERATOR     |             |1        |12  |
|13|     TABLE GET                |t3           |1        |12  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  4 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil)
  6 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  8 - output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  9 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  12 - output([t3.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([? = t3.c1])

*************** Case 30(end)  ************** 

***************   Case 31   ***************

SQL: select t1.c1 from t1,t2,t3 where t1.c1=t2.c1 and t1.c1+t2.c1=t3.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |151 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |151 |
|2 |  NESTED-LOOP JOIN              |        |1        |151 |
|3 |   EXCHANGE IN DISTR            |        |1        |144 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |144 |
|5 |     NESTED-LOOP JOIN           |        |1        |144 |
|6 |      EXCHANGE IN DISTR         |        |1        |137 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|8 |        PX PARTITION ITERATOR   |        |1        |137 |
|9 |         TABLE SCAN             |t2      |1        |137 |
|10|      PX PARTITION ITERATOR     |        |1        |30  |
|11|       TABLE GET                |t1      |1        |30  |
|12|   PX PARTITION ITERATOR        |        |1        |12  |
|13|    TABLE GET                   |t3      |1        |12  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1 + t2.c1]), batch_join=false
  3 - output([t1.c1], [PARTITION_ID], [t1.c1 + t2.c1]), filter(nil)
  4 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1], [PARTITION_ID], [t1.c1 + t2.c1]), filter(nil), dop=1
  5 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  6 - output([t2.c1], [PARTITION_ID]), filter(nil)
  7 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])
  12 - output(nil), filter(nil), 
      affinitize, force partition granule.
  13 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([? = t3.c1])

*************** Case 31(end)  ************** 

***************   Case 32   ***************

SQL: select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |NESTED-LOOP JOIN               |             |1        |146 |
|1 | HASH JOIN                     |             |1        |9   |
|2 |  PX COORDINATOR               |             |1        |1   |
|3 |   EXCHANGE OUT DISTR          |:EX10000     |1        |1   |
|4 |    PX PARTITION ITERATOR      |             |1        |1   |
|5 |     TABLE SCAN                |tt(idx_t1_c2)|1        |1   |
|6 |  PX COORDINATOR               |             |1        |8   |
|7 |   EXCHANGE OUT DISTR          |:EX20001     |1        |8   |
|8 |    NESTED-LOOP JOIN           |             |1        |8   |
|9 |     EXCHANGE IN DISTR         |             |1        |1   |
|10|      EXCHANGE OUT DISTR (PKEY)|:EX20000     |1        |1   |
|11|       PX PARTITION ITERATOR   |             |1        |1   |
|12|        TABLE SCAN             |t1(idx_t1_c2)|1        |1   |
|13|     PX PARTITION ITERATOR     |             |1        |12  |
|14|      TABLE GET                |t3           |1        |12  |
|15| MATERIAL                      |             |1        |137 |
|16|  PX COORDINATOR               |             |1        |137 |
|17|   EXCHANGE OUT DISTR          |:EX30000     |1        |137 |
|18|    PX PARTITION ITERATOR      |             |1        |137 |
|19|     TABLE SCAN                |t2           |1        |137 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  2 - output([tt.c1], [tt.c2]), filter(nil)
  3 - output([tt.c1], [tt.c2]), filter(nil), dop=1
  4 - output([tt.c1], [tt.c2]), filter(nil), 
      force partition granule.
  5 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c2], [tt.c1]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  9 - output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  10 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  13 - output(nil), filter(nil), 
      affinitize, force partition granule.
  14 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([? = t3.c1])
  15 - output([t2.c1]), filter(nil)
  16 - output([t2.c1]), filter(nil)
  17 - output([t2.c1]), filter(nil), dop=1
  18 - output([t2.c1]), filter(nil), 
      force partition granule.
  19 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 32(end)  ************** 

***************   Case 33   ***************

SQL: select t1.c1 from t1, (select * from t2) as t where t1.c1=t.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |144 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |144 |
|2 |  NESTED-LOOP JOIN           |        |1        |144 |
|3 |   EXCHANGE IN DISTR         |        |1        |137 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t2      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |30  |
|8 |    TABLE GET                |t1      |1        |30  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([PARTITION_ID], [t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([PARTITION_ID], [t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 33(end)  ************** 

***************   Case 34   ***************

SQL: select t1.c1 from t1, (select * from t2 where c2>1 order by c1 limit 10) as t where t1.c1=t.c1; 

================================================================
|ID|OPERATOR                           |NAME    |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                     |        |1        |138 |
|1 | EXCHANGE OUT DISTR                |:EX10002|1        |138 |
|2 |  NESTED-LOOP JOIN                 |        |1        |138 |
|3 |   EXCHANGE IN DISTR               |        |1        |137 |
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10001|1        |137 |
|5 |     SUBPLAN SCAN                  |t       |1        |137 |
|6 |      LIMIT                        |        |1        |137 |
|7 |       EXCHANGE IN MERGE SORT DISTR|        |1        |137 |
|8 |        EXCHANGE OUT DISTR         |:EX10000|1        |137 |
|9 |         TOP-N SORT                |        |1        |137 |
|10|          PX PARTITION ITERATOR    |        |1        |137 |
|11|           TABLE SCAN              |t2      |1        |137 |
|12|   PX PARTITION ITERATOR           |        |1        |30  |
|13|    TABLE GET                      |t1      |1        |30  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t.c1]), batch_join=false
  3 - output([PARTITION_ID], [t.c1]), filter(nil)
  4 - (#keys=1, [t.c1]), output([PARTITION_ID], [t.c1]), filter(nil), is_single, dop=1
  5 - output([t.c1]), filter(nil), 
      access([t.c1])
  6 - output([t2.c1]), filter(nil), limit(10), offset(nil)
  7 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  8 - output([t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), topn(10), local merge sort
  10 - output([t2.c1]), filter(nil), 
      force partition granule.
  11 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      limit(10), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 34(end)  ************** 

***************   Case 35   ***************

SQL: select c1, c1+c2 from t1 where c1 > 100 order by c2 + c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |1        |228 |
|1 | EXCHANGE OUT DISTR       |:EX10000|1        |228 |
|2 |  SORT                    |        |1        |228 |
|3 |   PX PARTITION ITERATOR  |        |1        |228 |
|4 |    TABLE SCAN            |t1      |1        |228 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 + t1.c2)]), filter(nil), sort_keys([t1.c2 + t1.c1, ASC])
  1 - output([t1.c2 + t1.c1], [INTERNAL_FUNCTION(t1.c1, t1.c1 + t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2 + t1.c1], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2 + t1.c1, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(100 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 35(end)  ************** 

***************   Case 36   ***************

SQL: select * from t1,t2 where t1.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |146 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |145 |
|2 |  NESTED-LOOP JOIN           |        |1        |145 |
|3 |   EXCHANGE IN DISTR         |        |1        |138 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |138 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t2      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |30  |
|8 |    TABLE GET                |t1      |1        |30  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 36(end)  ************** 

***************   Case 37   ***************

SQL: select t1.c1, t2.c2, t2.c3 from t1,t2 where t1.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |145 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |145 |
|2 |  NESTED-LOOP JOIN           |        |1        |145 |
|3 |   EXCHANGE IN DISTR         |        |1        |138 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |138 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t2      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |30  |
|8 |    TABLE GET                |t1      |1        |30  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c2], [t2.c3], [t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([PARTITION_ID], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([PARTITION_ID], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 37(end)  ************** 

***************   Case 38   ***************

SQL: select c2 from t1 order by c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |1        |228 |
|1 | EXCHANGE OUT DISTR       |:EX10000|1        |228 |
|2 |  SORT                    |        |1        |228 |
|3 |   PX PARTITION ITERATOR  |        |1        |228 |
|4 |    TABLE SCAN            |t1      |1        |228 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 38(end)  ************** 

***************   Case 39   ***************

SQL: select t1.c1, t2.c2, t2.c3 from t1,t2 where t1.c1 = t2.c1 order by t1.c2; 

================================================================
|ID|OPERATOR                      |NAME         |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |             |1        |9   |
|1 | EXCHANGE OUT DISTR           |:EX10001     |1        |9   |
|2 |  SORT                        |             |1        |8   |
|3 |   NESTED-LOOP JOIN           |             |1        |8   |
|4 |    EXCHANGE IN DISTR         |             |1        |1   |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000     |1        |1   |
|6 |      PX PARTITION ITERATOR   |             |1        |1   |
|7 |       TABLE SCAN             |t1(idx_t1_c2)|1        |1   |
|8 |    PX PARTITION ITERATOR     |             |1        |18  |
|9 |     TABLE GET                |t2           |1        |18  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2], [INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  3 - output([t1.c2], [t1.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  4 - output([t1.c2], [t1.c1], [PARTITION_ID]), filter(nil)
  5 - (#keys=1, [t1.c1]), output([t1.c2], [t1.c1], [PARTITION_ID]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  8 - output([t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])

*************** Case 39(end)  ************** 

***************   Case 40   ***************

SQL: select /*+ INDEX(t1 INVALID_INDEX) */ c1 from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 40(end)  ************** 

***************   Case 41   ***************

SQL: select c1 from t1 as t order by c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |1        |228 |
|1 | EXCHANGE OUT DISTR       |:EX10000|1        |228 |
|2 |  SORT                    |        |1        |228 |
|3 |   PX PARTITION ITERATOR  |        |1        |228 |
|4 |    TABLE SCAN            |t       |1        |228 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t.c1)]), filter(nil), sort_keys([t.c1, ASC])
  1 - output([t.c1], [INTERNAL_FUNCTION(t.c1)]), filter(nil), dop=1
  2 - output([t.c1]), filter(nil), sort_keys([t.c1, ASC]), local merge sort
  3 - output([t.c1]), filter(nil), 
      force partition granule.
  4 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 41(end)  ************** 

***************   Case 42   ***************

SQL: select c1, c1+c2 from t1 where c1 > 100 limit 1, 10; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |LIMIT                    |        |0        |228 |
|1 | PX COORDINATOR          |        |1        |228 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |228 |
|3 |   LIMIT                 |        |1        |228 |
|4 |    PX PARTITION ITERATOR|        |1        |228 |
|5 |     TABLE SCAN          |t1      |1        |228 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), limit(10), offset(?)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), limit(10 + ?), offset(nil)
  4 - output([t1.c1], [t1.c2], [10 + ?]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2], [10 + ?]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(10 + ?), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(100 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 42(end)  ************** 

***************   Case 43   ***************

SQL: select * from t1 where c1 in (3, 4); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |2        |93  |
|1 | EXCHANGE OUT DISTR    |:EX10000|2        |93  |
|2 |  PX PARTITION ITERATOR|        |2        |92  |
|3 |   TABLE GET           |t1      |2        |92  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[3-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], [4 ; 4], 
      range_cond([t1.c1 IN (?, ?)])

*************** Case 43(end)  ************** 

***************   Case 44   ***************

SQL: select * from t1 where c1 in (3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p3), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 44(end)  ************** 

***************   Case 45   ***************

SQL: select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |99  |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |99  |
|2 |  NESTED-LOOP JOIN           |        |1        |99  |
|3 |   EXCHANGE IN DISTR         |        |1        |92  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |92  |
|5 |     PX PARTITION ITERATOR   |        |1        |92  |
|6 |      TABLE SCAN             |t3      |1        |92  |
|7 |   PX PARTITION ITERATOR     |        |1        |18  |
|8 |    TABLE GET                |t2      |1        |18  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t3.c3], [t3.c2], [t3.c1], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t3.c3], [t3.c2], [t3.c1]), batch_join=false
  3 - output([t3.c3], [t3.c2], [t3.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t3.c1]), output([t3.c3], [t3.c2], [t3.c1], [PARTITION_ID]), filter(nil), dop=1
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c3 > ?], [t2.c2 < ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 45(end)  ************** 

***************   Case 46   ***************

SQL: select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |138 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |138 |
|2 |  NESTED-LOOP JOIN           |        |1        |138 |
|3 |   EXCHANGE IN DISTR         |        |1        |137 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t2      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |30  |
|8 |    TABLE GET                |t1      |1        |30  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([PARTITION_ID], [t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([PARTITION_ID], [t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 46(end)  ************** 

***************   Case 47   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |236 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |235 |
|2 |  NESTED-LOOP OUTER JOIN     |        |1        |235 |
|3 |   EXCHANGE IN DISTR         |        |1        |228 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |228 |
|5 |     PX PARTITION ITERATOR   |        |1        |228 |
|6 |      TABLE SCAN             |t1      |1        |228 |
|7 |   PX PARTITION ITERATOR     |        |1        |18  |
|8 |    TABLE GET                |t2      |1        |18  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter([? > ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 > ?], [? = t2.c1])

*************** Case 47(end)  ************** 

***************   Case 48   ***************

SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is null; 

==============================================================
|ID|OPERATOR                    |NAME         |EST. ROWS|COST|
--------------------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN       |             |1        |138 |
|1 | PX COORDINATOR             |             |1        |1   |
|2 |  EXCHANGE OUT DISTR        |:EX10000     |1        |1   |
|3 |   PX PARTITION ITERATOR    |             |1        |1   |
|4 |    TABLE SCAN              |t1(idx_t1_c2)|1        |1   |
|5 | MATERIAL                   |             |1        |137 |
|6 |  SUBPLAN SCAN              |VIEW1        |1        |137 |
|7 |   LIMIT                    |             |1        |137 |
|8 |    PX COORDINATOR          |             |1        |137 |
|9 |     EXCHANGE OUT DISTR     |:EX20000     |1        |137 |
|10|      LIMIT                 |             |1        |137 |
|11|       PX PARTITION ITERATOR|             |1        |137 |
|12|        TABLE SCAN          |t2           |1        |137 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [?], [?], [?]), filter(nil), 
      conds([t1.c1 > ?]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  5 - output(nil), filter(nil)
  6 - output(nil), filter(nil), 
      access(nil)
  7 - output([1]), filter(nil), limit(1), offset(nil)
  8 - output(nil), filter(nil)
  9 - output(nil), filter(nil), dop=1
  10 - output(nil), filter(nil), limit(1), offset(nil)
  11 - output(nil), filter(nil), 
      force partition granule.
  12 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 48(end)  ************** 

***************   Case 49   ***************

SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|             |1        |138 |
|1 | PX COORDINATOR           |             |1        |138 |
|2 |  EXCHANGE OUT DISTR      |:EX10000     |1        |138 |
|3 |   PX PARTITION ITERATOR  |             |1        |137 |
|4 |    TABLE SCAN            |t2           |1        |137 |
|5 | MATERIAL                 |             |1        |1   |
|6 |  PX COORDINATOR          |             |1        |1   |
|7 |   EXCHANGE OUT DISTR     |:EX20000     |1        |1   |
|8 |    PX PARTITION ITERATOR |             |1        |1   |
|9 |     TABLE SCAN           |t1(idx_t1_c2)|1        |1   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 49(end)  ************** 

***************   Case 50   ***************

SQL: select /*+no_use_px*/ t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |106 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |106 |
|2 |  NESTED-LOOP JOIN              |        |1        |106 |
|3 |   EXCHANGE IN DISTR            |        |1        |99  |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |99  |
|5 |     NESTED-LOOP JOIN           |        |1        |99  |
|6 |      EXCHANGE IN DISTR         |        |1        |92  |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |92  |
|8 |        PX PARTITION ITERATOR   |        |1        |92  |
|9 |         TABLE SCAN             |t3      |1        |92  |
|10|      PX PARTITION ITERATOR     |        |1        |30  |
|11|       TABLE GET                |t1      |1        |30  |
|12|   PX PARTITION ITERATOR        |        |1        |18  |
|13|    TABLE GET                   |t2      |1        |18  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t3.c1]), batch_join=false
  3 - output([PARTITION_ID], [t3.c1], [t1.c1]), filter(nil)
  4 - (#keys=1, [t3.c1]), output([PARTITION_ID], [t3.c1], [t1.c1]), filter(nil), dop=1
  5 - output([t3.c1], [t1.c1]), filter(nil), 
      conds(nil), nl_params_([t3.c1]), batch_join=false
  6 - output([t3.c1], [PARTITION_ID]), filter(nil)
  7 - (#keys=1, [t3.c1]), output([t3.c1], [PARTITION_ID]), filter(nil), dop=1
  8 - output([t3.c1]), filter(nil), 
      force partition granule.
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])
  12 - output(nil), filter(nil), 
      affinitize, force partition granule.
  13 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 50(end)  ************** 

***************   Case 51   ***************

SQL: select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |NESTED-LOOP JOIN               |             |1        |146 |
|1 | HASH JOIN                     |             |1        |9   |
|2 |  PX COORDINATOR               |             |1        |1   |
|3 |   EXCHANGE OUT DISTR          |:EX10000     |1        |1   |
|4 |    PX PARTITION ITERATOR      |             |1        |1   |
|5 |     TABLE SCAN                |tt(idx_t1_c2)|1        |1   |
|6 |  PX COORDINATOR               |             |1        |8   |
|7 |   EXCHANGE OUT DISTR          |:EX20001     |1        |8   |
|8 |    NESTED-LOOP JOIN           |             |1        |8   |
|9 |     EXCHANGE IN DISTR         |             |1        |1   |
|10|      EXCHANGE OUT DISTR (PKEY)|:EX20000     |1        |1   |
|11|       PX PARTITION ITERATOR   |             |1        |1   |
|12|        TABLE SCAN             |t1(idx_t1_c2)|1        |1   |
|13|     PX PARTITION ITERATOR     |             |1        |12  |
|14|      TABLE GET                |t3           |1        |12  |
|15| MATERIAL                      |             |1        |137 |
|16|  PX COORDINATOR               |             |1        |137 |
|17|   EXCHANGE OUT DISTR          |:EX30000     |1        |137 |
|18|    PX PARTITION ITERATOR      |             |1        |137 |
|19|     TABLE SCAN                |t2           |1        |137 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  2 - output([tt.c1], [tt.c2]), filter(nil)
  3 - output([tt.c1], [tt.c2]), filter(nil), dop=1
  4 - output([tt.c1], [tt.c2]), filter(nil), 
      force partition granule.
  5 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c2], [tt.c1]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  9 - output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  10 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  13 - output(nil), filter(nil), 
      affinitize, force partition granule.
  14 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([? = t3.c1])
  15 - output([t2.c1]), filter(nil)
  16 - output([t2.c1]), filter(nil)
  17 - output([t2.c1]), filter(nil), dop=1
  18 - output([t2.c1]), filter(nil), 
      force partition granule.
  19 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 51(end)  ************** 

***************   Case 52   ***************

SQL: select /*+no_use_px*/ t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

=====================================================================
|ID|OPERATOR                           |NAME         |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |PX COORDINATOR                     |             |1        |17  |
|1 | EXCHANGE OUT DISTR                |:EX10003     |1        |17  |
|2 |  HASH JOIN                        |             |1        |16  |
|3 |   PX PARTITION ITERATOR           |             |1        |1   |
|4 |    TABLE SCAN                     |tt(idx_t1_c2)|1        |1   |
|5 |   EXCHANGE IN DISTR               |             |1        |16  |
|6 |    EXCHANGE OUT DISTR (PKEY)      |:EX10002     |1        |15  |
|7 |     NESTED-LOOP JOIN              |             |1        |15  |
|8 |      EXCHANGE IN DISTR            |             |1        |8   |
|9 |       EXCHANGE OUT DISTR (PKEY)   |:EX10001     |1        |8   |
|10|        NESTED-LOOP JOIN           |             |1        |8   |
|11|         EXCHANGE IN DISTR         |             |1        |1   |
|12|          EXCHANGE OUT DISTR (PKEY)|:EX10000     |1        |1   |
|13|           PX PARTITION ITERATOR   |             |1        |1   |
|14|            TABLE SCAN             |t1(idx_t1_c2)|1        |1   |
|15|         PX PARTITION ITERATOR     |             |1        |18  |
|16|          TABLE GET                |t2           |1        |18  |
|17|      PX PARTITION ITERATOR        |             |1        |12  |
|18|       TABLE GET                   |t3           |1        |12  |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2], [t1.c1 + t2.c1 = tt.c1]), other_conds(nil)
  3 - output([tt.c1], [tt.c2]), filter(nil), 
      affinitize, force partition granule.
  4 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c2], [tt.c1]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t1.c1], [t1.c1 + t2.c1], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1], [t1.c1 + t2.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t2.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  8 - output([t1.c1], [t2.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  9 - (#keys=1, [t1.c1]), output([t1.c1], [t2.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  10 - output([t1.c1], [t2.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  11 - output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  12 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  15 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule.
  16 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])
  17 - output(nil), filter(nil), 
      affinitize, force partition granule.
  18 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([? = t3.c1])

*************** Case 52(end)  ************** 

***************   Case 53   ***************

SQL: select * from t1 where true; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 53(end)  ************** 

***************   Case 54   ***************

SQL: select * from t1 left join t2 t on t1.c1=t.c1 where false; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |236 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |236 |
|2 |  NESTED-LOOP OUTER JOIN     |        |1        |235 |
|3 |   EXCHANGE IN DISTR         |        |1        |228 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |228 |
|5 |     PX PARTITION ITERATOR   |        |1        |228 |
|6 |      TABLE SCAN             |t1      |1        |228 |
|7 |   PX PARTITION ITERATOR     |        |1        |18  |
|8 |    TABLE GET                |t       |1        |18  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t.c1, t.c2, t.c3)]), filter(nil), startup_filter([0])
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t.c1, t.c2, t.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2], [t.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX), 
      range_cond([? = t.c1])

*************** Case 54(end)  ************** 

***************   Case 55   ***************

SQL: select usec_to_time(c1) as modify_time_us from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(usec_to_time(cast(t1.c1, BIGINT(-1, 0))))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(usec_to_time(cast(t1.c1, BIGINT(-1, 0))))]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 55(end)  ************** 

***************   Case 56   ***************

SQL: select c1, repeat('ob', 2) as db_name from t1 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |1        |1   |
|1 | PX COORDINATOR MERGE SORT |             |1        |1   |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |1        |1   |
|3 |   TOP-N SORT              |             |1        |1   |
|4 |    PX PARTITION ITERATOR  |             |1        |1   |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(100), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 56(end)  ************** 

***************   Case 57   ***************

SQL: select 'ob' from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(?)]), filter(nil), dop=1
  2 - output(nil), filter(nil), 
      force partition granule.
  3 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 57(end)  ************** 

***************   Case 58   ***************

SQL: select c1, 'ob' from t1 where c1 > 100 order by c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |1        |1   |
|1 | EXCHANGE OUT DISTR       |:EX10000     |1        |1   |
|2 |  SORT                    |             |1        |1   |
|3 |   PX PARTITION ITERATOR  |             |1        |1   |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, ?)]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2], [INTERNAL_FUNCTION(t1.c1, ?)]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 58(end)  ************** 

***************   Case 59   ***************

SQL: select c1, 1 + 1 from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, ?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, ?)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 59(end)  ************** 

***************   Case 60   ***************

SQL: select c1, 1 + 1 from t1 order by c1 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |1        |228 |
|1 | PX COORDINATOR MERGE SORT |        |1        |228 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|1        |228 |
|3 |   TOP-N SORT              |        |1        |228 |
|4 |    PX PARTITION ITERATOR  |        |1        |228 |
|5 |     TABLE SCAN            |t1      |1        |228 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), topn(100), local merge sort
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 60(end)  ************** 

***************   Case 61   ***************

SQL: select c1 from t1 union select c2 from t2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |2        |366 |
|1 | EXCHANGE OUT DISTR          |:EX10001|2        |365 |
|2 |  HASH UNION DISTINCT        |        |2        |365 |
|3 |   PX PARTITION ITERATOR     |        |1        |228 |
|4 |    TABLE SCAN               |t1      |1        |228 |
|5 |   EXCHANGE IN DISTR         |        |1        |137 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|7 |     PX PARTITION ITERATOR   |        |1        |137 |
|8 |      TABLE SCAN             |t2      |1        |137 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c2]), filter(nil)
  6 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  7 - output([t2.c2]), filter(nil), 
      force partition granule.
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 61(end)  ************** 

***************   Case 62   ***************

SQL: select c1 from t1 union all select c2 from t2; 

==========================================================
|ID|OPERATOR                |NAME         |EST. ROWS|COST|
----------------------------------------------------------
|0 |UNION ALL               |             |2        |137 |
|1 | PX COORDINATOR         |             |1        |1   |
|2 |  EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|3 |   PX PARTITION ITERATOR|             |1        |1   |
|4 |    TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
|5 | PX COORDINATOR         |             |1        |137 |
|6 |  EXCHANGE OUT DISTR    |:EX20000     |1        |137 |
|7 |   PX PARTITION ITERATOR|             |1        |137 |
|8 |    TABLE SCAN          |t2           |1        |137 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t2.c2]), filter(nil)
  6 - output([t2.c2]), filter(nil), dop=1
  7 - output([t2.c2]), filter(nil), 
      force partition granule.
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 62(end)  ************** 

***************   Case 63   ***************

SQL: (select c1 from t1) except (select c2 from t2) order by c1; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |1        |365 |
|1 | EXCHANGE OUT DISTR           |:EX10001|1        |365 |
|2 |  SORT                        |        |1        |365 |
|3 |   HASH EXCEPT DISTINCT       |        |1        |365 |
|4 |    PX PARTITION ITERATOR     |        |1        |228 |
|5 |     TABLE SCAN               |t1      |1        |228 |
|6 |    EXCHANGE IN DISTR         |        |1        |137 |
|7 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|8 |      PX PARTITION ITERATOR   |        |1        |137 |
|9 |       TABLE SCAN             |t2      |1        |137 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(EXCEPT([1]))]), filter(nil), sort_keys([EXCEPT([1]), ASC])
  1 - output([EXCEPT([1])], [INTERNAL_FUNCTION(EXCEPT([1]))]), filter(nil), dop=1
  2 - output([EXCEPT([1])]), filter(nil), sort_keys([EXCEPT([1]), ASC])
  3 - output([EXCEPT([1])]), filter(nil)
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c2]), filter(nil)
  7 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  8 - output([t2.c2]), filter(nil), 
      force partition granule.
  9 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 63(end)  ************** 

***************   Case 64   ***************

SQL: (select c1 from t1) intersect (select c2 from t2) order by c1 limit 100; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |LIMIT                          |        |1        |365 |
|1 | PX COORDINATOR MERGE SORT     |        |1        |365 |
|2 |  EXCHANGE OUT DISTR           |:EX10001|1        |365 |
|3 |   TOP-N SORT                  |        |1        |365 |
|4 |    HASH INTERSECT DISTINCT    |        |1        |365 |
|5 |     PX PARTITION ITERATOR     |        |1        |228 |
|6 |      TABLE SCAN               |t1      |1        |228 |
|7 |     EXCHANGE IN DISTR         |        |1        |137 |
|8 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|9 |       PX PARTITION ITERATOR   |        |1        |137 |
|10|        TABLE SCAN             |t2      |1        |137 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil), limit(100), offset(nil)
  1 - output([INTERSECT([1])]), filter(nil), sort_keys([INTERSECT([1]), ASC])
  2 - output([INTERSECT([1])]), filter(nil), dop=1
  3 - output([INTERSECT([1])]), filter(nil), sort_keys([INTERSECT([1]), ASC]), topn(100)
  4 - output([INTERSECT([1])]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c2]), filter(nil)
  8 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  9 - output([t2.c2]), filter(nil), 
      force partition granule.
  10 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 64(end)  ************** 

***************   Case 65   ***************

SQL: (select c1 from t1) union (select c2 from t1) union (select c2 from t2); 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |MERGE DISTINCT            |             |1        |365 |
|1 | SORT                     |             |3        |365 |
|2 |  UNION ALL               |             |3        |365 |
|3 |   PX COORDINATOR         |             |1        |228 |
|4 |    EXCHANGE OUT DISTR    |:EX10000     |1        |228 |
|5 |     PX PARTITION ITERATOR|             |1        |228 |
|6 |      TABLE SCAN          |t1           |1        |228 |
|7 |   PX COORDINATOR         |             |1        |1   |
|8 |    EXCHANGE OUT DISTR    |:EX20000     |1        |1   |
|9 |     PX PARTITION ITERATOR|             |1        |1   |
|10|      TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
|11|   PX COORDINATOR         |             |1        |137 |
|12|    EXCHANGE OUT DISTR    |:EX30000     |1        |137 |
|13|     PX PARTITION ITERATOR|             |1        |137 |
|14|      TABLE SCAN          |t2           |1        |137 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), 
      distinct([UNION([1])])
  1 - output([UNION([1])]), filter(nil), sort_keys([UNION([1]), ASC])
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil)
  4 - output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t1.c2]), filter(nil)
  8 - output([t1.c2]), filter(nil), dop=1
  9 - output([t1.c2]), filter(nil), 
      force partition granule.
  10 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  11 - output([t2.c2]), filter(nil)
  12 - output([t2.c2]), filter(nil), dop=1
  13 - output([t2.c2]), filter(nil), 
      force partition granule.
  14 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 65(end)  ************** 

***************   Case 66   ***************

SQL: (select /*+no_use_px*/ c1 from t1) union (select c2 from t1) union (select c2 from t2) order by c1 limit 100; 

=======================================================================
|ID|OPERATOR                             |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------------
|0 |LIMIT                                |             |1        |366 |
|1 | MERGE DISTINCT                      |             |1        |366 |
|2 |  SORT                               |             |3        |366 |
|3 |   UNION ALL                         |             |3        |366 |
|4 |    LIMIT                            |             |1        |228 |
|5 |     PX COORDINATOR MERGE SORT       |             |1        |228 |
|6 |      EXCHANGE OUT DISTR             |:EX10000     |1        |228 |
|7 |       TOP-N SORT                    |             |1        |228 |
|8 |        PX PARTITION ITERATOR        |             |1        |228 |
|9 |         TABLE SCAN                  |t1           |1        |228 |
<<<<<<< HEAD
|10|    LIMIT                            |             |1        |228 |
|11|     PX COORDINATOR MERGE SORT       |             |1        |228 |
|12|      EXCHANGE OUT DISTR             |:EX20001     |1        |228 |
|13|       LIMIT                         |             |1        |228 |
|14|        MERGE DISTINCT               |             |1        |228 |
|15|         EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|16|          EXCHANGE OUT DISTR (HASH)  |:EX20000     |1        |228 |
|17|           PX PARTITION ITERATOR     |             |1        |228 |
|18|            MERGE DISTINCT           |             |1        |228 |
|19|             TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
|20|    LIMIT                            |             |1        |137 |
|21|     PX COORDINATOR MERGE SORT       |             |1        |137 |
|22|      EXCHANGE OUT DISTR             |:EX30001     |1        |137 |
|23|       LIMIT                         |             |1        |137 |
|24|        MERGE DISTINCT               |             |1        |137 |
|25|         EXCHANGE IN MERGE SORT DISTR|             |1        |137 |
|26|          EXCHANGE OUT DISTR (HASH)  |:EX30000     |1        |137 |
|27|           MERGE DISTINCT            |             |1        |137 |
|28|            SORT                     |             |1        |137 |
|29|             PX PARTITION ITERATOR   |             |1        |137 |
|30|              TABLE SCAN             |t2           |1        |137 |
=======
|10|    LIMIT                            |             |1        |1   |
|11|     PX COORDINATOR MERGE SORT       |             |1        |1   |
|12|      EXCHANGE OUT DISTR             |:EX20001     |1        |1   |
|13|       LIMIT                         |             |1        |1   |
|14|        MERGE DISTINCT               |             |1        |1   |
|15|         EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|16|          EXCHANGE OUT DISTR (HASH)  |:EX20000     |1        |1   |
|17|           PX PARTITION ITERATOR     |             |1        |1   |
|18|            TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
|19|    LIMIT                            |             |1        |137 |
|20|     PX COORDINATOR MERGE SORT       |             |1        |137 |
|21|      EXCHANGE OUT DISTR             |:EX30001     |1        |137 |
|22|       LIMIT                         |             |1        |137 |
|23|        MERGE DISTINCT               |             |1        |137 |
|24|         SORT                        |             |1        |137 |
|25|          EXCHANGE IN DISTR          |             |1        |137 |
|26|           EXCHANGE OUT DISTR (HASH) |:EX30000     |1        |137 |
|27|            PX PARTITION ITERATOR    |             |1        |137 |
|28|             TABLE SCAN              |t2           |1        |137 |
>>>>>>> refine idnex scan cost
=======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), limit(100), offset(nil)
  1 - output([UNION([1])]), filter(nil), 
      distinct([UNION([1])])
  2 - output([UNION([1])]), filter(nil), sort_keys([UNION([1]), ASC])
  3 - output([UNION([1])]), filter(nil)
  4 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), dop=1
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), topn(100), local merge sort
  8 - output([t1.c1]), filter(nil), 
      force partition granule.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  11 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  12 - output([t1.c2]), filter(nil), dop=1
  13 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  14 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  15 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  16 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  17 - output([t1.c2]), filter(nil), 
      force partition granule.
  18 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  19 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  20 - output([t2.c2]), filter(nil), limit(100), offset(nil)
  21 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  22 - output([t2.c2]), filter(nil), dop=1
  23 - output([t2.c2]), filter(nil), limit(100), offset(nil)
  24 - output([t2.c2]), filter(nil), 
      distinct([t2.c2])
  25 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  26 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  27 - output([t2.c2]), filter(nil), 
      distinct([t2.c2])
  28 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  29 - output([t2.c2]), filter(nil), 
      force partition granule.
  30 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 66(end)  ************** 

***************   Case 67   ***************

SQL: (select c1 from t1) union (select c2 from t1) intersect (select c2 from t2) order by c1 limit 100; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |TOP-N SORT                     |             |1        |367 |
|1 | HASH INTERSECT DISTINCT       |             |1        |367 |
|2 |  PX COORDINATOR               |             |2        |229 |
|3 |   EXCHANGE OUT DISTR          |:EX10001     |2        |229 |
|4 |    HASH UNION DISTINCT        |             |2        |229 |
|5 |     PX PARTITION ITERATOR     |             |1        |228 |
|6 |      TABLE SCAN               |t1           |1        |228 |
|7 |     EXCHANGE IN DISTR         |             |1        |1   |
|8 |      EXCHANGE OUT DISTR (PKEY)|:EX10000     |1        |1   |
|9 |       PX PARTITION ITERATOR   |             |1        |1   |
|10|        TABLE SCAN             |t1(idx_t1_c2)|1        |1   |
|11|  PX COORDINATOR               |             |1        |137 |
|12|   EXCHANGE OUT DISTR          |:EX20000     |1        |137 |
|13|    PX PARTITION ITERATOR      |             |1        |137 |
|14|     TABLE SCAN                |t2           |1        |137 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil), sort_keys([INTERSECT([1]), ASC]), topn(100)
  1 - output([INTERSECT([1])]), filter(nil)
  2 - output([UNION([1])]), filter(nil)
  3 - output([UNION([1])]), filter(nil), dop=1
  4 - output([UNION([1])]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t1.c2]), filter(nil)
  8 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  9 - output([t1.c2]), filter(nil), 
      force partition granule.
  10 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  11 - output([t2.c2]), filter(nil)
  12 - output([t2.c2]), filter(nil), dop=1
  13 - output([t2.c2]), filter(nil), 
      force partition granule.
  14 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 67(end)  ************** 

***************   Case 68   ***************

SQL: select distinct(c2) from t1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
<<<<<<< HEAD
|0 |PX COORDINATOR                 |             |1        |228 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |228 |
|2 |  MERGE DISTINCT               |             |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|5 |     PX PARTITION ITERATOR     |             |1        |228 |
|6 |      MERGE DISTINCT           |             |1        |228 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |PX COORDINATOR                 |             |1        |1   |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |1   |
|2 |  MERGE DISTINCT               |             |1        |1   |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR     |             |1        |1   |
|6 |      TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  3 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 68(end)  ************** 

***************   Case 69   ***************

SQL: select distinct(c1) from t4; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE DISTINCT|    |1        |46  |
|1 | TABLE SCAN   |t4  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 69(end)  ************** 

***************   Case 70   ***************

SQL: select distinct c1, c2 from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 70(end)  ************** 

***************   Case 71   ***************

SQL: select distinct c1, c2 from t4; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|1        |1   |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 71(end)  ************** 

***************   Case 72   ***************

SQL: select distinct(t1.c2), t2.c2 from t1, t2 where t1.c1 = t2.c1; 

<<<<<<< HEAD
===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |1        |145 |
|1 | EXCHANGE OUT DISTR               |:EX10002|1        |145 |
|2 |  MERGE DISTINCT                  |        |1        |145 |
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |1        |144 |
|4 |    EXCHANGE OUT DISTR (HASH)     |:EX10001|1        |144 |
|5 |     MERGE DISTINCT               |        |1        |144 |
|6 |      SORT                        |        |1        |144 |
|7 |       NESTED-LOOP JOIN           |        |1        |144 |
|8 |        EXCHANGE IN DISTR         |        |1        |137 |
|9 |         EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|10|          PX PARTITION ITERATOR   |        |1        |137 |
|11|           TABLE SCAN             |t2      |1        |137 |
|12|        PX PARTITION ITERATOR     |        |1        |30  |
|13|         TABLE GET                |t1      |1        |30  |
===============================================================
=======
===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |PX COORDINATOR                   |             |1        |9   |
|1 | EXCHANGE OUT DISTR              |:EX10002     |1        |9   |
|2 |  MERGE DISTINCT                 |             |1        |8   |
|3 |   SORT                          |             |1        |8   |
|4 |    EXCHANGE IN DISTR            |             |1        |8   |
|5 |     EXCHANGE OUT DISTR (HASH)   |:EX10001     |1        |8   |
|6 |      NESTED-LOOP JOIN           |             |1        |8   |
|7 |       EXCHANGE IN DISTR         |             |1        |1   |
|8 |        EXCHANGE OUT DISTR (PKEY)|:EX10000     |1        |1   |
|9 |         PX PARTITION ITERATOR   |             |1        |1   |
|10|          TABLE SCAN             |t1(idx_t1_c2)|1        |1   |
|11|       PX PARTITION ITERATOR     |             |1        |18  |
|12|        TABLE GET                |t2           |1        |18  |
===================================================================
>>>>>>> refine idnex scan cost

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, t2.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2, t2.c2)]), filter(nil), dop=1
  2 - output([t1.c2], [t2.c2]), filter(nil), 
      distinct([t1.c2], [t2.c2])
  3 - output([t1.c2], [t2.c2]), filter(nil), sort_keys([t1.c2, ASC], [t2.c2, ASC])
<<<<<<< HEAD
  4 - (#keys=2, [t1.c2], [t2.c2]), output([t1.c2], [t2.c2]), filter(nil), dop=1
  5 - output([t1.c2], [t2.c2]), filter(nil), 
      distinct([t1.c2], [t2.c2])
  6 - output([t1.c2], [t2.c2]), filter(nil), sort_keys([t1.c2, ASC], [t2.c2, ASC])
  7 - output([t1.c2], [t2.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  8 - output([t2.c2], [PARTITION_ID], [t2.c1]), filter(nil)
  9 - (#keys=1, [t2.c1]), output([t2.c2], [PARTITION_ID], [t2.c1]), filter(nil), dop=1
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c2]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
=======
  4 - output([t1.c2], [t2.c2]), filter(nil)
  5 - (#keys=2, [t1.c2], [t2.c2]), output([t1.c2], [t2.c2]), filter(nil), dop=1
  6 - output([t1.c2], [t2.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  7 - output([t1.c2], [PARTITION_ID], [t1.c1]), filter(nil)
  8 - (#keys=1, [t1.c1]), output([t1.c2], [PARTITION_ID], [t1.c1]), filter(nil), dop=1
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  11 - output([t2.c2]), filter(nil), 
      affinitize, force partition granule.
  12 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
>>>>>>> refine idnex scan cost
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])

*************** Case 72(end)  ************** 

***************   Case 73   ***************

SQL: select distinct(t1.c1), t2.c2 from t1, t2 where t1.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |144 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |144 |
|2 |  NESTED-LOOP JOIN           |        |1        |144 |
|3 |   EXCHANGE IN DISTR         |        |1        |137 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t2      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |30  |
|8 |    TABLE GET                |t1      |1        |30  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t2.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t2.c2)]), filter(nil), dop=1
  2 - output([t2.c2], [t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([PARTITION_ID], [t2.c1], [t2.c2]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([PARTITION_ID], [t2.c1], [t2.c2]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 73(end)  ************** 

***************   Case 74   ***************

SQL: select distinct t4.c1, t4.c2, t2.c2 from t4, t2 where t4.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |53  |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |53  |
|2 |  NESTED-LOOP JOIN           |        |1        |53  |
|3 |   EXCHANGE IN DISTR         |        |1        |46  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|5 |     TABLE SCAN              |t4      |1        |46  |
|6 |   PX PARTITION ITERATOR     |        |1        |18  |
|7 |    TABLE GET                |t2      |1        |18  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t2.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t2.c2)]), filter(nil), dop=1
  2 - output([t4.c1], [t4.c2], [t2.c2]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=false
  3 - output([t4.c1], [PARTITION_ID], [t4.c2]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1], [PARTITION_ID], [t4.c2]), filter(nil), is_single, dop=1
  5 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t2.c2]), filter(nil), 
      affinitize, force partition granule.
  7 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])

*************** Case 74(end)  ************** 

***************   Case 75   ***************

SQL: select distinct c1 as ali_name from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 75(end)  ************** 

***************   Case 76   ***************

SQL: select distinct c2 as ali_name from t1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
<<<<<<< HEAD
|0 |PX COORDINATOR                 |             |1        |228 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |228 |
|2 |  MERGE DISTINCT               |             |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|5 |     PX PARTITION ITERATOR     |             |1        |228 |
|6 |      MERGE DISTINCT           |             |1        |228 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |PX COORDINATOR                 |             |1        |1   |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |1   |
|2 |  MERGE DISTINCT               |             |1        |1   |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR     |             |1        |1   |
|6 |      TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  3 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 76(end)  ************** 

***************   Case 77   ***************

SQL: select distinct c1 * c2 from t1; 

<<<<<<< HEAD
============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |1        |228 |
|1 | EXCHANGE OUT DISTR            |:EX10001|1        |228 |
|2 |  MERGE DISTINCT               |        |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|1        |228 |
|5 |     MERGE DISTINCT            |        |1        |228 |
|6 |      SORT                     |        |1        |228 |
|7 |       PX PARTITION ITERATOR   |        |1        |228 |
|8 |        TABLE SCAN             |t1      |1        |228 |
============================================================
=======
================================================================
|ID|OPERATOR                      |NAME         |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                |             |1        |1   |
|1 | EXCHANGE OUT DISTR           |:EX10001     |1        |1   |
|2 |  MERGE DISTINCT              |             |1        |1   |
|3 |   SORT                       |             |1        |1   |
|4 |    EXCHANGE IN DISTR         |             |1        |1   |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000     |1        |1   |
|6 |      PX PARTITION ITERATOR   |             |1        |1   |
|7 |       TABLE SCAN             |t1(idx_t1_c2)|1        |1   |
================================================================
>>>>>>> refine idnex scan cost

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1 * t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1 * t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1 * t1.c2]), filter(nil), 
      distinct([t1.c1 * t1.c2])
  3 - output([t1.c1 * t1.c2]), filter(nil), sort_keys([t1.c1 * t1.c2, ASC])
  4 - (#keys=1, [t1.c1 * t1.c2]), output([t1.c1 * t1.c2]), filter(nil), dop=1
  5 - output([t1.c1 * t1.c2]), filter(nil), 
      distinct([t1.c1 * t1.c2])
  6 - output([t1.c1 * t1.c2]), filter(nil), sort_keys([t1.c1 * t1.c2, ASC])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 77(end)  ************** 

***************   Case 78   ***************

SQL: select distinct 1, 2 from t1; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |LIMIT                    |             |1        |1   |
|1 | PX COORDINATOR          |             |1        |1   |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |1   |
|3 |   LIMIT                 |             |1        |1   |
|4 |    PX PARTITION ITERATOR|             |1        |1   |
|5 |     TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?]), filter(nil), limit(1), offset(nil)
  1 - output(nil), filter(nil)
  2 - output(nil), filter(nil), dop=1
  3 - output(nil), filter(nil), limit(1), offset(nil)
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 78(end)  ************** 

***************   Case 79   ***************

SQL: select distinct c2 from t4 order by c2 limit 3; 

====================================================
|ID|OPERATOR       |NAME            |EST. ROWS|COST|
----------------------------------------------------
|0 |LIMIT          |                |1        |1   |
|1 | MERGE DISTINCT|                |1        |1   |
|2 |  TABLE SCAN   |t4(idx_t4_c2_c3)|1        |1   |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t4.c2]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 79(end)  ************** 

***************   Case 80   ***************

SQL: select distinct c2 from t4 order by c2; 

===================================================
|ID|OPERATOR      |NAME            |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE DISTINCT|                |1        |1   |
|1 | TABLE SCAN   |t4(idx_t4_c2_c3)|1        |1   |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), 
      distinct([t4.c2])
  1 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 80(end)  ************** 

***************   Case 81   ***************

SQL: select distinct c2 from t4 order by c3; 

====================================================
|ID|OPERATOR       |NAME            |EST. ROWS|COST|
----------------------------------------------------
|0 |SORT           |                |1        |1   |
|1 | MERGE DISTINCT|                |1        |1   |
|2 |  TABLE SCAN   |t4(idx_t4_c2_c3)|1        |1   |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC])
  1 - output([t4.c3], [t4.c2]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 81(end)  ************** 

***************   Case 82   ***************

SQL: select distinct c1, c2 from t4 order by c3; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c3)|1        |1   |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c3], [t4.c1], [t4.c2]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 82(end)  ************** 

***************   Case 83   ***************

SQL: select distinct c2 from t4 order by c3 limit 3; 

====================================================
|ID|OPERATOR       |NAME            |EST. ROWS|COST|
----------------------------------------------------
|0 |TOP-N SORT     |                |1        |1   |
|1 | MERGE DISTINCT|                |1        |1   |
|2 |  TABLE SCAN   |t4(idx_t4_c2_c3)|1        |1   |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC]), topn(3)
  1 - output([t4.c3], [t4.c2]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 83(end)  ************** 

***************   Case 84   ***************

SQL: select distinct c2 from t4 order by c3 limit 3; 

====================================================
|ID|OPERATOR       |NAME            |EST. ROWS|COST|
----------------------------------------------------
|0 |TOP-N SORT     |                |1        |1   |
|1 | MERGE DISTINCT|                |1        |1   |
|2 |  TABLE SCAN   |t4(idx_t4_c2_c3)|1        |1   |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC]), topn(3)
  1 - output([t4.c3], [t4.c2]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 84(end)  ************** 

***************   Case 85   ***************

SQL: select distinct c2 from t5 order by c3 limit 3; 

<<<<<<< HEAD
==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |LIMIT                            |        |1        |138 |
|1 | PX COORDINATOR MERGE SORT       |        |1        |138 |
|2 |  EXCHANGE OUT DISTR             |:EX10001|1        |138 |
|3 |   TOP-N SORT                    |        |1        |137 |
|4 |    MERGE DISTINCT               |        |1        |137 |
|5 |     EXCHANGE IN MERGE SORT DISTR|        |1        |137 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000|1        |137 |
|7 |       PX PARTITION ITERATOR     |        |1        |137 |
|8 |        MERGE DISTINCT           |        |1        |137 |
|9 |         TABLE SCAN              |t5      |1        |137 |
==============================================================
=======
===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |1        |1   |
|1 | PX COORDINATOR MERGE SORT       |             |1        |1   |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |1        |1   |
|3 |   TOP-N SORT                    |             |1        |1   |
|4 |    MERGE DISTINCT               |             |1        |1   |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|7 |       PX PARTITION ITERATOR     |             |1        |1   |
|8 |        TABLE SCAN               |t5(idx_t5_c2)|1        |1   |
===================================================================
>>>>>>> refine idnex scan cost

Outputs & filters: 
-------------------------------------
  0 - output([t5.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t5.c2]), filter(nil), sort_keys([t5.c3, ASC])
  2 - output([t5.c2], [t5.c3]), filter(nil), dop=1
  3 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC]), topn(3)
  4 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  5 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  6 - (#keys=1, [t5.c2]), output([t5.c2], [t5.c3]), filter(nil), dop=1
  7 - output([t5.c2], [t5.c3]), filter(nil), 
      force partition granule.
  8 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  9 - output([t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 85(end)  ************** 

***************   Case 86   ***************

SQL: select distinct c2 from t5 order by c3; 

==================================================================
|ID|OPERATOR                        |NAME         |EST. ROWS|COST|
------------------------------------------------------------------
<<<<<<< HEAD
|0 |PX COORDINATOR MERGE SORT       |             |1        |138 |
|1 | EXCHANGE OUT DISTR             |:EX10001     |1        |138 |
|2 |  SORT                          |             |1        |137 |
|3 |   MERGE DISTINCT               |             |1        |137 |
|4 |    EXCHANGE IN MERGE SORT DISTR|             |1        |137 |
|5 |     EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |137 |
|6 |      PX PARTITION ITERATOR     |             |1        |137 |
|7 |       MERGE DISTINCT           |             |1        |137 |
|8 |        TABLE SCAN              |t5(idx_t5_c2)|1        |137 |
=======
|0 |PX COORDINATOR MERGE SORT       |             |1        |1   |
|1 | EXCHANGE OUT DISTR             |:EX10001     |1        |1   |
|2 |  SORT                          |             |1        |1   |
|3 |   MERGE DISTINCT               |             |1        |1   |
|4 |    EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|5 |     EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|6 |      PX PARTITION ITERATOR     |             |1        |1   |
|7 |       TABLE SCAN               |t5(idx_t5_c2)|1        |1   |
>>>>>>> refine idnex scan cost
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c2)]), filter(nil), sort_keys([t5.c3, ASC])
  1 - output([t5.c3], [INTERNAL_FUNCTION(t5.c2)]), filter(nil), dop=1
  2 - output([t5.c3], [t5.c2]), filter(nil), sort_keys([t5.c3, ASC])
  3 - output([t5.c3], [t5.c2]), filter(nil), 
      distinct([t5.c2])
  4 - output([t5.c3], [t5.c2]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  5 - (#keys=1, [t5.c2]), output([t5.c3], [t5.c2]), filter(nil), dop=1
  6 - output([t5.c3], [t5.c2]), filter(nil), 
      force partition granule.
  7 - output([t5.c3], [t5.c2]), filter(nil), 
      distinct([t5.c2])
  8 - output([t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 86(end)  ************** 

***************   Case 87   ***************

SQL: select * from t1 where c1 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[7 ; 7], 
      range_cond([t1.c1 = ?])

*************** Case 87(end)  ************** 

***************   Case 88   ***************

SQL: select * from t1 where c1 = 5 or c1 = 7; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |2        |93  |
|1 | EXCHANGE OUT DISTR    |:EX10000|2        |93  |
|2 |  PX PARTITION ITERATOR|        |2        |92  |
|3 |   TABLE GET           |t1      |2        |92  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0, p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], [7 ; 7], 
      range_cond([t1.c1 = ? OR t1.c1 = ?])

*************** Case 88(end)  ************** 

***************   Case 89   ***************

SQL: select * from t1 where c1 = 5 or c1 = 7 or c1 = 8; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |3        |139 |
|1 | EXCHANGE OUT DISTR    |:EX10000|3        |139 |
|2 |  PX PARTITION ITERATOR|        |3        |138 |
|3 |   TABLE GET           |t1      |3        |138 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0, p[2-3]), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], [7 ; 7], [8 ; 8], 
      range_cond([(T_OP_OR, t1.c1 = ?, t1.c1 = ?, t1.c1 = ?)])

*************** Case 89(end)  ************** 

***************   Case 90   ***************

SQL: select c1 as alias_name from t1 where c1 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[7 ; 7], 
      range_cond([t1.c1 = ?])

*************** Case 90(end)  ************** 

***************   Case 91   ***************

SQL: select * from t5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |137 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |137 |
|2 |  PX PARTITION ITERATOR|        |1        |137 |
|3 |   TABLE SCAN          |t5      |1        |137 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 91(end)  ************** 

***************   Case 92   ***************

SQL: select * from t5 where c2 =3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |137 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |137 |
|2 |  PX PARTITION ITERATOR|        |1        |137 |
|3 |   TABLE SCAN          |t5      |1        |137 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(3,MIN ; 3,MAX), 
      range_cond([t5.c2 = ?])

*************** Case 92(end)  ************** 

***************   Case 93   ***************

SQL: select * from t5 where c2 = 5 and c3 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t5  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  2 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[5,7 ; 5,7], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 93(end)  ************** 

***************   Case 94   ***************

SQL: select * from t5 where c2 = 6 and c3 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t5  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  2 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[6,7 ; 6,7], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 94(end)  ************** 

***************   Case 95   ***************

SQL: select * from t5 where c2 = 11 and c3 = 8; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t5  |1        |46  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[11,8 ; 11,8], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 95(end)  ************** 

***************   Case 96   ***************

SQL: select c1 from t6; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |137 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |137 |
|2 |  PX PARTITION ITERATOR|        |1        |137 |
|3 |   TABLE SCAN          |t6      |1        |137 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t6.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t6.c1)]), filter(nil), dop=1
  2 - output([t6.c1]), filter(nil), 
      force partition granule.
  3 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 96(end)  ************** 

***************   Case 97   ***************

SQL: select * from t6 where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t6  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1], [t6.c2]), filter(nil)
  1 - output([t6.c1], [t6.c2]), filter(nil)
  2 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t6.c1]), range[3 ; 3], 
      range_cond([t6.c1 = ?])

*************** Case 97(end)  ************** 

***************   Case 98   ***************

SQL: select * from t6 where c1 = 10; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t6  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1], [t6.c2]), filter(nil)
  1 - output([t6.c1], [t6.c2]), filter(nil)
  2 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t6.c1]), range[10 ; 10], 
      range_cond([t6.c1 = ?])

*************** Case 98(end)  ************** 

***************   Case 99   ***************

SQL: select t1.c2 + t2.c1 from t1, t2 where t1.c1 = t2.c2 and t1.c1 and t1.c1 = 1 and t2.c1 = 2; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |142 |
|1 | PX COORDINATOR           |        |1        |46  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t1      |1        |46  |
|4 | PX COORDINATOR           |        |1        |46  |
|5 |  EXCHANGE OUT DISTR      |:EX20000|1        |46  |
|6 |   TABLE GET              |t2      |1        |46  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2 + ?]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c2]), filter(nil)
  2 - output([t1.c2]), filter(nil), is_single, dop=1
  3 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output(nil), filter(nil)
  5 - output(nil), filter(nil), is_single, dop=1
  6 - output(nil), filter([? = t2.c2]), 
      access([t2.c2]), partitions(p2), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])

*************** Case 99(end)  ************** 

***************   Case 100   ***************

SQL: select t1.c1 from t1,t2 where t1.c1+1=t2.c1; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR               |             |1        |8   |
|1 | EXCHANGE OUT DISTR          |:EX10001     |1        |8   |
|2 |  NESTED-LOOP JOIN           |             |1        |8   |
|3 |   EXCHANGE IN DISTR         |             |1        |1   |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR   |             |1        |1   |
|6 |      TABLE SCAN             |t1(idx_t1_c2)|1        |1   |
|7 |   PX PARTITION ITERATOR     |             |1        |18  |
|8 |    TABLE GET                |t2           |1        |18  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1 + ?]), batch_join=false
  3 - output([t1.c1], [PARTITION_ID], [t1.c1 + ?]), filter(nil)
  4 - (#keys=1, [t1.c1 + ?]), output([t1.c1], [PARTITION_ID], [t1.c1 + ?]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  7 - output(nil), filter(nil), 
      affinitize, force partition granule.
  8 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])

*************** Case 100(end)  ************** 

***************   Case 101   ***************

SQL: select t1.c1, t2.c1 from t1, t2 where t1.c1 = 1 and t2.c1 = 1 and t1.c1 = t2.c1; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |EXCHANGE IN REMOTE          |    |1        |93  |
|1 | EXCHANGE OUT REMOTE        |    |1        |93  |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |92  |
|3 |   TABLE GET                |t1  |1        |46  |
|4 |   TABLE GET                |t2  |1        |46  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil)
  1 - output([t1.c1], [t2.c1]), filter(nil)
  2 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?], [t1.c1 = ?])
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?], [t2.c1 = ?])

*************** Case 101(end)  ************** 

***************   Case 102   ***************

SQL: select /*+ leading(t2 t1 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |154 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |154 |
|2 |  NESTED-LOOP JOIN              |        |1        |152 |
|3 |   EXCHANGE IN DISTR            |        |1        |146 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |145 |
|5 |     NESTED-LOOP JOIN           |        |1        |145 |
|6 |      EXCHANGE IN DISTR         |        |1        |138 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |138 |
|8 |        PX PARTITION ITERATOR   |        |1        |137 |
|9 |         TABLE SCAN             |t2      |1        |137 |
|10|      PX PARTITION ITERATOR     |        |1        |30  |
|11|       TABLE GET                |t1      |1        |30  |
|12|   PX PARTITION ITERATOR        |        |1        |12  |
|13|    TABLE GET                   |t3      |1        |12  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  6 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil)
  7 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 = ?])

*************** Case 102(end)  ************** 

***************   Case 103   ***************

SQL: select /*+ leading(t2)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |154 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |154 |
|2 |  NESTED-LOOP JOIN              |        |1        |152 |
|3 |   EXCHANGE IN DISTR            |        |1        |146 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |145 |
|5 |     NESTED-LOOP JOIN           |        |1        |145 |
|6 |      EXCHANGE IN DISTR         |        |1        |138 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |138 |
|8 |        PX PARTITION ITERATOR   |        |1        |137 |
|9 |         TABLE SCAN             |t2      |1        |137 |
|10|      PX PARTITION ITERATOR     |        |1        |30  |
|11|       TABLE GET                |t1      |1        |30  |
|12|   PX PARTITION ITERATOR        |        |1        |12  |
|13|    TABLE GET                   |t3      |1        |12  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  6 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil)
  7 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 = ?])

*************** Case 103(end)  ************** 

***************   Case 104   ***************

SQL: select /*+ use_merge(t2)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |154 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |154 |
|2 |  NESTED-LOOP JOIN              |        |1        |152 |
|3 |   EXCHANGE IN DISTR            |        |1        |146 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |145 |
|5 |     NESTED-LOOP JOIN           |        |1        |145 |
|6 |      EXCHANGE IN DISTR         |        |1        |138 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |138 |
|8 |        PX PARTITION ITERATOR   |        |1        |137 |
|9 |         TABLE SCAN             |t2      |1        |137 |
|10|      PX PARTITION ITERATOR     |        |1        |30  |
|11|       TABLE GET                |t1      |1        |30  |
|12|   PX PARTITION ITERATOR        |        |1        |12  |
|13|    TABLE GET                   |t3      |1        |12  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  6 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil)
  7 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 = ?])

*************** Case 104(end)  ************** 

***************   Case 105   ***************

SQL: select /*+ use_merge(t1)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |245 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |244 |
|2 |  NESTED-LOOP JOIN              |        |1        |243 |
|3 |   EXCHANGE IN DISTR            |        |1        |236 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |236 |
|5 |     NESTED-LOOP JOIN           |        |1        |235 |
|6 |      EXCHANGE IN DISTR         |        |1        |228 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |228 |
|8 |        PX PARTITION ITERATOR   |        |1        |228 |
|9 |         TABLE SCAN             |t1      |1        |228 |
|10|      PX PARTITION ITERATOR     |        |1        |18  |
|11|       TABLE GET                |t2      |1        |18  |
|12|   PX PARTITION ITERATOR        |        |1        |12  |
|13|    TABLE GET                   |t3      |1        |12  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t1.c1], [t1.c2], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t2.c1], [PARTITION_ID], [t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  6 - output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 = ?])

*************** Case 105(end)  ************** 

***************   Case 106   ***************

SQL: select /*+ use_merge(t2 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |239 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |238 |
|2 |  HASH JOIN                     |        |1        |237 |
|3 |   PX PARTITION ITERATOR        |        |1        |92  |
|4 |    TABLE SCAN                  |t3      |1        |92  |
|5 |   EXCHANGE IN DISTR            |        |1        |146 |
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |145 |
|7 |     NESTED-LOOP JOIN           |        |1        |145 |
|8 |      EXCHANGE IN DISTR         |        |1        |138 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |138 |
|10|        PX PARTITION ITERATOR   |        |1        |137 |
|11|         TABLE SCAN             |t2      |1        |137 |
|12|      PX PARTITION ITERATOR     |        |1        |30  |
|13|       TABLE GET                |t1      |1        |30  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t3.c1], [t2.c1], [t3.c2], [t3.c3], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  8 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil)
  9 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil), dop=1
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 106(end)  ************** 

***************   Case 107   ***************

SQL: select /*+ use_nl(t2 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |109 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |108 |
|2 |  NESTED-LOOP JOIN              |        |1        |107 |
|3 |   EXCHANGE IN DISTR            |        |1        |100 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |100 |
|5 |     NESTED-LOOP JOIN           |        |1        |99  |
|6 |      EXCHANGE IN DISTR         |        |1        |92  |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |92  |
|8 |        PX PARTITION ITERATOR   |        |1        |92  |
|9 |         TABLE SCAN             |t3      |1        |92  |
|10|      PX PARTITION ITERATOR     |        |1        |30  |
|11|       TABLE GET                |t1      |1        |30  |
|12|   PX PARTITION ITERATOR        |        |1        |18  |
|13|    TABLE GET                   |t2      |1        |18  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [PARTITION_ID], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t3.c1]), batch_join=false
  6 - output([t3.c1], [PARTITION_ID], [t3.c2], [t3.c3]), filter(nil)
  7 - (#keys=1, [t3.c1]), output([t3.c1], [PARTITION_ID], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])

*************** Case 107(end)  ************** 

***************   Case 108   ***************

SQL: select /*+ use_merge(t2), use_nl(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |154 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |154 |
|2 |  NESTED-LOOP JOIN              |        |1        |152 |
|3 |   EXCHANGE IN DISTR            |        |1        |146 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |145 |
|5 |     NESTED-LOOP JOIN           |        |1        |145 |
|6 |      EXCHANGE IN DISTR         |        |1        |138 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |138 |
|8 |        PX PARTITION ITERATOR   |        |1        |137 |
|9 |         TABLE SCAN             |t2      |1        |137 |
|10|      PX PARTITION ITERATOR     |        |1        |30  |
|11|       TABLE GET                |t1      |1        |30  |
|12|   PX PARTITION ITERATOR        |        |1        |12  |
|13|    TABLE GET                   |t3      |1        |12  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  6 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil)
  7 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 = ?])

*************** Case 108(end)  ************** 

***************   Case 109   ***************

SQL: select /*+ ordered, use_merge(t2), use_nl(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |1        |375 |
|1 | EXCHANGE OUT DISTR               |:EX10002|1        |374 |
|2 |  NESTED-LOOP JOIN                |        |1        |373 |
|3 |   EXCHANGE IN DISTR              |        |1        |366 |
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|1        |366 |
|5 |     MERGE JOIN                   |        |1        |365 |
|6 |      EXCHANGE IN MERGE SORT DISTR|        |1        |228 |
|7 |       EXCHANGE OUT DISTR (PKEY)  |:EX10000|1        |228 |
|8 |        PX PARTITION ITERATOR     |        |1        |228 |
|9 |         TABLE SCAN               |t1      |1        |228 |
|10|      SORT                        |        |1        |137 |
|11|       PX PARTITION ITERATOR      |        |1        |137 |
|12|        TABLE SCAN                |t2      |1        |137 |
|13|   PX PARTITION ITERATOR          |        |1        |12  |
|14|    TABLE GET                     |t3      |1        |12  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t1.c1], [t1.c2], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t2.c1], [PARTITION_ID], [t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 = ?])

*************** Case 109(end)  ************** 

***************   Case 110   ***************

SQL: select /*+ use_nl(t2), use_merge(t3)*/ * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |109 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |108 |
|2 |  NESTED-LOOP JOIN              |        |1        |107 |
|3 |   EXCHANGE IN DISTR            |        |1        |100 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |100 |
|5 |     NESTED-LOOP JOIN           |        |1        |99  |
|6 |      EXCHANGE IN DISTR         |        |1        |92  |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |92  |
|8 |        PX PARTITION ITERATOR   |        |1        |92  |
|9 |         TABLE SCAN             |t3      |1        |92  |
|10|      PX PARTITION ITERATOR     |        |1        |30  |
|11|       TABLE GET                |t1      |1        |30  |
|12|   PX PARTITION ITERATOR        |        |1        |18  |
|13|    TABLE GET                   |t2      |1        |18  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t3.c1], [t3.c2], [t3.c3], [t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t3.c1]), batch_join=false
  3 - output([t3.c1], [PARTITION_ID], [t3.c2], [t3.c3], [t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t3.c1]), output([t3.c1], [PARTITION_ID], [t3.c2], [t3.c3], [t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t3.c1], [t3.c2], [t3.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t3.c1]), batch_join=false
  6 - output([t3.c1], [PARTITION_ID], [t3.c2], [t3.c3]), filter(nil)
  7 - (#keys=1, [t3.c1]), output([t3.c1], [PARTITION_ID], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([? = t1.c1])
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 110(end)  ************** 

***************   Case 111   ***************

SQL: select /*+ use_nl(t2), use_merge(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |109 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |108 |
|2 |  NESTED-LOOP JOIN              |        |1        |107 |
|3 |   EXCHANGE IN DISTR            |        |1        |100 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |100 |
|5 |     NESTED-LOOP JOIN           |        |1        |99  |
|6 |      EXCHANGE IN DISTR         |        |1        |92  |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |92  |
|8 |        PX PARTITION ITERATOR   |        |1        |92  |
|9 |         TABLE SCAN             |t3      |1        |92  |
|10|      PX PARTITION ITERATOR     |        |1        |30  |
|11|       TABLE GET                |t1      |1        |30  |
|12|   PX PARTITION ITERATOR        |        |1        |18  |
|13|    TABLE GET                   |t2      |1        |18  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [PARTITION_ID], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t3.c1]), batch_join=false
  6 - output([t3.c1], [PARTITION_ID], [t3.c2], [t3.c3]), filter(nil)
  7 - (#keys=1, [t3.c1]), output([t3.c1], [PARTITION_ID], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])

*************** Case 111(end)  ************** 

***************   Case 112   ***************

SQL: select /*+ ordered, use_nl(t2), use_merge(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |329 |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |329 |
|2 |  MERGE JOIN                    |        |1        |328 |
|3 |   EXCHANGE IN MERGE SORT DISTR |        |1        |236 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |236 |
|5 |     NESTED-LOOP JOIN           |        |1        |235 |
|6 |      EXCHANGE IN DISTR         |        |1        |228 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |228 |
|8 |        PX PARTITION ITERATOR   |        |1        |228 |
|9 |         TABLE SCAN             |t1      |1        |228 |
|10|      PX PARTITION ITERATOR     |        |1        |18  |
|11|       TABLE GET                |t2      |1        |18  |
|12|   SORT                         |        |1        |92  |
|13|    PX PARTITION ITERATOR       |        |1        |92  |
|14|     TABLE SCAN                 |t3      |1        |92  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t3.c1], [t2.c1], [t1.c1], [t1.c2], [t2.c2], [t2.c3], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), Local Order
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  6 - output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 112(end)  ************** 

***************   Case 113   ***************

SQL: select /*+ index(t5 idx_t5_c2) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 113(end)  ************** 

***************   Case 114   ***************

SQL: select /*+ index(t5 idx_t5_c3) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t5(idx_t5_c3)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c3], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 114(end)  ************** 

***************   Case 115   ***************

SQL: select /*+ index(t5 primary) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |137 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |137 |
|2 |  PX PARTITION ITERATOR|        |1        |137 |
|3 |   TABLE SCAN          |t5      |1        |137 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 115(end)  ************** 

***************   Case 116   ***************

SQL: select /*+ index(t5 idx_t5_c2) */ * from t5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 116(end)  ************** 

***************   Case 117   ***************

SQL: select /*+ full(t5) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |137 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |137 |
|2 |  PX PARTITION ITERATOR|        |1        |137 |
|3 |   TABLE SCAN          |t5      |1        |137 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 117(end)  ************** 

***************   Case 118   ***************

SQL: select c1, c2 from t5 use index for join (idx_t5_c2) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 118(end)  ************** 

***************   Case 119   ***************

SQL: select c1, c2 from t5 use index for join (idx_t5_c2, primary) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 119(end)  ************** 

***************   Case 120   ***************

SQL: select c1, c2 from t5 use index for order by (idx_t5_c2) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 120(end)  ************** 

***************   Case 121   ***************

SQL: select c1, c2 from t5 force index for group by (idx_t5_c2) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 121(end)  ************** 

***************   Case 122   ***************

SQL: select c1, c2 from t5 use index (primary) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |137 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |137 |
|2 |  PX PARTITION ITERATOR|        |1        |137 |
|3 |   TABLE SCAN          |t5      |1        |137 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 122(end)  ************** 

***************   Case 123   ***************

SQL: select c1, c2 from t1 ignore index (idx_t1_c2) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |228 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |228 |
|2 |  PX PARTITION ITERATOR|        |1        |228 |
|3 |   TABLE SCAN          |t1      |1        |228 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = ? OR t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 123(end)  ************** 

***************   Case 124   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c2) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t5(idx_t5_c3)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c3], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 124(end)  ************** 

***************   Case 125   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c2, idx_t5_c3) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |137 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |137 |
|2 |  PX PARTITION ITERATOR|        |1        |137 |
|3 |   TABLE SCAN          |t5      |1        |137 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 125(end)  ************** 

***************   Case 126   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c3, primary) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 126(end)  ************** 

***************   Case 127   ***************

SQL: select max(c2) from t1 where c1 = 2; 

==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |EXCHANGE IN REMOTE  |     |1        |46  |
|1 | EXCHANGE OUT REMOTE|     |1        |46  |
|2 |  SCALAR GROUP BY   |     |1        |46  |
|3 |   SUBPLAN SCAN     |VIEW1|1        |46  |
|4 |    TABLE GET       |t1   |1        |46  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t1.c2)]), filter(nil)
  1 - output([T_FUN_MAX(VIEW1.t1.c2)]), filter(nil)
  2 - output([T_FUN_MAX(VIEW1.t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW1.t1.c2)])
  3 - output([VIEW1.t1.c2]), filter(nil), 
      access([VIEW1.t1.c2])
  4 - output([t1.c2]), filter([(T_OP_IS_NOT, t1.c2, NULL, 0)]), 
      access([t1.c2]), partitions(p2), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 127(end)  ************** 

***************   Case 128   ***************

SQL: select @@sql_mode, c1 from t1 limit 1; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |LIMIT                    |             |1        |1   |
|1 | PX COORDINATOR          |             |1        |1   |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |1   |
|3 |   LIMIT                 |             |1        |1   |
|4 |    PX PARTITION ITERATOR|             |1        |1   |
|5 |     TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 128(end)  ************** 

***************   Case 129   ***************

SQL: select 1+2 from dual; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 129(end)  ************** 

***************   Case 130   ***************

SQL: select c1 from t1 where c1 = 0 and c2 = 2; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t1  |1        |46  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[0 ; 0], 
      range_cond([t1.c1 = ?])

*************** Case 130(end)  ************** 

***************   Case 131   ***************

SQL: select /*+ ordered, use_merge(t3) */ * from t2, t3 where t2.c2 = t3.c1 and t2.c1 = 0 and t3.c1 = 0; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |92  |
|1 | TABLE GET                |t2  |1        |46  |
|2 | TABLE GET                |t3  |1        |46  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[0 ; 0], 
      range_cond([t2.c1 = ?])
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t3.c1]), range[0 ; 0], 
      range_cond([t3.c1 = ?])

*************** Case 131(end)  ************** 

***************   Case 132   ***************

SQL: select /*+ use_merge(t3) */ * from t2, t3 where t2.c1 = t3.c2 and t2.c1 = 0 and t3.c1 = 0; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |92  |
|1 | TABLE GET                |t3  |1        |46  |
|2 | TABLE GET                |t2  |1        |46  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter([? = t3.c2]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t3.c1]), range[0 ; 0], 
      range_cond([t3.c1 = ?])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t2.c1]), range[0 ; 0], 
      range_cond([t2.c1 = ?])

*************** Case 132(end)  ************** 

***************   Case 133   ***************

SQL: select c1 as c from t1 partition (p4, p3) as t where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t   |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t.c1]), filter(nil)
  1 - output([t.c1]), filter(nil)
  2 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p3), 
      is_index_back=false, 
      range_key([t.c1]), range[3 ; 3], 
      range_cond([t.c1 = ?])

*************** Case 133(end)  ************** 

***************   Case 134   ***************

SQL: select c1 from t1 partition (p1) where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 134(end)  ************** 

***************   Case 135   ***************

SQL: select count(*) from t1 partition(p1); 

======================================================
|ID|OPERATOR            |NAME         |EST. ROWS|COST|
------------------------------------------------------
|0 |EXCHANGE IN REMOTE  |             |1        |1   |
|1 | EXCHANGE OUT REMOTE|             |1        |1   |
|2 |  SCALAR GROUP BY   |             |1        |1   |
|3 |   TABLE SCAN       |t1(idx_t1_c2)|1        |1   |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil)
  1 - output([T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  3 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 135(end)  ************** 

***************   Case 136   ***************

SQL: select * from t1 partition(p1) join t2 partition(p2) on t1.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |54  |
|1 | EXCHANGE OUT DISTR             |:EX10001|1        |54  |
|2 |  NESTED-LOOP JOIN              |        |1        |53  |
|3 |   EXCHANGE IN DISTR            |        |1        |46  |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|1        |46  |
|5 |     TABLE SCAN                 |t1      |1        |46  |
|6 |   TABLE GET                    |t2      |1        |6   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), is_single, dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), is_single, dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])

*************** Case 136(end)  ************** 

***************   Case 137   ***************

SQL: explain select * from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 137(end)  ************** 

***************   Case 138   ***************

SQL: explain format = json select * from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 138(end)  ************** 

***************   Case 139   ***************

SQL: select sum(c1) from t1 where c1 = 3 group by c2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil)
  2 - output([?]), filter(nil), 
      access([t1.c1]), partitions(p3), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 139(end)  ************** 

***************   Case 140   ***************

SQL: select sum(1) as c from t1 where c1 = 3 group by c2 having c2 = 5 order by c1 limit 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil)
  2 - output([?]), filter([t1.c2 = ?]), 
      access([t1.c2]), partitions(p3), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 140(end)  ************** 

***************   Case 141   ***************

SQL: select sum(t7.c2) from t7, t8  where t7.c1 = t8.c1 and t7.c2 = 4 group by t7.c1 order by t7.c1 limit 1; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |LIMIT            |    |1        |56  |
|1 | NESTED-LOOP JOIN|    |1        |56  |
|2 |  TABLE SCAN     |t7  |1        |46  |
|3 |  TABLE GET      |t8  |1        |5   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), limit(1), offset(nil)
  1 - output(nil), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  2 - output([t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])

*************** Case 141(end)  ************** 

***************   Case 142   ***************

SQL: select c1, sum(c1+c2) from t2_no_part where c3 > 100 group by c2, c1; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t2_no_part|1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_no_part.c1], [cast(t2_no_part.c1 + t2_no_part.c2, DECIMAL(12, 0))]), filter([t2_no_part.c3 > ?]), 
      access([t2_no_part.c1], [t2_no_part.c3], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 142(end)  ************** 

***************   Case 143   ***************

SQL: select * from t2_no_part X, t2_no_part Y where X.c1 = Y.c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|X   |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([X.c1], [X.c2], [X.c3], [X.c1], [X.c2], [X.c3]), filter(nil), 
      access([X.c1], [X.c2], [X.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([X.c1]), range(MIN ; MAX)always true

*************** Case 143(end)  ************** 

***************   Case 144   ***************

SQL: select count(*) from t1 group by c1 having c1 = 2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([1]), filter(nil)
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 144(end)  ************** 

***************   Case 145   ***************

SQL: select sum(c2) from t1 group by c1 having c1 = 2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil)
  1 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil)
  2 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 145(end)  ************** 

***************   Case 146   ***************

SQL: select sum(c1) + count(c2) from t2_no_part; 

==============================================
|ID|OPERATOR       |NAME      |EST. ROWS|COST|
----------------------------------------------
|0 |SCALAR GROUP BY|          |1        |46  |
|1 | TABLE SCAN    |t2_no_part|1        |46  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t2_no_part.c1) + cast(T_FUN_COUNT(t2_no_part.c2), DECIMAL(20, 0))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2_no_part.c1)], [T_FUN_COUNT(t2_no_part.c2)])
  1 - output([t2_no_part.c1], [t2_no_part.c2]), filter(nil), 
      access([t2_no_part.c1], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 146(end)  ************** 

***************   Case 147   ***************

SQL: select sum(c1) from t2_no_part group by c2 order by sum(c1); 

==============================================
|ID|OPERATOR       |NAME      |EST. ROWS|COST|
----------------------------------------------
|0 |SORT           |          |1        |46  |
|1 | MERGE GROUP BY|          |1        |46  |
|2 |  SORT         |          |1        |46  |
|3 |   TABLE SCAN  |t2_no_part|1        |46  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t2_no_part.c1)]), filter(nil), sort_keys([T_FUN_SUM(t2_no_part.c1), ASC])
  1 - output([T_FUN_SUM(t2_no_part.c1)]), filter(nil), 
      group([t2_no_part.c2]), agg_func([T_FUN_SUM(t2_no_part.c1)])
  2 - output([t2_no_part.c2], [t2_no_part.c1]), filter(nil), sort_keys([t2_no_part.c2, ASC])
  3 - output([t2_no_part.c1], [t2_no_part.c2]), filter(nil), 
      access([t2_no_part.c1], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 147(end)  ************** 

***************   Case 148   ***************

SQL: select * from t4 where c2 = 3 and c3 = 4; 

===============================================
|ID|OPERATOR  |NAME            |EST. ROWS|COST|
-----------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2_c3)|1        |1   |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(3,4,MIN ; 3,4,MAX), 
      range_cond([t4.c2 = ?], [t4.c3 = ?])

*************** Case 148(end)  ************** 

***************   Case 149   ***************

SQL: select * from t4 where c1 = 2 and c2 = 3; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t4  |1        |46  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range[2,3 ; 2,3], 
      range_cond([t4.c1 = ?], [t4.c2 = ?])

*************** Case 149(end)  ************** 

***************   Case 150   ***************

SQL: select * from t4, t7 where t4.c1 + 2 + 2 = t7.c1; 

=====================================================
|ID|OPERATOR        |NAME            |EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN|                |1        |6   |
|1 | TABLE SCAN     |t4(idx_t4_c2_c3)|1        |1   |
|2 | TABLE GET      |t7              |1        |5   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([t4.c1 + ? + ?]), batch_join=true
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([? = t7.c1])

*************** Case 150(end)  ************** 

***************   Case 151   ***************

SQL: select sum(c1 + 1) from t4 group by c1, c2; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|1        |1   |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t4.c1 + ?, DECIMAL(12, 0))]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 151(end)  ************** 

***************   Case 152   ***************

SQL: select /*+ frozen_version(10) */ * from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 152(end)  ************** 

***************   Case 153   ***************

SQL: select /*+index(t4 idx_t4_c2_c3)*/ c2, c3 from t4 where c2 = 3 and c3 = 4 and c1 = 5; 

==============================================
|ID|OPERATOR |NAME            |EST. ROWS|COST|
----------------------------------------------
|0 |TABLE GET|t4(idx_t4_c2_c3)|1        |1   |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range[3,4,5 ; 3,4,5], 
      range_cond([t4.c2 = ?], [t4.c3 = ?], [t4.c1 = ?])

*************** Case 153(end)  ************** 

***************   Case 154   ***************

SQL: select * from t4 where c1 = 1 and c2 > 5 and c3 > 8; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c3)|1        |1   |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c2 > ?], [t4.c1 = ?]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t4.c3], [t4.c1], [t4.c2]), range(8,MAX,MAX ; MAX,1,MAX), 
      range_cond([t4.c3 > ?])

*************** Case 154(end)  ************** 

***************   Case 155   ***************

SQL: select * from t4 where c1 in (1) and c2 in (1, 2, 3, 4, 5); 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t4  |5        |1   |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range[1,1 ; 1,1], [1,2 ; 1,2], [1,3 ; 1,3], [1,4 ; 1,4], [1,5 ; 1,5], 
      range_cond([t4.c1 = ?], [t4.c2 IN (?, ?, ?, ?, ?)])

*************** Case 155(end)  ************** 

***************   Case 156   ***************

SQL: select * from t1 where c1 in (c1, 2, 3, 4); 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = t1.c1 OR t1.c1 IN (?, ?, ?)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 156(end)  ************** 

***************   Case 157   ***************

SQL: select * from t1 where 1 in (c1); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([? = t1.c1])

*************** Case 157(end)  ************** 

***************   Case 158   ***************

SQL: select * from t1 where 1 in (c1, c2); 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([? IN (t1.c1, t1.c2)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 158(end)  ************** 

***************   Case 159   ***************

SQL: select * from t1 where c1 = 1 or c2 = 1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = ? OR t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 159(end)  ************** 

***************   Case 160   ***************

SQL: select * from t1 where c1 in (1, 2, 3, 4); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |4        |185 |
|1 | EXCHANGE OUT DISTR    |:EX10000|4        |185 |
|2 |  PX PARTITION ITERATOR|        |4        |184 |
|3 |   TABLE GET           |t1      |4        |184 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[1-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], [2 ; 2], [3 ; 3], [4 ; 4], 
      range_cond([t1.c1 IN (?, ?, ?, ?)])

*************** Case 160(end)  ************** 

***************   Case 161   ***************

SQL: select * from t1 where exists (select * from t2 limit 0); 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |SUBPLAN FILTER            |             |1        |1   |
|1 | PX COORDINATOR           |             |1        |1   |
|2 |  EXCHANGE OUT DISTR      |:EX10000     |1        |1   |
|3 |   PX PARTITION ITERATOR  |             |1        |1   |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
|5 | LIMIT                    |             |0        |0   |
|6 |  PX COORDINATOR          |             |0        |0   |
|7 |   EXCHANGE OUT DISTR     |:EX20000     |0        |0   |
|8 |    LIMIT                 |             |0        |0   |
|9 |     PX PARTITION ITERATOR|             |0        |0   |
|10|      TABLE SCAN          |t2           |0        |0   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([1]), filter(nil), limit(0), offset(nil)
  6 - output(nil), filter(nil)
  7 - output(nil), filter(nil), dop=1
  8 - output(nil), filter(nil), limit(0), offset(nil)
  9 - output(nil), filter(nil), 
      force partition granule.
  10 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(0), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 161(end)  ************** 

***************   Case 162   ***************

SQL: select * from t7,t8 where t7.c1=t8.c1 order by t7.c1,t7.c2; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |51  |
|1 | TABLE SCAN     |t7  |1        |46  |
|2 | TABLE GET      |t8  |1        |5   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])

*************** Case 162(end)  ************** 

***************   Case 163   ***************

SQL: select * from t7,t8 where t7.c1=t8.c2 order by t7.c1,t7.c2; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SORT             |    |1        |51  |
|1 | NESTED-LOOP JOIN|    |1        |51  |
|2 |  TABLE SCAN     |t8  |1        |46  |
|3 |  TABLE GET      |t7  |1        |5   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), sort_keys([t7.c1, ASC])
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_([t8.c2]), batch_join=true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 = ?])

*************** Case 163(end)  ************** 

***************   Case 164   ***************

SQL: select c1/c2 as v,sum(c1) from t1 group by v order by v; 

<<<<<<< HEAD
============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |        |1        |229 |
|1 | EXCHANGE OUT DISTR            |:EX10001|1        |228 |
|2 |  MERGE GROUP BY               |        |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|1        |228 |
|5 |     MERGE GROUP BY            |        |1        |228 |
|6 |      SORT                     |        |1        |228 |
|7 |       PX PARTITION ITERATOR   |        |1        |228 |
|8 |        TABLE SCAN             |t1      |1        |228 |
============================================================
=======
================================================================
|ID|OPERATOR                      |NAME         |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |             |1        |1   |
|1 | EXCHANGE OUT DISTR           |:EX10001     |1        |1   |
|2 |  MERGE GROUP BY              |             |1        |1   |
|3 |   SORT                       |             |1        |1   |
|4 |    EXCHANGE IN DISTR         |             |1        |1   |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000     |1        |1   |
|6 |      PX PARTITION ITERATOR   |             |1        |1   |
|7 |       TABLE SCAN             |t1(idx_t1_c2)|1        |1   |
================================================================
>>>>>>> refine idnex scan cost

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0)), T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil), sort_keys([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0)), ASC])
  1 - output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [INTERNAL_FUNCTION(cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0)), T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil), dop=1
  2 - output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0)), ASC])
  4 - (#keys=1, [cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))]), output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  5 - output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))]), agg_func([T_FUN_SUM(t1.c1)])
  6 - output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [t1.c1]), filter(nil), sort_keys([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0)), ASC])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 164(end)  ************** 

***************   Case 165   ***************

SQL: select c2 from t1 for update; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 165(end)  ************** 

***************   Case 166   ***************

SQL: select * from t2 where exists (select * from t6 where t2.c1=t6.c1 limit 1) for update; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |145 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |145 |
|2 |  NESTED-LOOP JOIN           |        |1        |144 |
|3 |   EXCHANGE IN DISTR         |        |1        |137 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t6      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |18  |
|8 |    TABLE GET                |t2      |1        |18  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t6.c1]), batch_join=false
  3 - output([PARTITION_ID], [t6.c1]), filter(nil)
  4 - (#keys=1, [t6.c1]), output([PARTITION_ID], [t6.c1]), filter(nil), dop=1
  5 - output([t6.c1]), filter(nil), 
      force partition granule.
  6 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 166(end)  ************** 

***************   Case 167   ***************

SQL: select case when t4.c1=0 then 'a' else 'b' end  from t4 order by c3, c2; 

=============================================
|ID|OPERATOR   |NAME         |EST. ROWS|COST|
---------------------------------------------
|0 |SORT       |             |1        |1   |
|1 | TABLE SCAN|t4(idx_t4_c3)|1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN t4.c1 = ? THEN ? ELSE ? END]), filter(nil), sort_keys([t4.c3, ASC], [t4.c2, ASC]), prefix_pos(1)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c3], [t4.c1], [t4.c2]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 167(end)  ************** 

***************   Case 168   ***************

SQL: select case when t4.c1=0 then 'a' else 'b' end  from t4, t9 where t4.c1 = t9.c1; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |51  |
|1 | TABLE SCAN     |t4  |1        |46  |
|2 | TABLE GET      |t9  |1        |5   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN t4.c1 = ? THEN ? ELSE ? END]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=true
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output(nil), filter(nil), 
      access([t9.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX), 
      range_cond([? = t9.c1])

*************** Case 168(end)  ************** 

***************   Case 169   ***************

SQL: select * from t4 where t4.c1 = 1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 169(end)  ************** 

***************   Case 170   ***************

SQL: select * from t7 group by c1 order by c1 desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t7(Reverse)|1        |46  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 170(end)  ************** 

***************   Case 171   ***************

SQL: select * from t4 order by c1,c2 desc; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |SORT       |    |1        |46  |
|1 | TABLE SCAN|t4  |1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC], [t4.c2, DESC]), prefix_pos(1)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 171(end)  ************** 

***************   Case 172   ***************

SQL: select * from t4 order by c1 desc,c2 desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t4(Reverse)|1        |46  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 172(end)  ************** 

***************   Case 173   ***************

SQL: select * from (select * from t4 union select * from t4) as a; 

=========================================================
|ID|OPERATOR            |NAME            |EST. ROWS|COST|
---------------------------------------------------------
|0 |MERGE UNION DISTINCT|                |2        |1   |
|1 | TABLE SCAN         |t4(idx_t4_c2_c3)|1        |1   |
|2 | TABLE SCAN         |t4(idx_t4_c2_c3)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 173(end)  ************** 

***************   Case 174   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 and t2.c1=2; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |234 |
|1 | EXCHANGE OUT DISTR             |:EX10001|1        |233 |
|2 |  NESTED-LOOP OUTER JOIN        |        |1        |232 |
|3 |   EXCHANGE IN DISTR            |        |1        |229 |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|1        |228 |
|5 |     PX PARTITION ITERATOR      |        |1        |228 |
|6 |      TABLE SCAN                |t1      |1        |228 |
|7 |   TABLE GET                    |t2      |1        |4   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), is_single, dop=1
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?], [? = t2.c1])

*************** Case 174(end)  ************** 

***************   Case 175   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1=2; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |EXCHANGE IN REMOTE          |    |1        |93  |
|1 | EXCHANGE OUT REMOTE        |    |1        |93  |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |92  |
|3 |   TABLE GET                |t1  |1        |46  |
|4 |   TABLE GET                |t2  |1        |46  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])

*************** Case 175(end)  ************** 

***************   Case 176   ***************

SQL: select * from t1 right join t2 on t1.c1=t2.c1 and t2.c1=2; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |143 |
|1 | EXCHANGE OUT DISTR             |:EX10001|1        |143 |
|2 |  NESTED-LOOP OUTER JOIN        |        |1        |142 |
|3 |   EXCHANGE IN DISTR            |        |1        |139 |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|1        |139 |
|5 |     PX PARTITION ITERATOR      |        |1        |137 |
|6 |      TABLE SCAN                |t2      |1        |137 |
|7 |   TABLE GET                    |t1      |1        |4   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), is_single, dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?], [t1.c1 = ?])

*************** Case 176(end)  ************** 

***************   Case 177   ***************

SQL: select * from t1 right join t2 on t1.c1=t2.c1 where t2.c1=2; 

===========================================================
|ID|OPERATOR                          |NAME|EST. ROWS|COST|
-----------------------------------------------------------
|0 |EXCHANGE IN REMOTE                |    |1        |93  |
|1 | EXCHANGE OUT REMOTE              |    |1        |93  |
|2 |  NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |92  |
|3 |   TABLE GET                      |t2  |1        |46  |
|4 |   TABLE GET                      |t1  |1        |46  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 177(end)  ************** 

***************   Case 178   ***************

SQL: select * from t1 full join t2 on t1.c1=t2.c1 and t2.c1=2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |366 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |366 |
|2 |  HASH FULL OUTER JOIN       |        |1        |365 |
|3 |   EXCHANGE IN DISTR         |        |1        |228 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |228 |
|5 |     PX PARTITION ITERATOR   |        |1        |228 |
|6 |      TABLE SCAN             |t1      |1        |228 |
|7 |   PX PARTITION ITERATOR     |        |1        |137 |
|8 |    TABLE SCAN               |t2      |1        |137 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t2.c1 = ?])
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 178(end)  ************** 

***************   Case 179   ***************

SQL: select * from t1 full join t2 on t1.c1=t2.c1 where t2.c1=2; 

===========================================================
|ID|OPERATOR                          |NAME|EST. ROWS|COST|
-----------------------------------------------------------
|0 |EXCHANGE IN REMOTE                |    |1        |93  |
|1 | EXCHANGE OUT REMOTE              |    |1        |93  |
|2 |  NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |92  |
|3 |   TABLE GET                      |t2  |1        |46  |
|4 |   TABLE GET                      |t1  |1        |46  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 179(end)  ************** 

***************   Case 180   ***************

SQL: select c2 from t1 where exists (select * from t2 where t1.c1=t2.c1 limit 1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |144 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |144 |
|2 |  NESTED-LOOP JOIN           |        |1        |144 |
|3 |   EXCHANGE IN DISTR         |        |1        |137 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t2      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |30  |
|8 |    TABLE GET                |t1      |1        |30  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([PARTITION_ID], [t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([PARTITION_ID], [t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 180(end)  ************** 

***************   Case 181   ***************

SQL: select c1 from (select c1, c2 from t1 limit 1) t; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |LIMIT                    |             |1        |1   |
|1 | PX COORDINATOR          |             |1        |1   |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |1   |
|3 |   LIMIT                 |             |1        |1   |
|4 |    PX PARTITION ITERATOR|             |1        |1   |
|5 |     TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 181(end)  ************** 

***************   Case 182   ***************

SQL: select sum(c) from (select c1 as c from t1 union select c1 as c from t1) as a; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SCALAR GROUP BY           |        |1        |455 |
|1 | PX COORDINATOR           |        |1        |455 |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |455 |
|3 |   MERGE GROUP BY         |        |1        |455 |
|4 |    SUBPLAN SCAN          |a       |2        |455 |
|5 |     PX PARTITION ITERATOR|        |2        |455 |
|6 |      MERGE UNION DISTINCT|        |2        |455 |
|7 |       TABLE SCAN         |t1      |1        |228 |
|8 |       TABLE SCAN         |t1      |1        |228 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(a.c))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(a.c))])
  1 - output([T_FUN_SUM(a.c)]), filter(nil)
  2 - output([T_FUN_SUM(a.c)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(a.c)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(a.c)])
  4 - output([a.c]), filter(nil), 
      access([a.c])
  5 - output([UNION([1])]), filter(nil), 
      partition wise, force partition granule.
  6 - output([UNION([1])]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 182(end)  ************** 

***************   Case 183   ***************

SQL: select * from t2 where 'cb' <= c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |137 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |137 |
|2 |  PX PARTITION ITERATOR|        |1        |137 |
|3 |   TABLE SCAN          |t2      |1        |137 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule.
  3 - output([t2.c1], [t2.c3], [t2.c2]), filter([? <= t2.c3]), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 183(end)  ************** 

***************   Case 184   ***************

SQL: select t7.c1 = t8.c2 from t7, t8 where t7.c1 = t8.c1; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |51  |
|1 | TABLE SCAN     |t7  |1        |46  |
|2 | TABLE GET      |t8  |1        |5   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1 = t8.c2]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])

*************** Case 184(end)  ************** 

***************   Case 185   ***************

SQL: select t11.c2 from (select c1,c2 from t4 limit 1) as t11 , t6 where t11.c1>t6.c1; 

=====================================================================
|ID|OPERATOR                        |NAME            |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |PX COORDINATOR                  |                |1        |22  |
|1 | EXCHANGE OUT DISTR             |:EX10001        |1        |22  |
|2 |  NESTED-LOOP JOIN              |                |1        |22  |
|3 |   EXCHANGE IN DISTR            |                |1        |1   |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000        |1        |1   |
|5 |     SUBPLAN SCAN               |t11             |1        |1   |
|6 |      TABLE SCAN                |t4(idx_t4_c2_c3)|1        |1   |
|7 |   PX PARTITION ITERATOR        |                |1        |18  |
|8 |    TABLE SCAN                  |t6              |1        |18  |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t11.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t11.c2)]), filter(nil), dop=1
  2 - output([t11.c2]), filter(nil), 
      conds(nil), nl_params_([t11.c1]), batch_join=false
  3 - output([t11.c1], [t11.c2]), filter(nil)
  4 - output([t11.c1], [t11.c2]), filter(nil), is_single, dop=1
  5 - output([t11.c1], [t11.c2]), filter(nil), 
      access([t11.c1], [t11.c2])
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output(nil), filter(nil), 
      access all, force partition granule.
  8 - output(nil), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX), 
      range_cond([? > t6.c1])

*************** Case 185(end)  ************** 

***************   Case 186   ***************

SQL: select t11.c2 from (select c1,c2 from t4) t11 left join t6 on t11.c1=1; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |             |1        |137 |
|1 | TABLE SCAN              |t4(idx_t4_c2)|1        |1   |
|2 | MATERIAL                |             |1        |137 |
|3 |  PX COORDINATOR         |             |1        |137 |
|4 |   EXCHANGE OUT DISTR    |:EX10000     |1        |137 |
|5 |    PX PARTITION ITERATOR|             |1        |137 |
|6 |     TABLE SCAN          |t6           |1        |137 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), 
      conds([t4.c1 = ?]), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), dop=1
  5 - output(nil), filter(nil), 
      force partition granule.
  6 - output(nil), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 186(end)  ************** 

***************   Case 187   ***************

SQL: select * from t2,t4 where t2.c1=t4.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |54  |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |54  |
|2 |  NESTED-LOOP JOIN           |        |1        |53  |
|3 |   EXCHANGE IN DISTR         |        |1        |46  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|5 |     TABLE SCAN              |t4      |1        |46  |
|6 |   PX PARTITION ITERATOR     |        |1        |18  |
|7 |    TABLE GET                |t2      |1        |18  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t4.c1, t4.c2, t4.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t4.c1, t4.c2, t4.c3)]), filter(nil), dop=1
  2 - output([t4.c1], [t4.c2], [t4.c3], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=false
  3 - output([t4.c1], [PARTITION_ID], [t4.c2], [t4.c3]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1], [PARTITION_ID], [t4.c2], [t4.c3]), filter(nil), is_single, dop=1
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 187(end)  ************** 

***************   Case 188   ***************

SQL: select * from t2,t6 where t2.c1=t6.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |145 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |145 |
|2 |  NESTED-LOOP JOIN           |        |1        |144 |
|3 |   EXCHANGE IN DISTR         |        |1        |137 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t6      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |18  |
|8 |    TABLE GET                |t2      |1        |18  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2)]), filter(nil), dop=1
  2 - output([t6.c1], [t6.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t6.c1]), batch_join=false
  3 - output([t6.c1], [PARTITION_ID], [t6.c2]), filter(nil)
  4 - (#keys=1, [t6.c1]), output([t6.c1], [PARTITION_ID], [t6.c2]), filter(nil), dop=1
  5 - output([t6.c1], [t6.c2]), filter(nil), 
      force partition granule.
  6 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 188(end)  ************** 

***************   Case 189   ***************

SQL: select * from t2,t6,t7 where t2.c1=t6.c1 and t6.c1=t7.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |62  |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |61  |
|2 |  NESTED-LOOP JOIN              |        |1        |60  |
|3 |   EXCHANGE IN DISTR            |        |1        |53  |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |53  |
|5 |     NESTED-LOOP JOIN           |        |1        |53  |
|6 |      EXCHANGE IN DISTR         |        |1        |46  |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|8 |        TABLE SCAN              |t7      |1        |46  |
|9 |      PX PARTITION ITERATOR     |        |1        |18  |
|10|       TABLE GET                |t6      |1        |18  |
|11|   PX PARTITION ITERATOR        |        |1        |18  |
|12|    TABLE GET                   |t2      |1        |18  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2, t7.c1, t7.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2, t7.c1, t7.c2)]), filter(nil), dop=1
  2 - output([t6.c1], [t7.c1], [t7.c2], [t6.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t6.c1]), batch_join=false
  3 - output([t6.c1], [PARTITION_ID], [t7.c1], [t7.c2], [t6.c2]), filter(nil)
  4 - (#keys=1, [t6.c1]), output([t6.c1], [PARTITION_ID], [t7.c1], [t7.c2], [t6.c2]), filter(nil), dop=1
  5 - output([t6.c1], [t7.c1], [t7.c2], [t6.c2]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=false
  6 - output([t7.c1], [PARTITION_ID], [t7.c2]), filter(nil)
  7 - (#keys=1, [t7.c1]), output([t7.c1], [PARTITION_ID], [t7.c2]), filter(nil), is_single, dop=1
  8 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  9 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule.
  10 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX), 
      range_cond([t6.c1 = ?])
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 189(end)  ************** 

***************   Case 190   ***************

SQL: select c1 from t2 union select c1 from t6; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |2        |275 |
|1 | EXCHANGE OUT DISTR          |:EX10001|2        |275 |
|2 |  HASH UNION DISTINCT        |        |2        |275 |
|3 |   PX PARTITION ITERATOR     |        |1        |137 |
|4 |    TABLE SCAN               |t2      |1        |137 |
|5 |   EXCHANGE IN DISTR         |        |1        |137 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|7 |     PX PARTITION ITERATOR   |        |1        |137 |
|8 |      TABLE SCAN             |t6      |1        |137 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t6.c1]), filter(nil)
  6 - (#keys=1, [t6.c1]), output([t6.c1]), filter(nil), dop=1
  7 - output([t6.c1]), filter(nil), 
      force partition granule.
  8 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 190(end)  ************** 

***************   Case 191   ***************

SQL: select c1 from t2 union all select c1 from t6; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |2        |274 |
|1 | EXCHANGE OUT DISTR    |:EX10000|2        |274 |
|2 |  PX PARTITION ITERATOR|        |2        |274 |
|3 |   UNION ALL           |        |2        |274 |
|4 |    TABLE SCAN         |t2      |1        |137 |
|5 |    TABLE SCAN         |t6      |1        |137 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil), 
      partition wise, force partition granule.
  3 - output([UNION([1])]), filter(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 191(end)  ************** 

***************   Case 192   ***************

SQL: select * from t2 where exists (select * from t6 where t2.c1=t6.c1 limit 1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |145 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |145 |
|2 |  NESTED-LOOP JOIN           |        |1        |144 |
|3 |   EXCHANGE IN DISTR         |        |1        |137 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t6      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |18  |
|8 |    TABLE GET                |t2      |1        |18  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t6.c1]), batch_join=false
  3 - output([PARTITION_ID], [t6.c1]), filter(nil)
  4 - (#keys=1, [t6.c1]), output([PARTITION_ID], [t6.c1]), filter(nil), dop=1
  5 - output([t6.c1]), filter(nil), 
      force partition granule.
  6 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 192(end)  ************** 

***************   Case 193   ***************

SQL: select * from t2 where exists (select * from t4 where t2.c1=t4.c1 limit 1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |54  |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |54  |
|2 |  NESTED-LOOP JOIN           |        |1        |53  |
|3 |   EXCHANGE IN DISTR         |        |1        |46  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|5 |     SUBPLAN SCAN            |VIEW2   |1        |46  |
|6 |      MERGE DISTINCT         |        |1        |46  |
|7 |       TABLE SCAN            |t4      |1        |46  |
|8 |   PX PARTITION ITERATOR     |        |1        |18  |
|9 |    TABLE GET                |t2      |1        |18  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.t4.c1]), batch_join=false
  3 - output([PARTITION_ID], [VIEW2.VIEW1.t4.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.VIEW1.t4.c1]), output([PARTITION_ID], [VIEW2.VIEW1.t4.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.VIEW1.t4.c1]), filter(nil), 
      access([VIEW2.VIEW1.t4.c1])
  6 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 193(end)  ************** 

***************   Case 194   ***************

SQL: select * from t2 where exists (select * from t1 where t2.c1=t1.c1 limit 1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |145 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |145 |
|2 |  NESTED-LOOP JOIN           |        |1        |145 |
|3 |   EXCHANGE IN DISTR         |        |1        |138 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |138 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t2      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |30  |
|8 |    TABLE GET                |t1      |1        |30  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output(nil), filter(nil), 
      affinitize, force partition granule.
  8 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([? = t1.c1])

*************** Case 194(end)  ************** 

***************   Case 195   ***************

SQL: select sum(c1) as c from t1 union select sum(c1) as c from t1; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |TEMP TABLE TRANSFORMATION  |             |2        |1   |
|1 | TEMP TABLE INSERT         |TEMP1        |1        |1   |
|2 |  SCALAR GROUP BY          |             |1        |1   |
|3 |   PX COORDINATOR          |             |1        |1   |
|4 |    EXCHANGE OUT DISTR     |:EX10000     |1        |1   |
|5 |     MERGE GROUP BY        |             |1        |1   |
|6 |      PX PARTITION ITERATOR|             |1        |1   |
|7 |       TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
|8 | MERGE UNION DISTINCT      |             |2        |1   |
|9 |  TEMP TABLE ACCESS        |VIEW1(TEMP1) |1        |1   |
|10|  TEMP TABLE ACCESS        |VIEW2(TEMP1) |1        |1   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output(nil), filter(nil)
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  8 - output([UNION([1])]), filter(nil)
  9 - output([VIEW1.T_FUN_SUM(t1.c1)]), filter(nil), 
      access([VIEW1.T_FUN_SUM(t1.c1)])
  10 - output([VIEW2.T_FUN_SUM(t1.c1)]), filter(nil), 
      access([VIEW2.T_FUN_SUM(t1.c1)])

*************** Case 195(end)  ************** 

***************   Case 196   ***************

SQL: select sum(c) from (select sum(c1) as c from t1 union select sum(c1) as c from t1) as a; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |TEMP TABLE TRANSFORMATION  |             |1        |1   |
|1 | TEMP TABLE INSERT         |TEMP1        |1        |1   |
|2 |  SCALAR GROUP BY          |             |1        |1   |
|3 |   PX COORDINATOR          |             |1        |1   |
|4 |    EXCHANGE OUT DISTR     |:EX10000     |1        |1   |
|5 |     MERGE GROUP BY        |             |1        |1   |
|6 |      PX PARTITION ITERATOR|             |1        |1   |
|7 |       TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
|8 | SCALAR GROUP BY           |             |1        |1   |
|9 |  SUBPLAN SCAN             |a            |2        |1   |
|10|   MERGE UNION DISTINCT    |             |2        |1   |
|11|    TEMP TABLE ACCESS      |VIEW1(TEMP1) |1        |1   |
|12|    TEMP TABLE ACCESS      |VIEW2(TEMP1) |1        |1   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(a.c)]), filter(nil)
  1 - output(nil), filter(nil)
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  8 - output([T_FUN_SUM(a.c)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(a.c)])
  9 - output([a.c]), filter(nil), 
      access([a.c])
  10 - output([UNION([1])]), filter(nil)
  11 - output([VIEW1.T_FUN_SUM(t1.c1)]), filter(nil), 
      access([VIEW1.T_FUN_SUM(t1.c1)])
  12 - output([VIEW2.T_FUN_SUM(t1.c1)]), filter(nil), 
      access([VIEW2.T_FUN_SUM(t1.c1)])

*************** Case 196(end)  ************** 

***************   Case 197   ***************

SQL: select * from t4 where c1; 

===============================================
|ID|OPERATOR  |NAME            |EST. ROWS|COST|
-----------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2_c3)|1        |1   |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 197(end)  ************** 

***************   Case 198   ***************

SQL: select * from t4, t4 t where t4.c1; 

===============================================================
|ID|OPERATOR                  |NAME            |EST. ROWS|COST|
---------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|                |1        |1   |
|1 | TABLE SCAN               |t(idx_t4_c2_c3) |1        |1   |
|2 | MATERIAL                 |                |1        |1   |
|3 |  TABLE SCAN              |t4(idx_t4_c2_c3)|1        |1   |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t.c1], [t.c2], [t.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c2], [t.c3], [t.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 198(end)  ************** 

***************   Case 199   ***************

SQL: select * from t4 left join t4 a on t4.c1; 

===========================================================
|ID|OPERATOR              |NAME            |EST. ROWS|COST|
-----------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|                |1        |1   |
|1 | TABLE SCAN           |t4(idx_t4_c2_c3)|1        |1   |
|2 | MATERIAL             |                |1        |1   |
|3 |  TABLE SCAN          |a(idx_t4_c2_c3) |1        |1   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [a.c1], [a.c2], [a.c3]), filter(nil), 
      conds([BOOL(t4.c1)]), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([a.c1], [a.c2], [a.c3]), filter(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([a.c2], [a.c3], [a.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 199(end)  ************** 

***************   Case 200   ***************

SQL: select t1.c2  from t1,t2 where t2.c1 in(t1.c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |144 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |144 |
|2 |  NESTED-LOOP JOIN           |        |1        |144 |
|3 |   EXCHANGE IN DISTR         |        |1        |137 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t2      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |30  |
|8 |    TABLE GET                |t1      |1        |30  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([PARTITION_ID], [t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([PARTITION_ID], [t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([? = t1.c1])

*************** Case 200(end)  ************** 

***************   Case 201   ***************

SQL: select  * from t3 join t4 on t3.c1>t4.c1 where t4.c1 in (t3.c1, t3.c1); 

=====================================================================
|ID|OPERATOR                        |NAME            |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |PX COORDINATOR                  |                |1        |16  |
|1 | EXCHANGE OUT DISTR             |:EX10001        |1        |16  |
|2 |  NESTED-LOOP JOIN              |                |1        |15  |
|3 |   EXCHANGE IN DISTR            |                |1        |1   |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000        |1        |1   |
|5 |     TABLE SCAN                 |t4(idx_t4_c2_c3)|1        |1   |
|6 |   PX PARTITION ITERATOR        |                |1        |12  |
|7 |    TABLE GET                   |t3              |1        |12  |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t3.c1, t3.c2, t3.c3, t4.c1, t4.c2, t4.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t3.c1, t3.c2, t3.c3, t4.c1, t4.c2, t4.c3)]), filter(nil), dop=1
  2 - output([t4.c1], [t4.c2], [t4.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=false
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), is_single, dop=1
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access all, force partition granule.
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 > ?], [? IN (t3.c1, t3.c1)])

*************** Case 201(end)  ************** 

***************   Case 202   ***************

SQL: select * from t1 where c1 in (select t2.c1 from t2 left join t3 on t2.c1=t3.c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |144 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |144 |
|2 |  NESTED-LOOP JOIN           |        |1        |144 |
|3 |   EXCHANGE IN DISTR         |        |1        |137 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |t2      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |30  |
|8 |    TABLE GET                |t1      |1        |30  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([PARTITION_ID], [t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([PARTITION_ID], [t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 202(end)  ************** 

***************   Case 203   ***************

SQL: select /*+use_merge(t10,t11)*/* from t10, t11 where t10.c2=t11.c2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |184 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |184 |
|2 |  PX PARTITION ITERATOR|        |1        |183 |
|3 |   MERGE JOIN          |        |1        |183 |
|4 |    SORT               |        |1        |92  |
|5 |     TABLE SCAN        |t10     |1        |92  |
|6 |    SORT               |        |1        |92  |
|7 |     TABLE SCAN        |t11     |1        |92  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t10.c1, t10.c2, t10.c3, t11.c1, t11.c2, t11.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t10.c1, t10.c2, t10.c3, t11.c1, t11.c2, t11.c3)]), filter(nil), dop=1
  2 - output([t10.c2], [t11.c2], [t10.c1], [t10.c3], [t11.c1], [t11.c3]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t10.c2], [t11.c2], [t10.c1], [t10.c3], [t11.c1], [t11.c3]), filter(nil), 
      equal_conds([t10.c2 = t11.c2]), other_conds(nil)
  4 - output([t10.c2], [t10.c1], [t10.c3]), filter(nil), sort_keys([t10.c2, ASC])
  5 - output([t10.c1], [t10.c2], [t10.c3]), filter(nil), 
      access([t10.c1], [t10.c2], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t11.c2], [t11.c1], [t11.c3]), filter(nil), sort_keys([t11.c2, ASC])
  7 - output([t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      access([t11.c1], [t11.c2], [t11.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 203(end)  ************** 

***************   Case 204   ***************

SQL: select c1 from t1 where c1 not in (select c1 from t2 where c2 not in (select c2 from t2)); 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |1        |502 |
|1 | EXCHANGE OUT DISTR           |:EX10003|1        |502 |
|2 |  HASH RIGHT ANTI JOIN        |        |1        |502 |
|3 |   EXCHANGE IN DISTR          |        |1        |274 |
|4 |    EXCHANGE OUT DISTR (PKEY) |:EX10002|1        |274 |
|5 |     SUBPLAN SCAN             |VIEW2   |1        |274 |
|6 |      HASH RIGHT ANTI JOIN NA |        |1        |274 |
|7 |       EXCHANGE IN DISTR      |        |1        |137 |
|8 |        EXCHANGE OUT DISTR    |:EX10000|1        |137 |
|9 |         PX PARTITION ITERATOR|        |1        |137 |
|10|          TABLE SCAN          |t2      |1        |137 |
|11|       EXCHANGE IN DISTR      |        |1        |137 |
|12|        EXCHANGE OUT DISTR    |:EX10001|1        |137 |
|13|         PX PARTITION ITERATOR|        |1        |137 |
|14|          TABLE SCAN          |t2      |1        |137 |
|15|   PX PARTITION ITERATOR      |        |1        |228 |
|16|    TABLE SCAN                |t1      |1        |228 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.c1]), other_conds(nil)
  3 - output([VIEW2.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.c1]), output([VIEW2.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t2.c2]), other_conds(nil)
  7 - output([t2.c2]), filter(nil)
  8 - output([t2.c2]), filter(nil), dop=1
  9 - output([t2.c2]), filter(nil), 
      force partition granule.
  10 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t2.c1], [t2.c2]), filter(nil)
  12 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  13 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  14 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  15 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  16 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 204(end)  ************** 

***************   Case 205   ***************

SQL: select distinct c1 from t1 order by c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |1        |1   |
|1 | EXCHANGE OUT DISTR       |:EX10000     |1        |1   |
|2 |  SORT                    |             |1        |1   |
|3 |   PX PARTITION ITERATOR  |             |1        |1   |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 205(end)  ************** 

***************   Case 206   ***************

SQL: SELECT c1, c2  FROM t1 WHERE c2 IN (ROUND(-1), 0, '5', '1'); 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(-1,MIN ; -1,MAX), (0,MIN ; 0,MAX), (5,MIN ; 5,MAX), (1,MIN ; 1,MAX), 
      range_cond([t1.c2 IN (?, ?) OR cast(t1.c2, DECIMAL(11, 0)) IN (?, ?)])

*************** Case 206(end)  ************** 

***************   Case 207   ***************

SQL: select count(*) from (select count(*) as a  from t4) t ; 

======================================================
|ID|OPERATOR         |NAME            |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY  |                |1        |1   |
|1 | SUBPLAN SCAN    |t               |1        |1   |
|2 |  SCALAR GROUP BY|                |1        |1   |
|3 |   TABLE SCAN    |t4(idx_t4_c2_c3)|1        |1   |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  3 - output(nil), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 207(end)  ************** 

***************   Case 208   ***************

SQL: (select * from t1 where c1 = 2) union all (select * from t1 where c1 = 2); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |2        |92  |
|1 | EXCHANGE OUT REMOTE|    |2        |92  |
|2 |  UNION ALL         |    |2        |91  |
|3 |   TABLE GET        |t1  |1        |46  |
|4 |   TABLE GET        |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([UNION([1])], [UNION([2])]), filter(nil)
  3 - output([?], [t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])
  4 - output([?], [t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 208(end)  ************** 

***************   Case 209   ***************

SQL: select * from t1 X, t1 Y where X.c1 = Y.c1 and X.c1 = 1 and Y.c1 = 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |X   |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([X.c1], [X.c2], [X.c1], [X.c2]), filter(nil)
  1 - output([X.c1], [X.c2], [X.c1], [X.c2]), filter(nil)
  2 - output([X.c1], [X.c2]), filter(nil), 
      access([X.c1], [X.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([X.c1]), range[1 ; 1], 
      range_cond([X.c1 = ?], [X.c1 = ?])

*************** Case 209(end)  ************** 

***************   Case 210   ***************

SQL: select distinct c2, c1 from t1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2, t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 210(end)  ************** 

***************   Case 211   ***************

SQL: select (select c1 from t7),c2 from t8; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |91  |
|1 | TABLE SCAN   |t8  |1        |46  |
|2 | TABLE SCAN   |t7  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t8.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 211(end)  ************** 

***************   Case 212   ***************

SQL: select (select c1 from t7 where c2=t8.c2), c2 from t8; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |91  |
|1 | TABLE SCAN   |t8  |1        |46  |
|2 | TABLE SCAN   |t7  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([subquery(1)], [t8.c2]), filter(nil), 
      exec_params_([t8.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 212(end)  ************** 

***************   Case 213   ***************

SQL: select c1 from t7 group by (select c1 from t8), c2; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |91  |
|1 | SORT           |    |1        |91  |
|2 |  SUBPLAN FILTER|    |1        |91  |
|3 |   TABLE SCAN   |t7  |1        |46  |
|4 |   TABLE SCAN   |t8  |1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c2], [t7.c1]), filter(nil), sort_keys([t7.c2, ASC])
  2 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 213(end)  ************** 

***************   Case 214   ***************

SQL: select c1 from t7 group by (select c1 from t8 where c2=t7.c2),c2; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |91  |
|1 | SORT           |    |1        |91  |
|2 |  SUBPLAN FILTER|    |1        |91  |
|3 |   TABLE SCAN   |t7  |1        |46  |
|4 |   TABLE SCAN   |t8  |1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([subquery(1)], [t7.c2]), agg_func(nil)
  1 - output([subquery(1)], [t7.c2], [t7.c1]), filter(nil), sort_keys([subquery(1), ASC], [t7.c2, ASC])
  2 - output([subquery(1)], [t7.c2], [t7.c1]), filter(nil), 
      exec_params_([t7.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter([t8.c2 = ?]), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 214(end)  ************** 

***************   Case 215   ***************

SQL: select c1, sum(c2) from t4 group by c1 having sum(c2) < (select 1); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |1        |46  |
|1 | TABLE SCAN   |t4  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [T_FUN_SUM(t4.c2)]), filter([T_FUN_SUM(t4.c2) < ?]), 
      group([t4.c1]), agg_func([T_FUN_SUM(t4.c2)])
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 215(end)  ************** 

***************   Case 216   ***************

SQL: select c1 from t7 order by (select c1 from t8), c2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SORT           |    |1        |91  |
|1 | SUBPLAN FILTER|    |1        |91  |
|2 |  TABLE SCAN   |t7  |1        |46  |
|3 |  TABLE SCAN   |t8  |1        |46  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 216(end)  ************** 

***************   Case 217   ***************

SQL: select c1 from t7 order by (select c1 from t8 where c2=t7.c2),c2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SORT           |    |1        |91  |
|1 | SUBPLAN FILTER|    |1        |91  |
|2 |  TABLE SCAN   |t7  |1        |46  |
|3 |  TABLE SCAN   |t8  |1        |46  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([subquery(1), ASC], [t7.c2, ASC])
  1 - output([subquery(1)], [t7.c2], [t7.c1]), filter(nil), 
      exec_params_([t7.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter([t8.c2 = ?]), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 217(end)  ************** 

***************   Case 218   ***************

SQL: select (select 1, 2, 3)=row(1, 2, 3); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | EXPRESSION   |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1) = (?, ?, ?)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([?], [?], [?]), filter(nil)
      values({?, ?, ?})

*************** Case 218(end)  ************** 

***************   Case 219   ***************

SQL: select count(1) from t1; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SCALAR GROUP BY          |             |1        |1   |
|1 | PX COORDINATOR          |             |1        |1   |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |1   |
|3 |   MERGE GROUP BY        |             |1        |1   |
|4 |    PX PARTITION ITERATOR|             |1        |1   |
|5 |     TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 219(end)  ************** 

***************   Case 220   ***************

SQL: select (select 1); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 220(end)  ************** 

***************   Case 221   ***************

SQL: (select (select 1)) union (select (select 1)); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 221(end)  ************** 

***************   Case 222   ***************

SQL: SELECT distinct '' , 1 FROM DUAL limit 2 offset 1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |LIMIT      |    |0        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?]), filter(nil), limit(2), offset(?)
  1 - output([1]), filter(nil)
      values({1})

*************** Case 222(end)  ************** 

***************   Case 223   ***************

SQL: select * from t1,t1 t; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|             |1        |1   |
|1 | PX COORDINATOR           |             |1        |1   |
|2 |  EXCHANGE OUT DISTR      |:EX10000     |1        |1   |
|3 |   PX PARTITION ITERATOR  |             |1        |1   |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
|5 | MATERIAL                 |             |1        |1   |
|6 |  PX COORDINATOR          |             |1        |1   |
|7 |   EXCHANGE OUT DISTR     |:EX20000     |1        |1   |
|8 |    PX PARTITION ITERATOR |             |1        |1   |
|9 |     TABLE SCAN           |t(idx_t1_c2) |1        |1   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t.c1], [t.c2]), filter(nil)
  6 - output([t.c1], [t.c2]), filter(nil)
  7 - output([t.c1], [t.c2]), filter(nil), dop=1
  8 - output([t.c1], [t.c2]), filter(nil), 
      force partition granule.
  9 - output([t.c1], [t.c2]), filter(nil), 
      access([t.c1], [t.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c2], [t.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 223(end)  ************** 

***************   Case 224   ***************

SQL: select * from t1,t1 t where t1.c1<t.c1; 

==================================================================
|ID|OPERATOR                        |NAME         |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR                  |             |1        |35  |
|1 | EXCHANGE OUT DISTR             |:EX10001     |1        |35  |
|2 |  NESTED-LOOP JOIN              |             |1        |34  |
|3 |   EXCHANGE IN DISTR            |             |1        |2   |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR      |             |1        |1   |
|6 |      TABLE SCAN                |t1(idx_t1_c2)|1        |1   |
|7 |   PX PARTITION ITERATOR        |             |1        |30  |
|8 |    TABLE SCAN                  |t            |1        |30  |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t.c1, t.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t.c1, t.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t.c1], [t.c2]), filter(nil), 
      access all, force partition granule.
  8 - output([t.c1], [t.c2]), filter(nil), 
      access([t.c1], [t.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX), 
      range_cond([? < t.c1])

*************** Case 224(end)  ************** 

***************   Case 225   ***************

SQL: (select * from t4) union (select * from t4) order by (select c1 from t4 limit 1); 

==========================================================
|ID|OPERATOR             |NAME            |EST. ROWS|COST|
----------------------------------------------------------
|0 |SUBPLAN FILTER       |                |2        |1   |
|1 | MERGE UNION DISTINCT|                |2        |1   |
|2 |  TABLE SCAN         |t4(idx_t4_c2_c3)|1        |1   |
|3 |  TABLE SCAN         |t4(idx_t4_c2_c3)|1        |1   |
|4 | TABLE SCAN          |t4(idx_t4_c2_c3)|1        |1   |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  4 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 225(end)  ************** 

***************   Case 226   ***************

SQL: select 1 from dual where 1 in (select 1 from dual); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 226(end)  ************** 

***************   Case 227   ***************

SQL: select count(c1) + 1 from t1; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SCALAR GROUP BY          |             |1        |1   |
|1 | PX COORDINATOR          |             |1        |1   |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |1   |
|3 |   MERGE GROUP BY        |             |1        |1   |
|4 |    PX PARTITION ITERATOR|             |1        |1   |
|5 |     TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) + ?]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  1 - output([T_FUN_COUNT(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 227(end)  ************** 

***************   Case 228   ***************

SQL: select count(c1) + 1 + 1 from t1; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SCALAR GROUP BY          |             |1        |1   |
|1 | PX COORDINATOR          |             |1        |1   |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |1   |
|3 |   MERGE GROUP BY        |             |1        |1   |
|4 |    PX PARTITION ITERATOR|             |1        |1   |
|5 |     TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) + ? + ?]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  1 - output([T_FUN_COUNT(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 228(end)  ************** 

***************   Case 229   ***************

SQL: SELECT (select max(t1.c1) from t1) as field from t1 group by field; 

<<<<<<< HEAD
============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |1        |229 |
|1 | EXCHANGE OUT DISTR            |:EX10001|1        |229 |
|2 |  MERGE GROUP BY               |        |1        |229 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |1        |229 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|1        |229 |
|5 |     MERGE GROUP BY            |        |1        |228 |
|6 |      SORT                     |        |1        |228 |
|7 |       SUBPLAN SCAN            |VIEW1   |1        |228 |
|8 |        WINDOW FUNCTION        |        |1        |228 |
|9 |         PX PARTITION ITERATOR |        |1        |228 |
|10|          TABLE SCAN           |t1      |1        |228 |
============================================================
=======
================================================================
|ID|OPERATOR                      |NAME         |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                |             |1        |2   |
|1 | EXCHANGE OUT DISTR           |:EX10001     |1        |2   |
|2 |  MERGE GROUP BY              |             |1        |1   |
|3 |   SORT                       |             |1        |1   |
|4 |    EXCHANGE IN DISTR         |             |1        |1   |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000     |1        |1   |
|6 |      SUBPLAN SCAN            |VIEW1        |1        |1   |
|7 |       WINDOW FUNCTION        |             |1        |1   |
|8 |        PX PARTITION ITERATOR |             |1        |1   |
|9 |         TABLE SCAN           |t1(idx_t1_c2)|1        |1   |
================================================================
>>>>>>> refine idnex scan cost

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(VIEW1.max(t1.c1))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(VIEW1.max(t1.c1))]), filter(nil), dop=1
  2 - output([VIEW1.max(t1.c1)]), filter(nil), 
      group([VIEW1.max(t1.c1)]), agg_func(nil)
  3 - output([VIEW1.max(t1.c1)]), filter(nil), sort_keys([VIEW1.max(t1.c1), ASC])
  4 - (#keys=1, [VIEW1.max(t1.c1)]), output([VIEW1.max(t1.c1)]), filter(nil), dop=1
  5 - output([VIEW1.max(t1.c1)]), filter(nil), 
      group([VIEW1.max(t1.c1)]), agg_func(nil)
  6 - output([VIEW1.max(t1.c1)]), filter(nil), sort_keys([VIEW1.max(t1.c1), ASC])
  7 - output([VIEW1.max(t1.c1)]), filter(nil), 
      access([VIEW1.max(t1.c1)])
  8 - output([T_FUN_MAX(t1.c1)], [t1.c1]), filter(nil), 
      win_expr(T_FUN_MAX(t1.c1)), partition_by(nil), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
  9 - output([t1.c1]), filter(nil), 
      force partition granule.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 229(end)  ************** 

***************   Case 230   ***************

SQL: ( SELECT * FROM t12 WHERE 69 > ROUND ( 3075 ) ) UNION ALL ( SELECT * FROM t12  ) UNION ( SELECT * FROM t13) ; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |91  |
|1 | TABLE SCAN         |t12 |1        |46  |
|2 | SORT               |    |1        |46  |
|3 |  TABLE SCAN        |t13 |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  1 - output([t12.a], [t12.b], [t12.c]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  2 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), sort_keys([t13.b, ASC], [cast(t13.c, CHAR(20)), ASC], [t13.a, ASC])
  3 - output([t13.a], [t13.b], [t13.c]), filter(nil), 
      access([t13.a], [t13.b], [t13.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 230(end)  ************** 

***************   Case 231   ***************

SQL: select t1.c1, nvl(t2.c2,0) from (select c1,c2 from t1 where c1=0 or c1=1) as t1 left join (select c1,c2 from t1 where c1=0) as t2 on t1.c1=t2.c1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |        |2        |101 |
|1 | PX COORDINATOR         |        |2        |92  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|2        |92  |
|3 |   PX PARTITION ITERATOR|        |2        |92  |
|4 |    TABLE GET           |t1      |2        |92  |
|5 | TABLE GET              |t1      |1        |4   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [nvl(cast(t1.c2, BIGINT(1, 0)), ?)]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=true
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t1.c1]), range[0 ; 0], [1 ; 1], 
      range_cond([t1.c1 = ? OR t1.c1 = ?])
  5 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?], [? = t1.c1])

*************** Case 231(end)  ************** 

***************   Case 232   ***************

SQL: (select * from t12 where a != 1 limit 7 ) union (select * from t13) union ( select * from t13); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE DISTINCT|    |1        |137 |
|1 | SORT         |    |3        |137 |
|2 |  UNION ALL   |    |3        |137 |
|3 |   TABLE SCAN |t12 |1        |46  |
|4 |   TABLE SCAN |t13 |1        |46  |
|5 |   TABLE SCAN |t13 |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), 
      distinct([UNION([1])], [UNION([2])], [UNION([3])])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), sort_keys([UNION([1]), ASC], [UNION([2]), ASC], [UNION([3]), ASC])
  2 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  3 - output([cast(t12.a, CHAR(20))], [t12.b], [t12.c]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      limit(7), offset(nil), 
      is_index_back=false, 
      range_key([t12.a]), range(NULL ; 1), (1 ; MAX), 
      range_cond([t12.a != ?])
  4 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), 
      access([t13.a], [t13.b], [t13.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true
  5 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), 
      access([t13.a], [t13.b], [t13.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 232(end)  ************** 

***************   Case 233   ***************

SQL: select /*+ leading(t3, t2, t1) use_merge(t3,t2) */* from t1,t2,t3; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |             |1        |230 |
|1 | NESTED-LOOP JOIN CARTESIAN|             |1        |230 |
|2 |  PX COORDINATOR           |             |1        |92  |
|3 |   EXCHANGE OUT DISTR      |:EX10000     |1        |92  |
|4 |    PX PARTITION ITERATOR  |             |1        |92  |
|5 |     TABLE SCAN            |t3           |1        |92  |
|6 |  MATERIAL                 |             |1        |138 |
|7 |   PX COORDINATOR          |             |1        |138 |
|8 |    EXCHANGE OUT DISTR     |:EX20000     |1        |138 |
|9 |     PX PARTITION ITERATOR |             |1        |137 |
|10|      TABLE SCAN           |t2           |1        |137 |
|11| MATERIAL                  |             |1        |1   |
|12|  PX COORDINATOR           |             |1        |1   |
|13|   EXCHANGE OUT DISTR      |:EX30000     |1        |1   |
|14|    PX PARTITION ITERATOR  |             |1        |1   |
|15|     TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t1.c1], [t1.c2]), filter(nil)
  12 - output([t1.c1], [t1.c2]), filter(nil)
  13 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 233(end)  ************** 

***************   Case 234   ***************

SQL: select /*+leading(t10, t11) use_nl(t11) */ * from t10 join t11 on t10.c2 = t11.c2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |184 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |184 |
|2 |  PX PARTITION ITERATOR|        |1        |183 |
|3 |   NESTED-LOOP JOIN    |        |1        |183 |
|4 |    TABLE SCAN         |t10     |1        |92  |
|5 |    MATERIAL           |        |1        |92  |
|6 |     TABLE SCAN        |t11     |1        |92  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t10.c1, t10.c2, t10.c3, t11.c1, t11.c2, t11.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t10.c1, t10.c2, t10.c3, t11.c1, t11.c2, t11.c3)]), filter(nil), dop=1
  2 - output([t10.c2], [t11.c2], [t10.c1], [t10.c3], [t11.c1], [t11.c3]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t10.c2], [t11.c2], [t10.c1], [t10.c3], [t11.c1], [t11.c3]), filter(nil), 
      conds([t10.c2 = t11.c2]), nl_params_(nil), batch_join=false
  4 - output([t10.c1], [t10.c2], [t10.c3]), filter(nil), 
      access([t10.c1], [t10.c2], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t11.c2], [t11.c1], [t11.c3]), filter(nil)
  6 - output([t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      access([t11.c1], [t11.c2], [t11.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 234(end)  ************** 

***************   Case 235   ***************

SQL: select * from t4 where c1 not in (select c1 from t7 where t4.c1+t7.c1 >(select c1 from t8)); 

====================================================
|ID|OPERATOR       |NAME            |EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER |                |1        |91  |
|1 | TABLE SCAN    |t4(idx_t4_c2_c3)|1        |1   |
|2 | SUBPLAN FILTER|                |1        |91  |
|3 |  TABLE SCAN   |t7              |1        |46  |
|4 |  TABLE SCAN   |t8              |1        |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 != ALL(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter([? + t7.c1 > ?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 235(end)  ************** 

***************   Case 236   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where t7.c1>(select c1 from t8)); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |MERGE ANTI JOIN |     |1        |137 |
|1 | TABLE SCAN     |t4   |1        |46  |
|2 | SUBPLAN SCAN   |VIEW1|1        |91  |
|3 |  SUBPLAN FILTER|     |1        |91  |
|4 |   TABLE SCAN   |t7   |1        |46  |
|5 |   TABLE SCAN   |t8   |1        |46  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 > ?])
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 236(end)  ************** 

***************   Case 237   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where t4.c1>(select c1 from t8)); 

=================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST|
-------------------------------------------------
|0 |SUBPLAN FILTER |             |1        |91  |
|1 | TABLE SCAN    |t4(idx_t4_c2)|1        |1   |
|2 | SUBPLAN FILTER|             |1        |91  |
|3 |  TABLE SCAN   |t7           |1        |46  |
|4 |  TABLE SCAN   |t8           |1        |46  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter([t4.c1 != ALL(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), startup_filter([?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 237(end)  ************** 

***************   Case 238   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where 1>(select c1 from t8)); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |MERGE ANTI JOIN |     |1        |137 |
|1 | TABLE SCAN     |t4   |1        |46  |
|2 | SUBPLAN SCAN   |VIEW1|1        |91  |
|3 |  SUBPLAN FILTER|     |1        |91  |
|4 |   TABLE SCAN   |t7   |1        |46  |
|5 |   TABLE SCAN   |t8   |1        |46  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1]), filter(nil), startup_filter([?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 238(end)  ************** 

***************   Case 239   ***************

SQL: select c1 from t7 where c1 <>ALL (select c1 from t8 where 1>(select 2)); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |MERGE ANTI JOIN|     |1        |91  |
|1 | TABLE SCAN    |t7   |1        |46  |
|2 | SUBPLAN SCAN  |VIEW1|1        |46  |
|3 |  TABLE SCAN   |t8   |1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      equal_conds([t7.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c1]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1])
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 239(end)  ************** 

***************   Case 240   ***************

SQL: select c1 from t4 where c1 in (select c1 from t7 where t4.c1>(select c1 from t8)); 

=================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST|
-------------------------------------------------
|0 |SUBPLAN FILTER |             |1        |91  |
|1 | TABLE SCAN    |t4(idx_t4_c2)|1        |1   |
|2 | SUBPLAN FILTER|             |1        |91  |
|3 |  TABLE SCAN   |t7           |1        |46  |
|4 |  TABLE SCAN   |t8           |1        |46  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter([t4.c1 = ANY(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), startup_filter([?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 240(end)  ************** 

***************   Case 241   ***************

SQL: select * from t7 where c1 not in (select 1 from t8 where t8.c1 >1); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |92  |
|1 | TABLE SCAN          |t7   |1        |46  |
|2 | MATERIAL            |     |1        |46  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |46  |
|4 |   TABLE SCAN        |t8   |1        |46  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 = ?]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), 
      access(nil)
  4 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 241(end)  ************** 

***************   Case 242   ***************

SQL: select * from t7 where c1 not in (select t7.c1 from t8 where t8.c1 >1); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |92  |
|1 | TABLE SCAN          |t7   |1        |46  |
|2 | MATERIAL            |     |1        |46  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |46  |
|4 |   TABLE SCAN        |t8   |1        |46  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 = t7.c1 OR (T_OP_IS, t7.c1, NULL, 0)]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), 
      access(nil)
  4 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 242(end)  ************** 

***************   Case 243   ***************

SQL: select * from t7 where c1 not in (select (select c1 from t1) from t8 where t8.c1 >1); 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SUBPLAN FILTER           |             |1        |92  |
|1 | TABLE SCAN              |t7           |1        |46  |
|2 | SUBPLAN FILTER          |             |1        |46  |
|3 |  TABLE SCAN             |t8           |1        |46  |
|4 |  PX COORDINATOR         |             |1        |1   |
|5 |   EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|6 |    PX PARTITION ITERATOR|             |1        |1   |
|7 |     TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([t7.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 243(end)  ************** 

***************   Case 244   ***************

SQL: select * from t7 where c1 in (select t8.c1 from t8 where t8.c1 >1); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |51  |
|1 | TABLE SCAN     |t7  |1        |46  |
|2 | TABLE GET      |t8  |1        |5   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(1 ; MAX), 
      range_cond([t7.c1 > ?])
  2 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([t8.c1 > ?], [? = t8.c1])

*************** Case 244(end)  ************** 

***************   Case 245   ***************

SQL: select * from t7 where c1 in (select 1 from t8 where t8.c1 >t7.c1); 

====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |1        |92  |
|1 | SUBPLAN SCAN             |VIEW1|1        |46  |
|2 |  TABLE SCAN              |t8   |1        |46  |
|3 | MATERIAL                 |     |1        |46  |
|4 |  TABLE GET               |t7   |1        |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])
  3 - output([t7.c1], [t7.c2]), filter(nil)
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[1 ; 1], 
      range_cond([t7.c1 = ?])

*************** Case 245(end)  ************** 

***************   Case 246   ***************

SQL: select * from t7 where c1 in (select 1 from t8 where t8.c1 >1); 

====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |1        |92  |
|1 | SUBPLAN SCAN             |VIEW1|1        |46  |
|2 |  TABLE SCAN              |t8   |1        |46  |
|3 | MATERIAL                 |     |1        |46  |
|4 |  TABLE GET               |t7   |1        |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])
  3 - output([t7.c1], [t7.c2]), filter(nil)
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[1 ; 1], 
      range_cond([t7.c1 = ?])

*************** Case 246(end)  ************** 

***************   Case 247   ***************

SQL: select * from t1 where c1 = 1 and c2 in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 247(end)  ************** 

***************   Case 248   ***************

SQL: select * from t1 partition(p1)  where c2 =1 or c2 = 2; 

======================================================
|ID|OPERATOR            |NAME         |EST. ROWS|COST|
------------------------------------------------------
|0 |EXCHANGE IN REMOTE  |             |1        |1   |
|1 | EXCHANGE OUT REMOTE|             |1        |1   |
|2 |  TABLE SCAN        |t1(idx_t1_c2)|1        |1   |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MIN ; 1,MAX), (2,MIN ; 2,MAX), 
      range_cond([t1.c2 = ? OR t1.c2 = ?])

*************** Case 248(end)  ************** 

***************   Case 249   ***************

SQL: select * from t14 partition(p1) where (c1, c2) =(1, 2) or (c1, c2) = (2, 3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE SCAN        |t14 |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  2 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      access([t14.c1], [t14.c2], [t14.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(1,2,MIN ; 1,2,MAX), (2,3,MIN ; 2,3,MAX), 
      range_cond([(t14.c1, t14.c2) = (?, ?) OR (t14.c1, t14.c2) = (?, ?)])

*************** Case 249(end)  ************** 

***************   Case 250   ***************

SQL: select/*+index(t14 primary)*/* from t14  partition(p1) where (c1, c2) =(1, 2) or (c1, c2) = (2, 3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE SCAN        |t14 |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  2 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      access([t14.c1], [t14.c2], [t14.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(1,2,MIN ; 1,2,MAX), (2,3,MIN ; 2,3,MAX), 
      range_cond([(t14.c1, t14.c2) = (?, ?) OR (t14.c1, t14.c2) = (?, ?)])

*************** Case 250(end)  ************** 

***************   Case 251   ***************

SQL: select c1 from t1 where (1, 2) in (select t1.c1, t2.c1 from t2); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |141 |
|1 | PX COORDINATOR           |        |1        |46  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t1      |1        |46  |
|4 | PX COORDINATOR           |        |1        |46  |
|5 |  EXCHANGE OUT DISTR      |:EX20000|1        |46  |
|6 |   TABLE GET              |t2      |1        |46  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), is_single, dop=1
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([? = t1.c1])
  4 - output(nil), filter(nil)
  5 - output(nil), filter(nil), is_single, dop=1
  6 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])

*************** Case 251(end)  ************** 

***************   Case 252   ***************

SQL: select c1 from t1 where (1, 2) in (select t2.c1, t2.c2 from t2 where t1.c1); 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|             |1        |46  |
|1 | PX COORDINATOR           |             |1        |1   |
|2 |  EXCHANGE OUT DISTR      |:EX10000     |1        |1   |
|3 |   PX PARTITION ITERATOR  |             |1        |1   |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
|5 | MATERIAL                 |             |1        |46  |
|6 |  PX COORDINATOR          |             |1        |46  |
|7 |   EXCHANGE OUT DISTR     |:EX20000     |1        |46  |
|8 |    TABLE GET             |t2           |1        |46  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter([t1.c1]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  5 - output(nil), filter(nil)
  6 - output(nil), filter(nil)
  7 - output(nil), filter(nil), is_single, dop=1
  8 - output(nil), filter([t2.c2 = ?]), 
      access([t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])

*************** Case 252(end)  ************** 

***************   Case 253   ***************

SQL: select c1 from t1 where (1, 2) in (select distinct t1.c1, t1.c2 from t2 where t1.c1); 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |1        |183 |
|1 | SUBPLAN SCAN              |VIEW1   |1        |137 |
|2 |  LIMIT                    |        |1        |137 |
|3 |   PX COORDINATOR          |        |1        |137 |
|4 |    EXCHANGE OUT DISTR     |:EX10000|1        |137 |
|5 |     LIMIT                 |        |1        |137 |
|6 |      PX PARTITION ITERATOR|        |1        |137 |
|7 |       TABLE SCAN          |t2      |1        |137 |
|8 | MATERIAL                  |        |1        |46  |
|9 |  PX COORDINATOR           |        |1        |46  |
|10|   EXCHANGE OUT DISTR      |:EX20000|1        |46  |
|11|    TABLE GET              |t1      |1        |46  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), dop=1
  5 - output(nil), filter(nil), limit(1), offset(nil)
  6 - output(nil), filter(nil), 
      force partition granule.
  7 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), is_single, dop=1
  11 - output([t1.c1]), filter([? = t1.c2]), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([? = t1.c1])

*************** Case 253(end)  ************** 

***************   Case 254   ***************

SQL: select c2 from t1 where exists (select * from t2 where t1.c1 and t1.c2 limit 1); 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |             |1        |137 |
|1 | SUBPLAN SCAN              |VIEW1        |1        |137 |
|2 |  LIMIT                    |             |1        |137 |
|3 |   PX COORDINATOR          |             |1        |137 |
|4 |    EXCHANGE OUT DISTR     |:EX10000     |1        |137 |
|5 |     LIMIT                 |             |1        |137 |
|6 |      PX PARTITION ITERATOR|             |1        |137 |
|7 |       TABLE SCAN          |t2           |1        |137 |
|8 | MATERIAL                  |             |1        |1   |
|9 |  PX COORDINATOR           |             |1        |1   |
|10|   EXCHANGE OUT DISTR      |:EX20000     |1        |1   |
|11|    PX PARTITION ITERATOR  |             |1        |1   |
|12|     TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), dop=1
  5 - output(nil), filter(nil), limit(1), offset(nil)
  6 - output(nil), filter(nil), 
      force partition granule.
  7 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  8 - output([t1.c2]), filter(nil)
  9 - output([t1.c2]), filter(nil)
  10 - output([t1.c2]), filter(nil), dop=1
  11 - output([t1.c2]), filter(nil), 
      force partition granule.
  12 - output([t1.c2]), filter([t1.c1], [t1.c2]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 254(end)  ************** 

***************   Case 255   ***************

SQL: select * from t4 where c1 in (select t7.c1 from t7 left join t8 on t7.c1<=t8.c1 where (t7.c1,t4.c1) in (select c1,c2 from t9)); 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN |    |1        |57  |
|1 | NESTED-LOOP JOIN|    |1        |51  |
|2 |  TABLE SCAN     |t9  |1        |46  |
|3 |  TABLE SCAN     |t4  |1        |5   |
|4 | TABLE GET       |t7  |1        |5   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=true
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t9.c2]), batch_join=true
  2 - output([t9.c2]), filter([t9.c2 = t9.c1]), 
      access([t9.c1], [t9.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t9.c1]), range(MIN ; MAX)always true
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN ; MAX), 
      range_cond([? = t4.c1])
  4 - output(nil), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([? = t7.c1])

*************** Case 255(end)  ************** 

***************   Case 256   ***************

SQL: select * from t7 where 1 in (select c1 from t8 where t7.c1); 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |91  |
|1 | TABLE SCAN               |t7  |1        |46  |
|2 | MATERIAL                 |    |1        |46  |
|3 |  TABLE GET               |t8  |1        |46  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter([t7.c1]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[1 ; 1], 
      range_cond([t8.c1 = ?])

*************** Case 256(end)  ************** 

***************   Case 257   ***************

SQL: select * from t7 where 1 not in (select 2 from t8 where t7.c1=t8.c1); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |MERGE ANTI JOIN|     |1        |91  |
|1 | TABLE SCAN    |t7   |1        |46  |
|2 | SUBPLAN SCAN  |VIEW1|1        |46  |
|3 |  TABLE SCAN   |t8   |1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c1 = VIEW1.t8.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.t8.c1]), filter(nil), startup_filter([0]), 
      access([VIEW1.t8.c1])
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 257(end)  ************** 

***************   Case 258   ***************

SQL: select * from t4 where (select c1 from t7)+1 in (select 2 from t8 where t4.c1=t8.c1); 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |1        |97  |
|1 | NESTED-LOOP JOIN|    |1        |51  |
|2 |  TABLE SCAN     |t4  |1        |46  |
|3 |  TABLE GET      |t8  |1        |5   |
|4 | TABLE SCAN      |t7  |1        |46  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1) + ? = ?]), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([?]), 
      conds(nil), nl_params_([t4.c1]), batch_join=true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  3 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 258(end)  ************** 

***************   Case 259   ***************

SQL: select sum(c1)+sum(c2), sum(c1) from t1 group by c2 having sum(c1) > 5; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
<<<<<<< HEAD
|0 |PX COORDINATOR                 |             |1        |229 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |229 |
|2 |  MERGE GROUP BY               |             |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|5 |     PX PARTITION ITERATOR     |             |1        |228 |
|6 |      MERGE GROUP BY           |             |1        |228 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |PX COORDINATOR                 |             |1        |1   |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |1   |
|2 |  MERGE GROUP BY               |             |1        |1   |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR     |             |1        |1   |
|6 |      TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)) + T_FUN_SUM(T_FUN_SUM(t1.c2)), T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)) + T_FUN_SUM(T_FUN_SUM(t1.c2)), T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c2))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c2))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 259(end)  ************** 

***************   Case 260   ***************

SQL: select sum(c1), c2, count(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
<<<<<<< HEAD
|0 |PX COORDINATOR                 |             |1        |228 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |228 |
|2 |  MERGE GROUP BY               |             |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|5 |     PX PARTITION ITERATOR     |             |1        |228 |
|6 |      MERGE GROUP BY           |             |1        |228 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |PX COORDINATOR                 |             |1        |1   |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |1   |
|2 |  MERGE GROUP BY               |             |1        |1   |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR     |             |1        |1   |
|6 |      TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 260(end)  ************** 

***************   Case 261   ***************

SQL: select distinct sum(c1) from t1 group by c2 having sum(c1) > 5; 

<<<<<<< HEAD
======================================================================
|ID|OPERATOR                            |NAME         |EST. ROWS|COST|
----------------------------------------------------------------------
|0 |PX COORDINATOR                      |             |1        |228 |
|1 | EXCHANGE OUT DISTR                 |:EX10002     |1        |228 |
|2 |  MERGE DISTINCT                    |             |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR     |             |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)       |:EX10001     |1        |228 |
|5 |     MERGE DISTINCT                 |             |1        |228 |
|6 |      SORT                          |             |1        |228 |
|7 |       MERGE GROUP BY               |             |1        |228 |
|8 |        EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|9 |         EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|10|          PX PARTITION ITERATOR     |             |1        |228 |
|11|           MERGE GROUP BY           |             |1        |228 |
|12|            TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      distinct([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), sort_keys([T_FUN_SUM(T_FUN_SUM(t1.c1)), ASC])
  4 - (#keys=1, [T_FUN_SUM(T_FUN_SUM(t1.c1))]), output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), dop=1
  5 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      distinct([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  6 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), sort_keys([T_FUN_SUM(T_FUN_SUM(t1.c1)), ASC])
  7 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  8 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  9 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), dop=1
  10 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule.
  11 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
=======
=====================================================================
|ID|OPERATOR                           |NAME         |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |PX COORDINATOR                     |             |1        |1   |
|1 | EXCHANGE OUT DISTR                |:EX10002     |1        |1   |
|2 |  MERGE DISTINCT                   |             |1        |1   |
|3 |   SORT                            |             |1        |1   |
|4 |    EXCHANGE IN DISTR              |             |1        |1   |
|5 |     EXCHANGE OUT DISTR (HASH)     |:EX10001     |1        |1   |
|6 |      MERGE GROUP BY               |             |1        |1   |
|7 |       EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|8 |        EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|9 |         PX PARTITION ITERATOR     |             |1        |1   |
|10|          TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(t1.c1))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(t1.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      distinct([T_FUN_SUM(t1.c1)])
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([T_FUN_SUM(t1.c1), ASC])
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  5 - (#keys=1, [T_FUN_SUM(t1.c1)]), output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  6 - output([T_FUN_SUM(t1.c1)]), filter([T_FUN_SUM(t1.c1) > ?]), 
>>>>>>> refine idnex scan cost
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 261(end)  ************** 

***************   Case 262   ***************

SQL: select distinct sum(c1), c2, count(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
<<<<<<< HEAD
|0 |PX COORDINATOR                 |             |1        |228 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |228 |
|2 |  MERGE GROUP BY               |             |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|5 |     PX PARTITION ITERATOR     |             |1        |228 |
|6 |      MERGE GROUP BY           |             |1        |228 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |PX COORDINATOR                 |             |1        |1   |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |1   |
|2 |  MERGE GROUP BY               |             |1        |1   |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR     |             |1        |1   |
|6 |      TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 262(end)  ************** 

***************   Case 263   ***************

SQL: select distinct sum(c1), c2, count(c1), avg(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
<<<<<<< HEAD
|0 |PX COORDINATOR                 |             |1        |228 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |228 |
|2 |  MERGE GROUP BY               |             |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|5 |     PX PARTITION ITERATOR     |             |1        |228 |
|6 |      MERGE GROUP BY           |             |1        |228 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |PX COORDINATOR                 |             |1        |1   |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |1   |
|2 |  MERGE GROUP BY               |             |1        |1   |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR     |             |1        |1   |
|6 |      TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 263(end)  ************** 

***************   Case 264   ***************

SQL: select * from t1, t2 where t1.c1 > any(select t3.c2 from t2,t3 where t2.c1 > any(select t4.c1 from t4,t5 where exists (select c1 from t2 ))); 

====================================================================
|ID|OPERATOR                          |NAME         |EST. ROWS|COST|
--------------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN        |             |1        |599 |
|1 | NESTED-LOOP SEMI JOIN            |             |1        |461 |
|2 |  PX COORDINATOR                  |             |1        |1   |
|3 |   EXCHANGE OUT DISTR             |:EX10000     |1        |1   |
|4 |    PX PARTITION ITERATOR         |             |1        |1   |
|5 |     TABLE SCAN                   |t1(idx_t1_c2)|1        |1   |
|6 |  MATERIAL                        |             |1        |461 |
|7 |   SUBPLAN SCAN                   |VIEW2        |1        |461 |
|8 |    NESTED-LOOP JOIN CARTESIAN    |             |1        |461 |
|9 |     NESTED-LOOP SEMI JOIN        |             |1        |369 |
|10|      PX COORDINATOR              |             |1        |137 |
|11|       EXCHANGE OUT DISTR         |:EX20000     |1        |137 |
|12|        PX PARTITION ITERATOR     |             |1        |137 |
|13|         TABLE SCAN               |t2           |1        |137 |
|14|      SUBPLAN SCAN                |VIEW1        |1        |183 |
|15|       SUBPLAN FILTER             |             |1        |183 |
|16|        NESTED-LOOP JOIN CARTESIAN|             |1        |46  |
|17|         TABLE SCAN               |t4           |1        |46  |
|18|         MATERIAL                 |             |1        |1   |
|19|          PX COORDINATOR          |             |1        |1   |
|20|           EXCHANGE OUT DISTR     |:EX30000     |1        |1   |
|21|            PX PARTITION ITERATOR |             |1        |1   |
|22|             TABLE SCAN           |t5(idx_t5_c2)|1        |1   |
|23|        LIMIT                     |             |1        |137 |
|24|         PX COORDINATOR           |             |1        |137 |
|25|          EXCHANGE OUT DISTR      |:EX40000     |1        |137 |
|26|           LIMIT                  |             |1        |137 |
|27|            PX PARTITION ITERATOR |             |1        |137 |
|28|             TABLE SCAN           |t2           |1        |137 |
|29|     MATERIAL                     |             |1        |92  |
|30|      PX COORDINATOR              |             |1        |92  |
|31|       EXCHANGE OUT DISTR         |:EX50000     |1        |92  |
|32|        PX PARTITION ITERATOR     |             |1        |92  |
|33|         TABLE SCAN               |t3           |1        |92  |
|34| MATERIAL                         |             |1        |138 |
|35|  PX COORDINATOR                  |             |1        |138 |
|36|   EXCHANGE OUT DISTR             |:EX60000     |1        |138 |
|37|    PX PARTITION ITERATOR         |             |1        |137 |
|38|     TABLE SCAN                   |t2           |1        |137 |
====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > VIEW2.c2]), nl_params_(nil), batch_join=false
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([VIEW2.c2]), filter(nil)
  7 - output([VIEW2.c2]), filter(nil), 
      access([VIEW2.c2])
  8 - output([t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  9 - output(nil), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), dop=1
  12 - output([t2.c1]), filter(nil), 
      force partition granule.
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  14 - output(nil), filter(nil), 
      access(nil)
  15 - output([t4.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  16 - output([t4.c1]), filter(nil), startup_filter([?]), 
      conds(nil), nl_params_(nil), batch_join=false
  17 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true, 
      range_cond([? > t4.c1])
  18 - output(nil), filter(nil)
  19 - output(nil), filter(nil)
  20 - output(nil), filter(nil), dop=1
  21 - output(nil), filter(nil), 
      force partition granule.
  22 - output(nil), filter(nil), 
      access([t5.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  23 - output([1]), filter(nil), limit(1), offset(nil)
  24 - output(nil), filter(nil)
  25 - output(nil), filter(nil), dop=1
  26 - output(nil), filter(nil), limit(1), offset(nil)
  27 - output(nil), filter(nil), 
      force partition granule.
  28 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  29 - output([t3.c2]), filter(nil)
  30 - output([t3.c2]), filter(nil)
  31 - output([t3.c2]), filter(nil), dop=1
  32 - output([t3.c2]), filter(nil), 
      force partition granule.
  33 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  34 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  35 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  36 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  37 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  38 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 264(end)  ************** 

***************   Case 265   ***************

SQL: select * from t4,t4 t5 where t4.c1+t5.c1 in (select t7.c1 from t7,t8); 

=================================================================
|ID|OPERATOR                    |NAME            |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |MERGE SEMI JOIN             |                |1        |92  |
|1 | SORT                       |                |1        |1   |
|2 |  NESTED-LOOP JOIN CARTESIAN|                |1        |1   |
|3 |   TABLE SCAN               |t4(idx_t4_c2_c3)|1        |1   |
|4 |   MATERIAL                 |                |1        |1   |
|5 |    TABLE SCAN              |t5(idx_t4_c2_c3)|1        |1   |
|6 | SUBPLAN SCAN               |VIEW1           |1        |92  |
|7 |  NESTED-LOOP JOIN CARTESIAN|                |1        |92  |
|8 |   TABLE SCAN               |t7              |1        |46  |
|9 |   MATERIAL                 |                |1        |46  |
|10|    TABLE SCAN              |t8              |1        |46  |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t4.c1 + t5.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t4.c1 + t5.c1]), filter(nil), sort_keys([t4.c1 + t5.c1, ASC])
  2 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  4 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  5 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3], [t5.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  6 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  7 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  8 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  9 - output(nil), filter(nil)
  10 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 265(end)  ************** 

***************   Case 266   ***************

SQL: select * from t4,t4 t5 where t4.c1 in (select t7.c1 from t7,t8); 

===================================================================
|ID|OPERATOR                      |NAME            |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN    |                |1        |97  |
|1 | NESTED-LOOP JOIN             |                |1        |97  |
|2 |  SUBPLAN SCAN                |VIEW2           |1        |92  |
|3 |   MERGE DISTINCT             |                |1        |92  |
|4 |    NESTED-LOOP JOIN CARTESIAN|                |1        |92  |
|5 |     TABLE SCAN               |t7              |1        |46  |
|6 |     MATERIAL                 |                |1        |46  |
|7 |      TABLE SCAN              |t8              |1        |46  |
|8 |  TABLE SCAN                  |t4              |1        |5   |
|9 | MATERIAL                     |                |1        |1   |
|10|  TABLE SCAN                  |t5(idx_t4_c2_c3)|1        |1   |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1]), batch_join=true
  2 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  3 - output([t7.c1]), filter(nil), 
      distinct([t7.c1])
  4 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  5 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  6 - output(nil), filter(nil)
  7 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  8 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN ; MAX), 
      range_cond([t4.c1 = ?])
  9 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  10 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3], [t5.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 266(end)  ************** 

***************   Case 267   ***************

SQL: select * from t4,t4 t5 where t4.c1+t5.c1 in (select t7.c1 from t7,t8 where t7.c1=t8.c1); 

=================================================================
|ID|OPERATOR                    |NAME            |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |NESTED-LOOP JOIN            |                |1        |12  |
|1 | NESTED-LOOP JOIN           |                |1        |6   |
|2 |  NESTED-LOOP JOIN CARTESIAN|                |1        |1   |
|3 |   TABLE SCAN               |t4(idx_t4_c2_c3)|1        |1   |
|4 |   MATERIAL                 |                |1        |1   |
|5 |    TABLE SCAN              |t5(idx_t4_c2_c3)|1        |1   |
|6 |  TABLE GET                 |t7              |1        |5   |
|7 | TABLE GET                  |t8              |1        |5   |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  1 - output([t7.c1], [t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1 + t5.c1]), batch_join=true
  2 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  4 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  5 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3], [t5.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  6 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([? = t7.c1])
  7 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])

*************** Case 267(end)  ************** 

***************   Case 268   ***************

SQL: select count(*) v from t1 where c2 = 1; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SCALAR GROUP BY          |             |1        |1   |
|1 | PX COORDINATOR          |             |1        |1   |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |1   |
|3 |   MERGE GROUP BY        |             |1        |1   |
|4 |    PX PARTITION ITERATOR|             |1        |1   |
|5 |     TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MIN ; 1,MAX), 
      range_cond([t1.c2 = ?])

*************** Case 268(end)  ************** 

***************   Case 269   ***************

SQL: select count(*) v, sum(c1) as v2 from t1 where c1 > 0; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |228 |
|1 | PX COORDINATOR          |        |1        |228 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |228 |
|3 |   MERGE GROUP BY        |        |1        |228 |
|4 |    PX PARTITION ITERATOR|        |1        |228 |
|5 |     TABLE SCAN          |t1      |1        |228 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [T_FUN_SUM(T_FUN_SUM(t1.c1))])
  1 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 269(end)  ************** 

***************   Case 270   ***************

SQL: select distinct sum(c1), c2, count(c1), avg(c1) as alias from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1 and alias > 100; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
<<<<<<< HEAD
|0 |PX COORDINATOR                 |             |1        |228 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |228 |
|2 |  MERGE GROUP BY               |             |1        |228 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |228 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |228 |
|5 |     PX PARTITION ITERATOR     |             |1        |228 |
|6 |      MERGE GROUP BY           |             |1        |228 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|1        |228 |
=======
|0 |PX COORDINATOR                 |             |1        |1   |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |1   |
|2 |  MERGE GROUP BY               |             |1        |1   |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |1        |1   |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |1        |1   |
|5 |     PX PARTITION ITERATOR     |             |1        |1   |
|6 |      TABLE SCAN               |t1(idx_t1_c2)|1        |1   |
>>>>>>> refine idnex scan cost
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 270(end)  ************** 

***************   Case 271   ***************

SQL: select 1 from t15; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |183 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |183 |
|2 |  PX PARTITION ITERATOR|        |1        |182 |
|3 |   TABLE SCAN          |t15     |1        |182 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(?)]), filter(nil), dop=1
  2 - output(nil), filter(nil), 
      force partition granule.
  3 - output(nil), filter(nil), 
      access([t15.__pk_increment]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 271(end)  ************** 

***************   Case 272   ***************

SQL: select c1 from t15 where false; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |183 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |183 |
|2 |  PX PARTITION ITERATOR|        |1        |182 |
|3 |   TABLE SCAN          |t15     |1        |182 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t15.c1)]), filter(nil), startup_filter([0])
  1 - output([INTERNAL_FUNCTION(t15.c1)]), filter(nil), dop=1
  2 - output([t15.c1]), filter(nil), 
      force partition granule.
  3 - output([t15.c1]), filter(nil), 
      access([t15.c1]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 272(end)  ************** 

***************   Case 273   ***************

SQL: select count(1) from t15 where false; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |183 |
|1 | PX COORDINATOR          |        |1        |183 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |183 |
|3 |   MERGE GROUP BY        |        |1        |182 |
|4 |    PX PARTITION ITERATOR|        |1        |182 |
|5 |     TABLE SCAN          |t15     |1        |182 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)]), filter(nil), startup_filter([0])
  2 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t15.__pk_increment]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 273(end)  ************** 

***************   Case 274   ***************

SQL: select * from t1 order by c2,c1,c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |1        |1   |
|1 | EXCHANGE OUT DISTR       |:EX10000     |1        |1   |
|2 |  SORT                    |             |1        |1   |
|3 |   PX PARTITION ITERATOR  |             |1        |1   |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|1        |1   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), sort_keys([t1.c2, ASC], [t1.c1, ASC])
  1 - output([t1.c2], [t1.c1], [INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c2, ASC], [t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 274(end)  ************** 

***************   Case 275   ***************

SQL: select * from t1 left outer join t2 using(c1) order by t1.c1 desc, t2.c1; 

==============================================================
|ID|OPERATOR                      |NAME       |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |           |1        |236 |
|1 | EXCHANGE OUT DISTR           |:EX10001   |1        |236 |
|2 |  SORT                        |           |1        |235 |
|3 |   NESTED-LOOP OUTER JOIN     |           |1        |235 |
|4 |    EXCHANGE IN DISTR         |           |1        |228 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000   |1        |228 |
|6 |      PX PARTITION ITERATOR   |           |1        |228 |
|7 |       TABLE SCAN             |t1(Reverse)|1        |228 |
|8 |    PX PARTITION ITERATOR     |           |1        |18  |
|9 |     TABLE GET                |t2(Reverse)|1        |18  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c2, t2.c3)]), filter(nil), sort_keys([t1.c1, DESC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, DESC]), local merge sort
  3 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  4 - output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  5 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])

*************** Case 275(end)  ************** 

***************   Case 276   ***************

SQL: select count(*) from t1 left outer join t2 using(c1) group by (t1.c1) having count(*) > 1 order by t1.c1 desc, t2.c1; 

==============================================================
|ID|OPERATOR                      |NAME       |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |           |1        |235 |
|1 | EXCHANGE OUT DISTR           |:EX10001   |1        |235 |
|2 |  SORT                        |           |1        |235 |
|3 |   NESTED-LOOP OUTER JOIN     |           |1        |235 |
|4 |    EXCHANGE IN DISTR         |           |1        |228 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000   |1        |228 |
|6 |      PX PARTITION ITERATOR   |           |1        |228 |
|7 |       TABLE SCAN             |t1(Reverse)|1        |228 |
|8 |    PX PARTITION ITERATOR     |           |1        |18  |
|9 |     TABLE GET                |t2(Reverse)|1        |18  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(1)]), filter(nil), startup_filter([0]), sort_keys([t1.c1, DESC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC]), local merge sort
  3 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  4 - output([t1.c1], [PARTITION_ID]), filter(nil)
  5 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output(nil), filter(nil), 
      affinitize, force partition granule.
  9 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])

*************** Case 276(end)  ************** 

***************   Case 277   ***************

SQL: select now() from t1 left outer join t2 using(c1); 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |1        |1   |
|1 | EXCHANGE OUT DISTR    |:EX10000     |1        |1   |
|2 |  PX PARTITION ITERATOR|             |1        |1   |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|1        |1   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(?)]), filter(nil), dop=1
  2 - output(nil), filter(nil), 
      force partition granule.
  3 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 277(end)  ************** 

***************   Case 278   ***************

SQL: select a1.c2 from t1 left join t2 a1 on (a1.c1= t1.c1) where least(t1.c2, a1.c2) > 1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |144 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |144 |
|2 |  NESTED-LOOP JOIN           |        |1        |144 |
|3 |   EXCHANGE IN DISTR         |        |1        |137 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|5 |     PX PARTITION ITERATOR   |        |1        |137 |
|6 |      TABLE SCAN             |a1      |1        |137 |
|7 |   PX PARTITION ITERATOR     |        |1        |30  |
|8 |    TABLE GET                |t1      |1        |30  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(a1.c2)]), filter(nil), dop=1
  2 - output([a1.c2]), filter(nil), 
      conds(nil), nl_params_([a1.c2], [a1.c1]), batch_join=false
  3 - output([a1.c2], [PARTITION_ID], [a1.c1]), filter(nil)
  4 - (#keys=1, [a1.c1]), output([a1.c2], [PARTITION_ID], [a1.c1]), filter(nil), dop=1
  5 - output([a1.c1], [a1.c2]), filter(nil), 
      force partition granule.
  6 - output([a1.c1], [a1.c2]), filter(nil), 
      access([a1.c1], [a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX)always true
  7 - output(nil), filter(nil), 
      affinitize, force partition granule.
  8 - output(nil), filter([least(t1.c2, ?) > ?]), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([? = t1.c1])

*************** Case 278(end)  ************** 

***************   Case 279   ***************

SQL: select a1.c2 from t1 left join t2 a1 on (a1.c1= t1.c1) where length(t1.c2) > 1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |230 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |230 |
|2 |  NESTED-LOOP OUTER JOIN     |        |1        |230 |
|3 |   EXCHANGE IN DISTR         |        |1        |228 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |228 |
|5 |     PX PARTITION ITERATOR   |        |1        |228 |
|6 |      TABLE SCAN             |t1      |1        |228 |
|7 |   PX PARTITION ITERATOR     |        |1        |18  |
|8 |    TABLE GET                |a1      |1        |18  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(a1.c2)]), filter(nil), dop=1
  2 - output([a1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([PARTITION_ID], [t1.c1]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([PARTITION_ID], [t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule.
  6 - output([t1.c1]), filter([length(cast(t1.c2, VARCHAR(1048576))) > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([a1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([a1.c2]), filter(nil), 
      access([a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX), 
      range_cond([a1.c1 = ?])

*************** Case 279(end)  ************** 

***************   Case 280   ***************

SQL: select a2.c2, t1.c2, a1.c2 from t1  left join t2 a1 on (a1.c1 = t1.c1), t2 a2 where least(t1.c2, a1.c2) =a2.c2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |HASH JOIN                     |        |1        |282 |
|1 | PX COORDINATOR               |        |1        |137 |
|2 |  EXCHANGE OUT DISTR          |:EX10000|1        |137 |
|3 |   PX PARTITION ITERATOR      |        |1        |137 |
|4 |    TABLE SCAN                |a2      |1        |137 |
|5 | PX COORDINATOR               |        |1        |145 |
|6 |  EXCHANGE OUT DISTR          |:EX20001|1        |144 |
|7 |   NESTED-LOOP JOIN           |        |1        |144 |
|8 |    EXCHANGE IN DISTR         |        |1        |137 |
|9 |     EXCHANGE OUT DISTR (PKEY)|:EX20000|1        |137 |
|10|      PX PARTITION ITERATOR   |        |1        |137 |
|11|       TABLE SCAN             |a1      |1        |137 |
|12|    PX PARTITION ITERATOR     |        |1        |30  |
|13|     TABLE GET                |t1      |1        |30  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([a2.c2], [t1.c2], [a1.c2]), filter(nil), 
      equal_conds([least(t1.c2, a1.c2) = a2.c2]), other_conds(nil)
  1 - output([a2.c2]), filter(nil)
  2 - output([a2.c2]), filter(nil), dop=1
  3 - output([a2.c2]), filter(nil), 
      force partition granule.
  4 - output([a2.c2]), filter(nil), 
      access([a2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c2], [a1.c2]), filter(nil)
  6 - output([t1.c2], [a1.c2]), filter(nil), dop=1
  7 - output([t1.c2], [a1.c2]), filter(nil), 
      conds(nil), nl_params_([a1.c1]), batch_join=false
  8 - output([a1.c2], [PARTITION_ID], [a1.c1]), filter(nil)
  9 - (#keys=1, [a1.c1]), output([a1.c2], [PARTITION_ID], [a1.c1]), filter(nil), dop=1
  10 - output([a1.c1], [a1.c2]), filter(nil), 
      force partition granule.
  11 - output([a1.c1], [a1.c2]), filter(nil), 
      access([a1.c1], [a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX)always true
  12 - output([t1.c2]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([? = t1.c1])

*************** Case 280(end)  ************** 

***************   Case 281   ***************

SQL: select f_acc.c2, a1.c2, a2.c2 from t2 left join t2 f1 on (f1.c1 = 1 and t2.c3 = f1.c3) left join t3 a1 on (a1.c1 = f1.c1) left join t2 f2 on (f2.c1 = 3 and f2.c3=t2.c3) left join t3 a2 on (a2.c1 = f2.c1), t3 f_acc where least(a1.c2, a2.c2) = f_acc.c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH JOIN                    |        |1        |372 |
|1 | PX COORDINATOR              |        |1        |92  |
|2 |  EXCHANGE OUT DISTR         |:EX10000|1        |92  |
|3 |   PX PARTITION ITERATOR     |        |1        |92  |
|4 |    TABLE SCAN               |f_acc   |1        |92  |
|5 | NESTED-LOOP JOIN CARTESIAN  |        |1        |280 |
|6 |  MERGE JOIN                 |        |1        |234 |
|7 |   NESTED-LOOP JOIN CARTESIAN|        |1        |188 |
|8 |    NESTED-LOOP JOIN         |        |1        |142 |
|9 |     PX COORDINATOR          |        |1        |47  |
|10|      EXCHANGE OUT DISTR     |:EX20000|1        |46  |
|11|       TABLE GET             |f1      |1        |46  |
|12|     PX COORDINATOR          |        |1        |138 |
|13|      EXCHANGE OUT DISTR     |:EX30000|1        |137 |
|14|       PX PARTITION ITERATOR |        |1        |137 |
|15|        TABLE SCAN           |t2      |1        |137 |
|16|    MATERIAL                 |        |1        |46  |
|17|     PX COORDINATOR          |        |1        |46  |
|18|      EXCHANGE OUT DISTR     |:EX40000|1        |46  |
|19|       TABLE GET             |a1      |1        |46  |
|20|   TABLE GET                 |f2      |1        |46  |
|21|  MATERIAL                   |        |1        |46  |
|22|   PX COORDINATOR            |        |1        |46  |
|23|    EXCHANGE OUT DISTR       |:EX50000|1        |46  |
|24|     TABLE GET               |a2      |1        |46  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([f_acc.c2], [a1.c2], [a2.c2]), filter(nil), 
      equal_conds([least(a1.c2, a2.c2) = f_acc.c2]), other_conds(nil)
  1 - output([f_acc.c2]), filter(nil)
  2 - output([f_acc.c2]), filter(nil), dop=1
  3 - output([f_acc.c2]), filter(nil), 
      force partition granule.
  4 - output([f_acc.c2]), filter(nil), 
      access([f_acc.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([f_acc.c1]), range(MIN ; MAX)always true
  5 - output([a1.c2], [a2.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  6 - output([a1.c2]), filter(nil), 
      equal_conds([f2.c3 = t2.c3]), other_conds(nil)
  7 - output([a1.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  8 - output([t2.c3]), filter(nil), 
      conds([t2.c3 = f1.c3]), nl_params_(nil), batch_join=false
  9 - output([f1.c3]), filter(nil)
  10 - output([f1.c3]), filter(nil), is_single, dop=1
  11 - output([f1.c3]), filter(nil), 
      access([f1.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([f1.c1]), range[1 ; 1], 
      range_cond([f1.c1 = ?])
  12 - output([t2.c3]), filter(nil)
  13 - output([t2.c3]), filter(nil), dop=1
  14 - output([t2.c3]), filter(nil), 
      force partition granule.
  15 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  16 - output([a1.c2]), filter(nil)
  17 - output([a1.c2]), filter(nil)
  18 - output([a1.c2]), filter(nil), is_single, dop=1
  19 - output([a1.c2]), filter(nil), 
      access([a1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a1.c1]), range[1 ; 1], 
      range_cond([a1.c1 = ?])
  20 - output([f2.c3]), filter(nil), 
      access([f2.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([f2.c1]), range[3 ; 3], 
      range_cond([f2.c1 = ?])
  21 - output([a2.c2]), filter(nil)
  22 - output([a2.c2]), filter(nil)
  23 - output([a2.c2]), filter(nil), is_single, dop=1
  24 - output([a2.c2]), filter(nil), 
      access([a2.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a2.c1]), range[3 ; 3], 
      range_cond([a2.c1 = ?])

*************** Case 281(end)  ************** 

***************   Case 282   ***************

SQL: select f_acc.c2, a1.c2, a2.c2 from t2 left join t2 f1 on (f1.c1 =1 and f1.c3 = t2.c3) left join t3 a1 on (a1.c1 = f1.c1) left join t3 a2 on (a2.c1 = f1.c1) , t3 f_acc where least(a1.c2, a2.c2) = f_acc.c2; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |HASH JOIN                  |        |1        |280 |
|1 | PX COORDINATOR            |        |1        |92  |
|2 |  EXCHANGE OUT DISTR       |:EX10000|1        |92  |
|3 |   PX PARTITION ITERATOR   |        |1        |92  |
|4 |    TABLE SCAN             |f_acc   |1        |92  |
|5 | NESTED-LOOP JOIN CARTESIAN|        |1        |188 |
|6 |  NESTED-LOOP JOIN         |        |1        |142 |
|7 |   PX COORDINATOR          |        |1        |47  |
|8 |    EXCHANGE OUT DISTR     |:EX20000|1        |46  |
|9 |     TABLE GET             |f1      |1        |46  |
|10|   PX COORDINATOR          |        |1        |138 |
|11|    EXCHANGE OUT DISTR     |:EX30000|1        |137 |
|12|     PX PARTITION ITERATOR |        |1        |137 |
|13|      TABLE SCAN           |t2      |1        |137 |
|14|  MATERIAL                 |        |1        |46  |
|15|   PX COORDINATOR          |        |1        |46  |
|16|    EXCHANGE OUT DISTR     |:EX40000|1        |46  |
|17|     TABLE GET             |a1      |1        |46  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([f_acc.c2], [a1.c2], [a1.c2]), filter(nil), 
      equal_conds([least(a1.c2, a1.c2) = f_acc.c2]), other_conds(nil)
  1 - output([f_acc.c2]), filter(nil)
  2 - output([f_acc.c2]), filter(nil), dop=1
  3 - output([f_acc.c2]), filter(nil), 
      force partition granule.
  4 - output([f_acc.c2]), filter(nil), 
      access([f_acc.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([f_acc.c1]), range(MIN ; MAX)always true
  5 - output([a1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  6 - output(nil), filter(nil), 
      conds([f1.c3 = t2.c3]), nl_params_(nil), batch_join=false
  7 - output([f1.c3]), filter(nil)
  8 - output([f1.c3]), filter(nil), is_single, dop=1
  9 - output([f1.c3]), filter(nil), 
      access([f1.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([f1.c1]), range[1 ; 1], 
      range_cond([f1.c1 = ?])
  10 - output([t2.c3]), filter(nil)
  11 - output([t2.c3]), filter(nil), dop=1
  12 - output([t2.c3]), filter(nil), 
      force partition granule.
  13 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  14 - output([a1.c2]), filter(nil)
  15 - output([a1.c2]), filter(nil)
  16 - output([a1.c2]), filter(nil), is_single, dop=1
  17 - output([a1.c2]), filter(nil), 
      access([a1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a1.c1]), range[1 ; 1], 
      range_cond([a1.c1 = ?])

*************** Case 282(end)  ************** 

***************   Case 283   ***************

SQL: select * from t9,t10,t11 where t9.c2=t10.c2 and t9.c3=t10.c3 and t9.c2=t11.c2 and t9.c3=t11.c3 order by t11.c3,t11.c2; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SORT                     |        |1        |230 |
|1 | HASH JOIN               |        |1        |230 |
|2 |  TABLE SCAN             |t9      |1        |46  |
|3 |  PX COORDINATOR         |        |1        |184 |
|4 |   EXCHANGE OUT DISTR    |:EX10000|1        |184 |
|5 |    PX PARTITION ITERATOR|        |1        |183 |
|6 |     HASH JOIN           |        |1        |183 |
|7 |      TABLE SCAN         |t10     |1        |92  |
|8 |      TABLE SCAN         |t11     |1        |92  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3], [t11.c1], [t11.c2], [t11.c3]), filter(nil), sort_keys([t11.c3, ASC], [t11.c2, ASC])
  1 - output([t11.c3], [t11.c2], [t9.c1], [t9.c2], [t9.c3], [t10.c1], [t10.c2], [t10.c3], [t11.c1]), filter(nil), 
      equal_conds([t9.c2 = t10.c2], [t9.c3 = t10.c3]), other_conds(nil)
  2 - output([t9.c1], [t9.c2], [t9.c3]), filter(nil), 
      access([t9.c1], [t9.c2], [t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  3 - output([t11.c3], [t11.c2], [t10.c1], [t10.c2], [t10.c3], [t11.c1]), filter(nil)
  4 - output([t11.c3], [t11.c2], [t10.c1], [t10.c2], [t10.c3], [t11.c1]), filter(nil), dop=1
  5 - output([t11.c3], [t11.c2], [t10.c1], [t10.c2], [t10.c3], [t11.c1]), filter(nil), 
      partition wise, force partition granule.
  6 - output([t11.c3], [t11.c2], [t10.c1], [t10.c2], [t10.c3], [t11.c1]), filter(nil), 
      equal_conds([t10.c2 = t11.c2], [t10.c3 = t11.c3]), other_conds(nil)
  7 - output([t10.c1], [t10.c2], [t10.c3]), filter(nil), 
      access([t10.c1], [t10.c2], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true
  8 - output([t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      access([t11.c1], [t11.c2], [t11.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 283(end)  ************** 

***************   Case 284   ***************

SQL: select t9.c2, t9.c3, t9.c2, t10.c3 from t9, t10 where t9.c2 = t10.c2 and t9.c3 = t10.c3 order by t9.c2, t9.c3 desc; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |1        |138 |
|1 | EXCHANGE OUT DISTR           |:EX10001|1        |138 |
|2 |  SORT                        |        |1        |138 |
|3 |   HASH JOIN                  |        |1        |138 |
|4 |    EXCHANGE IN DISTR         |        |1        |46  |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|6 |      TABLE SCAN              |t9      |1        |46  |
|7 |    PX PARTITION ITERATOR     |        |1        |92  |
|8 |     TABLE SCAN               |t10     |1        |92  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t9.c2, t9.c3, t9.c2, t10.c3)]), filter(nil), sort_keys([t9.c2, ASC], [t9.c3, DESC])
  1 - output([t9.c2], [t9.c3], [INTERNAL_FUNCTION(t9.c2, t9.c3, t9.c2, t10.c3)]), filter(nil), dop=1
  2 - output([t9.c2], [t9.c3], [t10.c3]), filter(nil), sort_keys([t9.c2, ASC], [t9.c3, DESC])
  3 - output([t9.c2], [t9.c3], [t10.c3]), filter(nil), 
      equal_conds([t9.c2 = t10.c2], [t9.c3 = t10.c3]), other_conds(nil)
  4 - output([t9.c2], [t9.c3]), filter(nil)
  5 - (#keys=1, [t9.c2]), output([t9.c2], [t9.c3]), filter(nil), is_single, dop=1
  6 - output([t9.c2], [t9.c3]), filter(nil), 
      access([t9.c2], [t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  7 - output([t10.c2], [t10.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t10.c2], [t10.c3]), filter(nil), 
      access([t10.c2], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 284(end)  ************** 

***************   Case 285   ***************

SQL: select c1, (select count(c1) from t7 where c1=t4.c1) calc_total, (select count(c1) from t8 where c1=0 and c1=t4.c1) calc_new from t4 where c1 in (select distinct c1 from t1); 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SUBPLAN FILTER                |        |1        |144 |
|1 | PX COORDINATOR               |        |1        |53  |
|2 |  EXCHANGE OUT DISTR          |:EX10001|1        |53  |
|3 |   NESTED-LOOP JOIN           |        |1        |53  |
|4 |    EXCHANGE IN DISTR         |        |1        |46  |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|6 |      TABLE SCAN              |t4      |1        |46  |
|7 |    PX PARTITION ITERATOR     |        |1        |30  |
|8 |     TABLE GET                |t1      |1        |30  |
|9 | SCALAR GROUP BY              |        |1        |46  |
|10|  TABLE GET                   |t7      |1        |46  |
|11| SCALAR GROUP BY              |        |1        |46  |
|12|  TABLE GET                   |t8      |1        |46  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [subquery(1)], [subquery(2)]), filter(nil), 
      exec_params_([t4.c1], [? = t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil)
  2 - output([t4.c1]), filter(nil), dop=1
  3 - output([t4.c1]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=false
  4 - output([t4.c1], [PARTITION_ID]), filter(nil)
  5 - (#keys=1, [t4.c1]), output([t4.c1], [PARTITION_ID]), filter(nil), is_single, dop=1
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  7 - output(nil), filter(nil), 
      affinitize, force partition granule.
  8 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([? = t1.c1])
  9 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  10 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 = ?])
  11 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  12 - output(nil), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[0 ; 0], 
      range_cond([t8.c1 = ?])

*************** Case 285(end)  ************** 

***************   Case 286   ***************

SQL: select c1, (select count(c1) from t7 ) calc_total, (select count(c1) from t8 ) calc_new from t4  where c1 in (select distinct c1 from t1); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN     |        |1        |144 |
|1 | NESTED-LOOP JOIN CARTESIAN    |        |1        |99  |
|2 |  PX COORDINATOR               |        |1        |53  |
|3 |   EXCHANGE OUT DISTR          |:EX10001|1        |53  |
|4 |    NESTED-LOOP JOIN           |        |1        |53  |
|5 |     EXCHANGE IN DISTR         |        |1        |46  |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|7 |       TABLE SCAN              |t4      |1        |46  |
|8 |     PX PARTITION ITERATOR     |        |1        |30  |
|9 |      TABLE GET                |t1      |1        |30  |
|10|  MATERIAL                     |        |1        |46  |
|11|   SUBPLAN SCAN                |VIEW2   |1        |46  |
|12|    SCALAR GROUP BY            |        |1        |46  |
|13|     TABLE SCAN                |t7      |1        |46  |
|14| MATERIAL                      |        |1        |46  |
|15|  SUBPLAN SCAN                 |VIEW3   |1        |46  |
|16|   SCALAR GROUP BY             |        |1        |46  |
|17|    TABLE SCAN                 |t8      |1        |46  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [VIEW2.count(c1)], [VIEW3.count(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [VIEW2.count(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t4.c1]), filter(nil)
  3 - output([t4.c1]), filter(nil), dop=1
  4 - output([t4.c1]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=false
  5 - output([t4.c1], [PARTITION_ID]), filter(nil)
  6 - (#keys=1, [t4.c1]), output([t4.c1], [PARTITION_ID]), filter(nil), is_single, dop=1
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  8 - output(nil), filter(nil), 
      affinitize, force partition granule.
  9 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([? = t1.c1])
  10 - output([VIEW2.count(c1)]), filter(nil)
  11 - output([VIEW2.count(c1)]), filter(nil), 
      access([VIEW2.count(c1)])
  12 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  13 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  14 - output([VIEW3.count(c1)]), filter(nil)
  15 - output([VIEW3.count(c1)]), filter(nil), 
      access([VIEW3.count(c1)])
  16 - output([T_FUN_COUNT(t8.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t8.c1)])
  17 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 286(end)  ************** 

***************   Case 287   ***************

SQL: select distinct (select c1) from t4 limit 100; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |LIMIT          |    |1        |46  |
|1 | MERGE DISTINCT|    |1        |46  |
|2 |  TABLE SCAN   |t4  |1        |46  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  2 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 287(end)  ************** 

***************   Case 288   ***************

SQL: select * from t4 where c1 > 0 and c1 < 100 order by c2 limit 1; 

===============================================
|ID|OPERATOR  |NAME            |EST. ROWS|COST|
-----------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2_c3)|1        |1   |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 > ?], [t4.c1 < ?]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 288(end)  ************** 

***************   Case 289   ***************

SQL: select * from tt1 where c2 like "a%"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_LIKE, tt1.c2, ?, '\\')]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 289(end)  ************** 

***************   Case 290   ***************

SQL: select * from tt1 where c2 like "ab%"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_LIKE, tt1.c2, ?, '\\')]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 290(end)  ************** 

***************   Case 291   ***************

SQL: select * from tt1 where c2 between "aa" and "ab"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([tt1.c2 >= ?], [tt1.c2 <= ?]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 291(end)  ************** 

***************   Case 292   ***************

SQL: select * from tt1 where c2 between "aa" and "ai"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([tt1.c2 >= ?], [tt1.c2 <= ?]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 292(end)  ************** 

***************   Case 293   ***************

SQL: select * from tt1 where c2 not between "aa" and "ab"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([tt1.c2 < ? OR tt1.c2 > ?]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 293(end)  ************** 

***************   Case 294   ***************

SQL: select * from tt1 where c2 not between "aa" and "ai"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([tt1.c2 < ? OR tt1.c2 > ?]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 294(end)  ************** 

***************   Case 295   ***************

SQL: select * from tt1 where "ag" between c2 and "ai"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_BTW, ?, tt1.c2, ?)]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 295(end)  ************** 

***************   Case 296   ***************

SQL: select * from tt1 where "ag" between "aa" and "c2"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter(nil), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 296(end)  ************** 

***************   Case 297   ***************

SQL: select * from tt1 where 'ag' not between c1 and 'ai'; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_NOT_BTW, ?, tt1.c1, ?)]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 297(end)  ************** 

***************   Case 298   ***************

SQL: SELECT id, k, c, pad FROM sbtest_sysbench WHERE k IN(1,2,3,4,5,6,7,8,9,10); 

=====================================================
|ID|OPERATOR  |NAME                  |EST. ROWS|COST|
-----------------------------------------------------
|0 |TABLE SCAN|sbtest_sysbench(key_1)|1        |1   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([sbtest_sysbench.id], [sbtest_sysbench.k], [sbtest_sysbench.c], [sbtest_sysbench.pad]), filter(nil), 
      access([sbtest_sysbench.id], [sbtest_sysbench.k], [sbtest_sysbench.c], [sbtest_sysbench.pad]), partitions(p0), 
      is_index_back=true, 
      range_key([sbtest_sysbench.k], [sbtest_sysbench.id]), range(1,MIN ; 1,MAX), (2,MIN ; 2,MAX), (3,MIN ; 3,MAX), (4,MIN ; 4,MAX), (5,MIN ; 5,MAX), (6,MIN ; 6,MAX), (7,MIN ; 7,MAX), (8,MIN ; 8,MAX), (9,MIN ; 9,MAX), (10,MIN ; 10,MAX), 
      range_cond([sbtest_sysbench.k IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)])

*************** Case 298(end)  ************** 

***************   Case 299   ***************

SQL: select a1 from test_limit limit 1000; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1]), filter(nil), 
      access([test_limit.a1]), partitions(p0), 
      limit(1000), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 299(end)  ************** 

***************   Case 300   ***************

SQL: select a1,a2,a3 from test_limit limit 1000; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1], [test_limit.a2], [test_limit.a3]), filter(nil), 
      access([test_limit.a1], [test_limit.a2], [test_limit.a3]), partitions(p0), 
      limit(1000), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 300(end)  ************** 

***************   Case 301   ***************

SQL: select * from test_limit limit 1000; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1], [test_limit.a2], [test_limit.a3], [test_limit.a4], [test_limit.a5], [test_limit.a6]), filter(nil), 
      access([test_limit.a1], [test_limit.a2], [test_limit.a3], [test_limit.a4], [test_limit.a5], [test_limit.a6]), partitions(p0), 
      limit(1000), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 301(end)  ************** 

***************   Case 302   ***************

SQL: select a1 from test_limit limit 500; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1]), filter(nil), 
      access([test_limit.a1]), partitions(p0), 
      limit(500), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 302(end)  ************** 

***************   Case 303   ***************

SQL: select a1,a2,a3 from test_limit limit 500; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1], [test_limit.a2], [test_limit.a3]), filter(nil), 
      access([test_limit.a1], [test_limit.a2], [test_limit.a3]), partitions(p0), 
      limit(500), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 303(end)  ************** 

***************   Case 304   ***************

SQL: select * from test_limit limit 500; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|test_limit|1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([test_limit.a1], [test_limit.a2], [test_limit.a3], [test_limit.a4], [test_limit.a5], [test_limit.a6]), filter(nil), 
      access([test_limit.a1], [test_limit.a2], [test_limit.a3], [test_limit.a4], [test_limit.a5], [test_limit.a6]), partitions(p0), 
      limit(500), offset(nil), 
      is_index_back=false, 
      range_key([test_limit.__pk_increment], [test_limit.__pk_cluster_id], [test_limit.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 304(end)  ************** 

***************   Case 305   ***************

SQL: select * from cb_dep_acctbal_54 s,  cb_dep_acct_54 a where s.acctnbr = a.acctnbr and (a.curracctstatcd != 'CLS' or (a.curracctstatcd = 'CLS' and exists(select 1 from cb_dep_rxtnbal_54 r where r.acctnbr = a.acctnbr))); 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SUBPLAN FILTER                |        |1        |99  |
|1 | PX COORDINATOR               |        |1        |53  |
|2 |  EXCHANGE OUT DISTR          |:EX10001|1        |53  |
|3 |   NESTED-LOOP JOIN           |        |1        |53  |
|4 |    EXCHANGE IN DISTR         |        |1        |46  |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|6 |      TABLE SCAN              |s       |1        |46  |
|7 |    PX PARTITION ITERATOR     |        |1        |30  |
|8 |     TABLE GET                |a       |1        |30  |
|9 | TABLE SCAN                   |r       |1        |46  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([s.acctnbr], [s.balcatcd], [s.baltypcd], [a.acctnbr], [a.curracctstatcd]), filter([a.curracctstatcd != ? OR a.curracctstatcd = ? AND (T_OP_EXISTS, subquery(1))]), 
      exec_params_([cast(a.acctnbr, DECIMAL(20, 0))]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([s.acctnbr], [s.balcatcd], [s.baltypcd], [a.acctnbr], [a.curracctstatcd], [a.curracctstatcd != ?], [a.curracctstatcd = ?]), filter(nil)
  2 - output([s.acctnbr], [s.balcatcd], [s.baltypcd], [a.acctnbr], [a.curracctstatcd], [a.curracctstatcd != ?], [a.curracctstatcd = ?]), filter(nil), dop=1
  3 - output([s.acctnbr], [s.balcatcd], [s.baltypcd], [a.acctnbr], [a.curracctstatcd], [a.curracctstatcd != ?], [a.curracctstatcd = ?]), filter(nil), 
      conds(nil), nl_params_([s.acctnbr]), batch_join=false
  4 - output([s.acctnbr], [s.balcatcd], [s.baltypcd], [PARTITION_ID]), filter(nil)
  5 - (#keys=1, [s.acctnbr]), output([s.acctnbr], [s.balcatcd], [s.baltypcd], [PARTITION_ID]), filter(nil), is_single, dop=1
  6 - output([s.acctnbr], [s.balcatcd], [s.baltypcd]), filter(nil), 
      access([s.acctnbr], [s.balcatcd], [s.baltypcd]), partitions(p0), 
      is_index_back=false, 
      range_key([s.acctnbr], [s.balcatcd], [s.baltypcd]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([a.acctnbr], [a.curracctstatcd], [a.curracctstatcd != ?], [a.curracctstatcd = ?]), filter(nil), 
      affinitize, force partition granule.
  8 - output([a.acctnbr], [a.curracctstatcd], [a.curracctstatcd != ?], [a.curracctstatcd = ?]), filter([a.curracctstatcd != ? OR a.curracctstatcd = ?]), 
      access([a.acctnbr], [a.curracctstatcd]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([a.acctnbr]), range(MIN ; MAX), 
      range_cond([? = a.acctnbr])
  9 - output([?]), filter([cast(r.acctnbr, DECIMAL(-1, -1)) = ?]), 
      access([r.acctnbr]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([r.__pk_increment], [r.__pk_cluster_id], [r.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 305(end)  ************** 

