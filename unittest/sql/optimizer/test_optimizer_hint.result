***************   Case 1   ***************

SQL: select /*+ log_level(debug)*/ * from hint.t1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
<<<<<<< HEAD
      LOG_LEVEL("debug")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LOG_LEVEL('debug')
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 1(end)  ************** 

***************   Case 2   ***************

SQL: select /*+ log_level('sql.opt:debug')*/ * from hint.t1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
<<<<<<< HEAD
      LOG_LEVEL("sql.opt:debug")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LOG_LEVEL('sql.opt:debug')
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 2(end)  ************** 

***************   Case 3   ***************

SQL: select /*+ leading(ta, tb) use_nl(tb)*/ * from hint.t1 as tb, opt.t1 as ta where tb.a = ta.c1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN        |        |100      |3241|
|1 | PX COORDINATOR         |        |500      |528 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|3 |   PX PARTITION ITERATOR|        |500      |387 |
|4 |    TABLE SCAN          |ta      |500      |387 |
|5 | TABLE GET              |tb      |1        |5   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([tb.a], [tb.b], [ta.c1], [ta.c2]), filter(nil), 
      conds(nil), nl_params_([ta.c1])
  1 - output([ta.c1], [ta.c2]), filter(nil)
  2 - output([ta.c1], [ta.c2]), filter(nil), dop=1
  3 - output([ta.c1], [ta.c2]), filter(nil)
  4 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."ta"@"SEL$1" "hint"."tb"@"SEL$1"))
      USE_NL(@"SEL$1" "hint"."tb"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."tb"@"SEL$1" LOCAL LOCAL)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tb"@"SEL$1" ) LOCAL LOCAL)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("hint.tb"@"SEL$1" ))
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 3(end)  ************** 

***************   Case 4   ***************

SQL: select /*+ leading(ta, tb) use_bnl(tb)*/ * from hint.t1 as tb, opt.t1 as ta where tb.a = ta.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |692 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |675 |
|2 |  HASH JOIN                  |        |100      |639 |
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |ta      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |100      |106 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|7 |     TABLE SCAN              |tb      |100      |78  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(tb.a, tb.b, ta.c1, ta.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(tb.a, tb.b, ta.c1, ta.c2)]), filter(nil), dop=1
  2 - output([tb.a], [ta.c1], [ta.c2], [tb.b]), filter(nil), 
      equal_conds([tb.a = ta.c1]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil)
  4 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  5 - output([tb.a], [tb.b]), filter(nil)
  6 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  7 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."ta"@"SEL$1" "hint"."tb"@"SEL$1"))
      USE_HASH(@"SEL$1" "hint"."tb"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."tb"@"SEL$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tb"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 4(end)  ************** 

***************   Case 5   ***************

SQL: select /*+ leading(t1) use_nl(hint.t1)*/ * from hint.t2, hint.t1, opt.t1 where hint.t2.a = opt.t1.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN     |        |10000    |1285|
|1 | TABLE SCAN                    |t1      |100      |78  |
|2 | MATERIAL                      |        |100      |691 |
|3 |  PX COORDINATOR               |        |100      |689 |
|4 |   EXCHANGE OUT DISTR          |:EX10001|100      |673 |
|5 |    HASH JOIN                  |        |100      |637 |
|6 |     EXCHANGE IN DISTR         |        |100      |106 |
|7 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|8 |       TABLE SCAN              |t2      |100      |78  |
|9 |     PX PARTITION ITERATOR     |        |500      |387 |
|10|      TABLE SCAN               |t1      |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.a], [t2.b], [t1.a], [t1.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil)
  3 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil)
  4 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t2.a = t1.c1]), other_conds(nil)
  6 - output([t2.a], [t2.b]), filter(nil)
  7 - (#keys=1, [t2.a]), output([t2.a], [t2.b]), filter(nil), is_single, dop=1
  8 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  9 - output([t1.c1], [t1.c2]), filter(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t1"@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1")))
      USE_NL(@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      PQ_DISTRIBUTE(@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1") LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" )))
      USE_NL(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 5(end)  ************** 

***************   Case 6   ***************

SQL: select /*+ leading(t1) use_bnl(hint.t1)*/ * from hint.t2, hint.t1, opt.t1 where hint.t2.a = opt.t1.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN     |        |10000    |1285|
|1 | TABLE SCAN                    |t1      |100      |78  |
|2 | MATERIAL                      |        |100      |691 |
|3 |  PX COORDINATOR               |        |100      |689 |
|4 |   EXCHANGE OUT DISTR          |:EX10001|100      |673 |
|5 |    HASH JOIN                  |        |100      |637 |
|6 |     EXCHANGE IN DISTR         |        |100      |106 |
|7 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|8 |       TABLE SCAN              |t2      |100      |78  |
|9 |     PX PARTITION ITERATOR     |        |500      |387 |
|10|      TABLE SCAN               |t1      |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.a], [t2.b], [t1.a], [t1.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil)
  3 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil)
  4 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t2.a = t1.c1]), other_conds(nil)
  6 - output([t2.a], [t2.b]), filter(nil)
  7 - (#keys=1, [t2.a]), output([t2.a], [t2.b]), filter(nil), is_single, dop=1
  8 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  9 - output([t1.c1], [t1.c2]), filter(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t1"@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1")))
      USE_NL(@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      PQ_DISTRIBUTE(@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1") LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" )))
      USE_NL(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 6(end)  ************** 

***************   Case 7   ***************

SQL: select /*+ leading(t2, t1) use_merge(t1)*/ * from hint.t2, opt.t1 where t1.c1 = t2.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |691 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |674 |
|2 |  MERGE JOIN                 |        |100      |638 |
|3 |   EXCHANGE IN DISTR         |        |100      |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|5 |     TABLE SCAN              |t2      |100      |78  |
|6 |   SORT                      |        |500      |490 |
|7 |    PX PARTITION ITERATOR    |        |500      |387 |
|8 |     TABLE SCAN              |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.a, t2.b, t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.a, t2.b, t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.a], [t2.b], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.a]), other_conds(nil)
  3 - output([t2.a], [t2.b]), filter(nil)
  4 - (#keys=1, [t2.a]), output([t2.a], [t2.b]), filter(nil), is_single, dop=1
  5 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_MERGE(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 7(end)  ************** 

***************   Case 8   ***************

SQL: select /*+ index(hint.t1 idx_t1_a)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c1; 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR               |            |100      |703 |
|1 | EXCHANGE OUT DISTR          |:EX10001    |100      |686 |
|2 |  HASH JOIN                  |            |100      |651 |
|3 |   EXCHANGE IN DISTR         |            |100      |120 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000    |100      |110 |
|5 |     TABLE SCAN              |t1(idx_t1_a)|100      |92  |
|6 |   PX PARTITION ITERATOR     |            |500      |387 |
|7 |    TABLE SCAN               |t1          |500      |387 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.a, t1.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.a, t1.b)]), filter(nil), dop=1
  2 - output([t1.a], [t1.c1], [t1.b], [t1.c2]), filter(nil), 
      equal_conds([t1.a = t1.c1]), other_conds(nil)
  3 - output([t1.a], [t1.b]), filter(nil)
  4 - (#keys=1, [t1.a]), output([t1.a], [t1.b]), filter(nil), is_single, dop=1
  5 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t1"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" PARTITION NONE)
      INDEX(@"SEL$1" "hint"."t1"@"SEL$1" "idx_t1_a")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      INDEX(@"SEL$1" "hint"."t1"@"SEL$1" "idx_t1_a")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 8(end)  ************** 

***************   Case 9   ***************

SQL: select /*+ full(opt.t1)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c2; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH JOIN               |        |451      |749 |
|1 | TABLE SCAN             |t1      |100      |78  |
|2 | PX COORDINATOR         |        |500      |528 |
|3 |  EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|4 |   PX PARTITION ITERATOR|        |500      |387 |
|5 |    TABLE SCAN          |t1      |500      |387 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = t1.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t1"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 9(end)  ************** 

***************   Case 10   ***************

SQL: select /*+ ordered use_nl(hint.t2 opt.t1)*/ * from (select * from t2) as tb, hint.t2, opt.t1; 

===========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST   |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |15000000 |1292839|
|1 | NESTED-LOOP JOIN CARTESIAN|        |50000    |3186   |
|2 |  TABLE SCAN               |t2      |100      |78     |
|3 |  MATERIAL                 |        |500      |531    |
|4 |   PX COORDINATOR          |        |500      |528    |
|5 |    EXCHANGE OUT DISTR     |:EX10000|500      |481    |
|6 |     PX PARTITION ITERATOR |        |500      |387    |
|7 |      TABLE SCAN           |t1      |500      |387    |
|8 | MATERIAL                  |        |300      |471    |
|9 |  PX COORDINATOR           |        |300      |464    |
|10|   EXCHANGE OUT DISTR      |:EX20000|300      |391    |
|11|    PX PARTITION ITERATOR  |        |300      |233    |
|12|     TABLE SCAN            |t2      |300      |233    |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1") "opt"."t2"@"SEL$2"))
      USE_NL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      USE_NL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$CFEA49FE" "hint"."t2"@"SEL$1")
      FULL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" )"opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 10(end)  ************** 

***************   Case 11   ***************

SQL: select /*+ ordered use_bnl(hint.t2 opt.t1)*/ * from (select * from t2) as tb, hint.t2, opt.t1; 

===========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST   |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |15000000 |1292839|
|1 | NESTED-LOOP JOIN CARTESIAN|        |50000    |3186   |
|2 |  TABLE SCAN               |t2      |100      |78     |
|3 |  MATERIAL                 |        |500      |531    |
|4 |   PX COORDINATOR          |        |500      |528    |
|5 |    EXCHANGE OUT DISTR     |:EX10000|500      |481    |
|6 |     PX PARTITION ITERATOR |        |500      |387    |
|7 |      TABLE SCAN           |t1      |500      |387    |
|8 | MATERIAL                  |        |300      |471    |
|9 |  PX COORDINATOR           |        |300      |464    |
|10|   EXCHANGE OUT DISTR      |:EX20000|300      |391    |
|11|    PX PARTITION ITERATOR  |        |300      |233    |
|12|     TABLE SCAN            |t2      |300      |233    |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1") "opt"."t2"@"SEL$2"))
      USE_NL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      USE_NL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$CFEA49FE" "hint"."t2"@"SEL$1")
      FULL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" )"opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 11(end)  ************** 

***************   Case 12   ***************

SQL: select /*+ leading(tb, opt.t1) use_nl(hint.t2 opt.t1)*/ * from (select * from t2) as tb, hint.t2, opt.t1; 

===========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST   |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |15000000 |3876364|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |8729   |
|2 |  PX COORDINATOR           |        |300      |464    |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |391    |
|4 |    PX PARTITION ITERATOR  |        |300      |233    |
|5 |     TABLE SCAN            |t2      |300      |233    |
|6 |  MATERIAL                 |        |500      |531    |
|7 |   PX COORDINATOR          |        |500      |528    |
|8 |    EXCHANGE OUT DISTR     |:EX20000|500      |481    |
|9 |     PX PARTITION ITERATOR |        |500      |387    |
|10|      TABLE SCAN           |t1      |500      |387    |
|11| MATERIAL                  |        |100      |79     |
|12|  TABLE SCAN               |t2      |100      |78     |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  9 - output([t1.c1], [t1.c2]), filter(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  11 - output([t2.a], [t2.b]), filter(nil)
  12 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("opt"."t2"@"SEL$2" "opt"."t1"@"SEL$1") "hint"."t2"@"SEL$1"))
      USE_NL(@"SEL$CFEA49FE" "hint"."t2"@"SEL$1")
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "hint"."t2"@"SEL$1")
      USE_NL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      FULL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$CFEA49FE" "hint"."t2"@"SEL$1")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" )"hint.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t2"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 12(end)  ************** 

***************   Case 13   ***************

SQL: select /*+ leading(tb, opt.t1) use_bnl(hint.t2, opt.t1)*/ * from (select * from t2) as tb, hint.t2, opt.t1; 

===========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST   |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |15000000 |3876364|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |8729   |
|2 |  PX COORDINATOR           |        |300      |464    |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |391    |
|4 |    PX PARTITION ITERATOR  |        |300      |233    |
|5 |     TABLE SCAN            |t2      |300      |233    |
|6 |  MATERIAL                 |        |500      |531    |
|7 |   PX COORDINATOR          |        |500      |528    |
|8 |    EXCHANGE OUT DISTR     |:EX20000|500      |481    |
|9 |     PX PARTITION ITERATOR |        |500      |387    |
|10|      TABLE SCAN           |t1      |500      |387    |
|11| MATERIAL                  |        |100      |79     |
|12|  TABLE SCAN               |t2      |100      |78     |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  9 - output([t1.c1], [t1.c2]), filter(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  11 - output([t2.a], [t2.b]), filter(nil)
  12 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("opt"."t2"@"SEL$2" "opt"."t1"@"SEL$1") "hint"."t2"@"SEL$1"))
      USE_NL(@"SEL$CFEA49FE" "hint"."t2"@"SEL$1")
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "hint"."t2"@"SEL$1")
      USE_NL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      FULL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$CFEA49FE" "hint"."t2"@"SEL$1")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" )"hint.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t2"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 13(end)  ************** 

***************   Case 14   ***************

SQL: select * from opt.t1,opt.t2 use index (idx_t1_c2) where opt.t1.c1 = opt.t2.c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |270      |1321|
|1 | EXCHANGE OUT DISTR          |:EX10001|270      |1234|
|2 |  HASH JOIN                  |        |270      |1046|
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |300      |464 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |391 |
|7 |     PX PARTITION ITERATOR   |        |300      |233 |
|8 |      TABLE SCAN             |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2], [t1.c2], [t2.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  5 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil)
  6 - (#keys=1, [t2.c2]), output([t2.c2], [t2.c1], [t2.c3]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 14(end)  ************** 

***************   Case 15   ***************

SQL: select /*+ index(t1 idx_t1_c2)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c2; 

==========================================================
|ID|OPERATOR                |NAME         |EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH JOIN               |             |451      |749 |
|1 | TABLE SCAN             |t1           |100      |78  |
|2 | PX COORDINATOR         |             |500      |528 |
|3 |  EXCHANGE OUT DISTR    |:EX10000     |500      |481 |
|4 |   PX PARTITION ITERATOR|             |500      |387 |
|5 |    TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = t1.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t1"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 15(end)  ************** 

***************   Case 16   ***************

SQL: select /*+ index(opt.t1 idx_t1_c2)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c2; 

==========================================================
|ID|OPERATOR                |NAME         |EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH JOIN               |             |451      |749 |
|1 | TABLE SCAN             |t1           |100      |78  |
|2 | PX COORDINATOR         |             |500      |528 |
|3 |  EXCHANGE OUT DISTR    |:EX10000     |500      |481 |
|4 |   PX PARTITION ITERATOR|             |500      |387 |
|5 |    TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = t1.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t1"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 16(end)  ************** 

***************   Case 17   ***************

SQL: select /*+ index(opt.t1 idx_t1_c2) use_merge(hint.t2, hint.t1)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c2; 

==========================================================
|ID|OPERATOR                |NAME         |EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH JOIN               |             |451      |749 |
|1 | TABLE SCAN             |t1           |100      |78  |
|2 | PX COORDINATOR         |             |500      |528 |
|3 |  EXCHANGE OUT DISTR    |:EX10000     |500      |481 |
|4 |   PX PARTITION ITERATOR|             |500      |387 |
|5 |    TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = t1.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t1"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 17(end)  ************** 

***************   Case 18   ***************

SQL: select /*+ index(opt.t1 idx_t1_c2) use_merge(test hint.t2) use_nl(hint.t1)*/ * from opt.t1, hint.t1 where hint.t1.a = opt.t1.c2; 

==========================================================
|ID|OPERATOR                |NAME         |EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH JOIN               |             |451      |749 |
|1 | TABLE SCAN             |t1           |100      |78  |
|2 | PX COORDINATOR         |             |500      |528 |
|3 |  EXCHANGE OUT DISTR    |:EX10000     |500      |481 |
|4 |   PX PARTITION ITERATOR|             |500      |387 |
|5 |    TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = t1.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t1"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 18(end)  ************** 

***************   Case 19   ***************

SQL: select /*+ index(ta idx_t1_c2) use_merge(test) use_nl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR               |             |100      |689 |
|1 | EXCHANGE OUT DISTR          |:EX10001     |100      |673 |
|2 |  HASH JOIN                  |             |100      |637 |
|3 |   EXCHANGE IN DISTR         |             |100      |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000     |100      |97  |
|5 |     TABLE SCAN              |tb           |100      |78  |
|6 |   PX PARTITION ITERATOR     |             |500      |387 |
|7 |    TABLE SCAN               |ta(idx_t1_c2)|500      |387 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil), dop=1
  2 - output([ta.c1], [tb.a], [tb.b], [ta.c2]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."tb"@"SEL$1" "opt"."ta"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."ta"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."ta"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      INDEX(@"SEL$1" "opt"."ta"@"SEL$1" "idx_t1_c2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      INDEX(@"SEL$1" "opt"."ta"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 19(end)  ************** 

***************   Case 20   ***************

SQL: select /*+ index(ta idx_t1_c2) use_merge(test) use_bnl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR               |             |100      |689 |
|1 | EXCHANGE OUT DISTR          |:EX10001     |100      |673 |
|2 |  HASH JOIN                  |             |100      |637 |
|3 |   EXCHANGE IN DISTR         |             |100      |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000     |100      |97  |
|5 |     TABLE SCAN              |tb           |100      |78  |
|6 |   PX PARTITION ITERATOR     |             |500      |387 |
|7 |    TABLE SCAN               |ta(idx_t1_c2)|500      |387 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil), dop=1
  2 - output([ta.c1], [tb.a], [tb.b], [ta.c2]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."tb"@"SEL$1" "opt"."ta"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."ta"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."ta"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      INDEX(@"SEL$1" "opt"."ta"@"SEL$1" "idx_t1_c2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      INDEX(@"SEL$1" "opt"."ta"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 20(end)  ************** 

***************   Case 21   ***************

SQL: select /*+ index(opt.t1 idx_t1_c2) use_merge(opt.t2) use_nl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |689 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |673 |
|2 |  HASH JOIN                  |        |100      |637 |
|3 |   EXCHANGE IN DISTR         |        |100      |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|5 |     TABLE SCAN              |tb      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |ta      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil), dop=1
  2 - output([ta.c1], [tb.a], [tb.b], [ta.c2]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."tb"@"SEL$1" "opt"."ta"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."ta"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."ta"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 21(end)  ************** 

***************   Case 22   ***************

SQL: select /*+ index(opt.t1 idx_t1_c2) use_merge(opt.t2) use_bnl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |689 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |673 |
|2 |  HASH JOIN                  |        |100      |637 |
|3 |   EXCHANGE IN DISTR         |        |100      |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|5 |     TABLE SCAN              |tb      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |ta      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil), dop=1
  2 - output([ta.c1], [tb.a], [tb.b], [ta.c2]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."tb"@"SEL$1" "opt"."ta"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."ta"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."ta"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 22(end)  ************** 

***************   Case 23   ***************

SQL: select /*+ index(opt.t1 idx_test) use_merge(opt.t2) use_nl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |689 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |673 |
|2 |  HASH JOIN                  |        |100      |637 |
|3 |   EXCHANGE IN DISTR         |        |100      |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|5 |     TABLE SCAN              |tb      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |ta      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil), dop=1
  2 - output([ta.c1], [tb.a], [tb.b], [ta.c2]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."tb"@"SEL$1" "opt"."ta"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."ta"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."ta"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 23(end)  ************** 

***************   Case 24   ***************

SQL: select /*+ index(opt.t1 idx_test) use_merge(opt.t2) use_bnl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |689 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |673 |
|2 |  HASH JOIN                  |        |100      |637 |
|3 |   EXCHANGE IN DISTR         |        |100      |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|5 |     TABLE SCAN              |tb      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |ta      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil), dop=1
  2 - output([ta.c1], [tb.a], [tb.b], [ta.c2]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([tb.a], [tb.b]), filter(nil)
  4 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  5 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)
  6 - output([ta.c1], [ta.c2]), filter(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."tb"@"SEL$1" "opt"."ta"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."ta"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."ta"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 24(end)  ************** 

***************   Case 25   ***************

SQL: select /*+ index(opt.t1 idx_test) use_merge(ta tb) use_nl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |688 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |671 |
|2 |  MERGE JOIN                 |        |100      |635 |
|3 |   SORT                      |        |500      |490 |
|4 |    PX PARTITION ITERATOR    |        |500      |387 |
|5 |     TABLE SCAN              |ta      |500      |387 |
|6 |   EXCHANGE IN DISTR         |        |100      |106 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|8 |     TABLE SCAN              |tb      |100      |78  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil), dop=1
  2 - output([ta.c1], [tb.a], [ta.c2], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), local merge sort
  4 - output([ta.c1], [ta.c2]), filter(nil)
  5 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  6 - output([tb.a], [tb.b]), filter(nil)
  7 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  8 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."ta"@"SEL$1" "hint"."tb"@"SEL$1"))
      USE_MERGE(@"SEL$1" "hint"."tb"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."tb"@"SEL$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tb"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 25(end)  ************** 

***************   Case 26   ***************

SQL: select /*+ index(opt.t1 idx_test) use_merge(ta tb) use_bnl(tb)*/ * from opt.t1 as ta, hint.t1 as tb where ta.c1 = tb.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |688 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |671 |
|2 |  MERGE JOIN                 |        |100      |635 |
|3 |   SORT                      |        |500      |490 |
|4 |    PX PARTITION ITERATOR    |        |500      |387 |
|5 |     TABLE SCAN              |ta      |500      |387 |
|6 |   EXCHANGE IN DISTR         |        |100      |106 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|8 |     TABLE SCAN              |tb      |100      |78  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.a, tb.b)]), filter(nil), dop=1
  2 - output([ta.c1], [tb.a], [ta.c2], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c1, ASC]), local merge sort
  4 - output([ta.c1], [ta.c2]), filter(nil)
  5 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  6 - output([tb.a], [tb.b]), filter(nil)
  7 - (#keys=1, [tb.a]), output([tb.a], [tb.b]), filter(nil), is_single, dop=1
  8 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."ta"@"SEL$1" "hint"."tb"@"SEL$1"))
      USE_MERGE(@"SEL$1" "hint"."tb"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."tb"@"SEL$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tb"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 26(end)  ************** 

***************   Case 27   ***************

SQL: select * from opt.t1,hint.t1 use index (idx_t1_c2, idx_t1_a) where opt.t1.c1 = hint.t1.a; 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR               |            |100      |703 |
|1 | EXCHANGE OUT DISTR          |:EX10001    |100      |686 |
|2 |  HASH JOIN                  |            |100      |651 |
|3 |   EXCHANGE IN DISTR         |            |100      |120 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000    |100      |110 |
|5 |     TABLE SCAN              |t1(idx_t1_a)|100      |92  |
|6 |   PX PARTITION ITERATOR     |            |500      |387 |
|7 |    TABLE SCAN               |t1          |500      |387 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.a, t1.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.a, t1.b)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.a], [t1.b], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t1.a]), other_conds(nil)
  3 - output([t1.a], [t1.b]), filter(nil)
  4 - (#keys=1, [t1.a]), output([t1.a], [t1.b]), filter(nil), is_single, dop=1
  5 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t1"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" PARTITION NONE)
      INDEX(@"SEL$1" "hint"."t1"@"SEL$1" "idx_t1_a")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      INDEX(@"SEL$1" "hint"."t1"@"SEL$1" "idx_t1_a")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 27(end)  ************** 

***************   Case 28   ***************

SQL: select * from opt.t1,hint.t1 use index (idx_t1_a, idx_t1_c2) where opt.t1.c1 = hint.t1.a; 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR               |            |100      |703 |
|1 | EXCHANGE OUT DISTR          |:EX10001    |100      |686 |
|2 |  HASH JOIN                  |            |100      |651 |
|3 |   EXCHANGE IN DISTR         |            |100      |120 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000    |100      |110 |
|5 |     TABLE SCAN              |t1(idx_t1_a)|100      |92  |
|6 |   PX PARTITION ITERATOR     |            |500      |387 |
|7 |    TABLE SCAN               |t1          |500      |387 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.a, t1.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.a, t1.b)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.a], [t1.b], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t1.a]), other_conds(nil)
  3 - output([t1.a], [t1.b]), filter(nil)
  4 - (#keys=1, [t1.a]), output([t1.a], [t1.b]), filter(nil), is_single, dop=1
  5 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t1"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" PARTITION NONE)
      INDEX(@"SEL$1" "hint"."t1"@"SEL$1" "idx_t1_a")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      INDEX(@"SEL$1" "hint"."t1"@"SEL$1" "idx_t1_a")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 28(end)  ************** 

***************   Case 29   ***************

SQL: select * from opt.t1,hint.t1 force index (idx_t1_a, idx_t1_c2) where opt.t1.c1 = hint.t1.a; 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR               |            |100      |703 |
|1 | EXCHANGE OUT DISTR          |:EX10001    |100      |686 |
|2 |  HASH JOIN                  |            |100      |651 |
|3 |   EXCHANGE IN DISTR         |            |100      |120 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000    |100      |110 |
|5 |     TABLE SCAN              |t1(idx_t1_a)|100      |92  |
|6 |   PX PARTITION ITERATOR     |            |500      |387 |
|7 |    TABLE SCAN               |t1          |500      |387 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.a, t1.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.a, t1.b)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.a], [t1.b], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t1.a]), other_conds(nil)
  3 - output([t1.a], [t1.b]), filter(nil)
  4 - (#keys=1, [t1.a]), output([t1.a], [t1.b]), filter(nil), is_single, dop=1
  5 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t1"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" PARTITION NONE)
      INDEX(@"SEL$1" "hint"."t1"@"SEL$1" "idx_t1_a")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      INDEX(@"SEL$1" "hint"."t1"@"SEL$1" "idx_t1_a")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 29(end)  ************** 

***************   Case 30   ***************

SQL: select * from opt.t4 force index (idx_t4_c2,idx_t4_c3,idx_t4_c2_c3) where opt.t4.c1 = opt.t4.c2; 

===============================================
|ID|OPERATOR  |NAME            |EST. ROWS|COST|
-----------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2_c3)|9        |80  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = t4.c2]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c2_c3")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c3")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 30(end)  ************** 

***************   Case 31   ***************

SQL: select * from opt.t4 ignore index (idx_t4_c2,idx_t4_c3,idx_t4_c2_c3) where opt.t4.c1 = opt.t4.c2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |9        |80  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = t4.c2]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 31(end)  ************** 

***************   Case 32   ***************

SQL: select * from opt.t4 ignore index (idx_t4_c2,idx_t4_c3) where opt.t4.c1 = opt.t4.c2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |9        |80  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = t4.c2]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c2_c3")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 32(end)  ************** 

***************   Case 33   ***************

SQL: select * from opt.t4, hint.t1 ignore index (idx_t4_c2,idx_t4_c3, idx_t1_a) where opt.t4.c1 = hint.t1.a; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |91       |181 |
|1 | TABLE SCAN|t4  |100      |78  |
|2 | TABLE SCAN|t1  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t1.a], [t1.b]), filter(nil), 
      equal_conds([t4.c1 = t1.a]), other_conds(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  2 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t4"@"SEL$1" "hint"."t1"@"SEL$1"))
      USE_MERGE(@"SEL$1" "hint"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t1"@"SEL$1" ) LOCAL LOCAL)
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 33(end)  ************** 

***************   Case 34   ***************

SQL: select * from opt.t4 as ta, hint.t1 as tb ignore index (idx_t4_c2,idx_t4_c3, idx_t1_a) where ta.c1 = tb.a; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |91       |181 |
|1 | TABLE SCAN|ta  |100      |78  |
|2 | TABLE SCAN|tb  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [ta.c3], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  1 - output([ta.c1], [ta.c2], [ta.c3]), filter(nil), 
      access([ta.c1], [ta.c2], [ta.c3]), partitions(p0)
  2 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."ta"@"SEL$1" "hint"."tb"@"SEL$1"))
      USE_MERGE(@"SEL$1" "hint"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tb"@"SEL$1" ) LOCAL LOCAL)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 34(end)  ************** 

***************   Case 35   ***************

SQL: select * from opt.t1 use index(idx_yeti, idx_t1_c2) where opt.t1.c1 = opt.t1.c1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |500      |540 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |500      |494 |
|2 |  PX PARTITION ITERATOR|             |500      |400 |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|500      |400 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = t1.c1]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 35(end)  ************** 

***************   Case 36   ***************

SQL: select * from opt.t4 as ta, hint.t1 as tb ignore index (idx_test, idx_t1_a) where ta.c1 = tb.a; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |91       |181 |
|1 | TABLE SCAN|ta  |100      |78  |
|2 | TABLE SCAN|tb  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [ta.c3], [tb.a], [tb.b]), filter(nil), 
      equal_conds([ta.c1 = tb.a]), other_conds(nil)
  1 - output([ta.c1], [ta.c2], [ta.c3]), filter(nil), 
      access([ta.c1], [ta.c2], [ta.c3]), partitions(p0)
  2 - output([tb.a], [tb.b]), filter(nil), 
      access([tb.a], [tb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."ta"@"SEL$1" "hint"."tb"@"SEL$1"))
      USE_MERGE(@"SEL$1" "hint"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.ta"@"SEL$1" "hint.tb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tb"@"SEL$1" ) LOCAL LOCAL)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "hint"."tb"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 36(end)  ************** 

***************   Case 37   ***************

SQL: select * from opt.t1 use index(index_t1_c2) where opt.t1.c2 = (select hint.t1.a from hint.t1,opt.t2 use index(idx_t1_a) where opt.t2.c1 = hint.t1.b); 

================================================================
|ID|OPERATOR                      |NAME         |EST. ROWS|COST|
----------------------------------------------------------------
|0 |SUBPLAN FILTER                |             |5        |699 |
|1 | PX COORDINATOR               |             |5        |229 |
|2 |  EXCHANGE OUT DISTR          |:EX10000     |5        |228 |
|3 |   PX PARTITION ITERATOR      |             |5        |227 |
|4 |    TABLE SCAN                |t1(idx_t1_c2)|5        |227 |
|5 | PX COORDINATOR               |             |90       |471 |
|6 |  EXCHANGE OUT DISTR          |:EX20001     |90       |459 |
|7 |   HASH JOIN                  |             |90       |434 |
|8 |    EXCHANGE IN DISTR         |             |100      |106 |
|9 |     EXCHANGE OUT DISTR (PKEY)|:EX20000     |100      |97  |
|10|      TABLE SCAN              |t1           |100      |78  |
|11|    PX PARTITION ITERATOR     |             |300      |233 |
|12|     TABLE SCAN               |t2           |300      |233 |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  5 - output([t1.a]), filter(nil)
  6 - output([t1.a]), filter(nil), dop=1
  7 - output([t1.a]), filter(nil), 
      equal_conds([t2.c1 = t1.b]), other_conds(nil)
  8 - output([t1.a], [t1.b]), filter(nil)
  9 - (#keys=1, [t1.b]), output([t1.a], [t1.b]), filter(nil), is_single, dop=1
  10 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  11 - output([t2.c1]), filter(nil)
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
<<<<<<< HEAD
      LEADING(@"SEL$2" ("hint"."t1"@"SEL$2" "opt"."t2"@"SEL$2"))
      USE_HASH(@"SEL$2" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$2" "opt"."t2"@"SEL$2" PARTITION NONE)
      FULL(@"SEL$2" "hint"."t1"@"SEL$2")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$2" ("hint.t1"@"SEL$2" "opt.t2"@"SEL$2" ))
      USE_HASH(@"SEL$2" ("opt.t2"@"SEL$2" ))
      PQ_DISTRIBUTE(@"SEL$2" ("opt.t2"@"SEL$2" ) PARTITION NONE)
      FULL(@"SEL$2" "hint"."t1"@"SEL$2")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 37(end)  ************** 

***************   Case 38   ***************

SQL: select /*+ idex(yeti idx_t1_c2)*/ * from (select /*+ idex(opt.t4 idx_t4_c2))*/ * from hint.t1, opt.t4 where hint.t1.a = opt.t4.c2) as yeti, opt.t1 where yeti.a = opt.t1.c2; 

=============================================================
|ID|OPERATOR                |NAME            |EST. ROWS|COST|
-------------------------------------------------------------
|0 |HASH JOIN               |                |365      |850 |
|1 | MERGE JOIN             |                |91       |181 |
|2 |  TABLE SCAN            |t4(idx_t4_c2_c3)|100      |78  |
|3 |  TABLE SCAN            |t1              |100      |78  |
|4 | PX COORDINATOR         |                |500      |528 |
|5 |  EXCHANGE OUT DISTR    |:EX10000        |500      |481 |
|6 |   PX PARTITION ITERATOR|                |500      |387 |
|7 |    TABLE SCAN          |t1(idx_t1_c2)   |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t4.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.a = t4.c2]), other_conds(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  3 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("opt"."t4"@"SEL$2" "hint"."t1"@"SEL$2") "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      USE_MERGE(@"SEL$CFEA49FE" "hint"."t1"@"SEL$2")
      INDEX(@"SEL$CFEA49FE" "opt"."t4"@"SEL$2" "idx_t4_c2_c3")
      FULL(@"SEL$CFEA49FE" "hint"."t1"@"SEL$2")
      INDEX(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1" "idx_t1_c2")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("opt.t4"@"SEL$1" "hint.t1"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t1"@"SEL$1" ) LOCAL LOCAL)
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c2_c3")
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 38(end)  ************** 

***************   Case 39   ***************

SQL: select /*+ idex(ta idx_t1_c2)*/ * from (select /*+ idex(opt.t4 idx_t4_c2))*/ * from hint.t1, opt.t4 where hint.t1.a = opt.t4.c2) as yeti, opt.t1 as ta where yeti.a = ta.c2; 

=============================================================
|ID|OPERATOR                |NAME            |EST. ROWS|COST|
-------------------------------------------------------------
|0 |HASH JOIN               |                |365      |850 |
|1 | MERGE JOIN             |                |91       |181 |
|2 |  TABLE SCAN            |t4(idx_t4_c2_c3)|100      |78  |
|3 |  TABLE SCAN            |t1              |100      |78  |
|4 | PX COORDINATOR         |                |500      |528 |
|5 |  EXCHANGE OUT DISTR    |:EX10000        |500      |481 |
|6 |   PX PARTITION ITERATOR|                |500      |387 |
|7 |    TABLE SCAN          |ta(idx_t1_c2)   |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3], [ta.c1], [ta.c2]), filter(nil), 
      equal_conds([ta.c2 = t4.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.a = t4.c2]), other_conds(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  3 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  4 - output([ta.c1], [ta.c2]), filter(nil)
  5 - output([ta.c1], [ta.c2]), filter(nil), dop=1
  6 - output([ta.c1], [ta.c2]), filter(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("opt"."t4"@"SEL$2" "hint"."t1"@"SEL$2") "opt"."ta"@"SEL$1"))
      USE_HASH(@"SEL$CFEA49FE" "opt"."ta"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."ta"@"SEL$1" LOCAL LOCAL)
      USE_MERGE(@"SEL$CFEA49FE" "hint"."t1"@"SEL$2")
      INDEX(@"SEL$CFEA49FE" "opt"."t4"@"SEL$2" "idx_t4_c2_c3")
      FULL(@"SEL$CFEA49FE" "hint"."t1"@"SEL$2")
      INDEX(@"SEL$CFEA49FE" "opt"."ta"@"SEL$1" "idx_t1_c2")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("opt.t4"@"SEL$1" "hint.t1"@"SEL$1" )"opt.ta"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) LOCAL LOCAL)
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t1"@"SEL$1" ) LOCAL LOCAL)
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c2_c3")
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."ta"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 39(end)  ************** 

***************   Case 40   ***************

SQL: select /*+ idex(opt.t1 idx_t1_c2)*/ * from (select /*+ idex(opt.t4 idx_t4_c2))*/ * from hint.t1, opt.t4 where hint.t1.a = opt.t4.c2) as yeti, opt.t1 as ta where yeti.a = ta.c2; 

=============================================================
|ID|OPERATOR                |NAME            |EST. ROWS|COST|
-------------------------------------------------------------
|0 |HASH JOIN               |                |365      |850 |
|1 | MERGE JOIN             |                |91       |181 |
|2 |  TABLE SCAN            |t4(idx_t4_c2_c3)|100      |78  |
|3 |  TABLE SCAN            |t1              |100      |78  |
|4 | PX COORDINATOR         |                |500      |528 |
|5 |  EXCHANGE OUT DISTR    |:EX10000        |500      |481 |
|6 |   PX PARTITION ITERATOR|                |500      |387 |
|7 |    TABLE SCAN          |ta(idx_t1_c2)   |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3], [ta.c1], [ta.c2]), filter(nil), 
      equal_conds([ta.c2 = t4.c2]), other_conds(nil)
  1 - output([t1.a], [t1.b], [t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t1.a = t4.c2]), other_conds(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  3 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  4 - output([ta.c1], [ta.c2]), filter(nil)
  5 - output([ta.c1], [ta.c2]), filter(nil), dop=1
  6 - output([ta.c1], [ta.c2]), filter(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("opt"."t4"@"SEL$2" "hint"."t1"@"SEL$2") "opt"."ta"@"SEL$1"))
      USE_HASH(@"SEL$CFEA49FE" "opt"."ta"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."ta"@"SEL$1" LOCAL LOCAL)
      USE_MERGE(@"SEL$CFEA49FE" "hint"."t1"@"SEL$2")
      INDEX(@"SEL$CFEA49FE" "opt"."t4"@"SEL$2" "idx_t4_c2_c3")
      FULL(@"SEL$CFEA49FE" "hint"."t1"@"SEL$2")
      INDEX(@"SEL$CFEA49FE" "opt"."ta"@"SEL$1" "idx_t1_c2")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("opt.t4"@"SEL$1" "hint.t1"@"SEL$1" )"opt.ta"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) LOCAL LOCAL)
      USE_MERGE(@"SEL$1" ("hint.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t1"@"SEL$1" ) LOCAL LOCAL)
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c2_c3")
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."ta"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 40(end)  ************** 

***************   Case 41   ***************

SQL: select /*+ full(opt.t1)*/ * from opt.t1 as ta , opt.t2 as tb where ta.c1 = tb.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |ta      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |tb      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.c1, tb.c2, tb.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.c1, tb.c2, tb.c3)]), filter(nil), dop=1
  2 - output([ta.c1], [tb.c1], [ta.c2], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c1 = tb.c1]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil)
  4 - (#keys=1, [ta.c1]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  5 - output([ta.c1], [ta.c2]), filter(nil)
  6 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  7 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  8 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."ta"@"SEL$1" "opt"."tb"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."tb"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."tb"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "opt"."tb"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 41(end)  ************** 

***************   Case 42   ***************

SQL: select /*+ full(opt.t1 opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |270      |1321|
|1 | EXCHANGE OUT DISTR          |:EX10001|270      |1234|
|2 |  HASH JOIN                  |        |270      |1046|
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |300      |464 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |391 |
|7 |     PX PARTITION ITERATOR   |        |300      |233 |
|8 |      TABLE SCAN             |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2], [t1.c2], [t2.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  5 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil)
  6 - (#keys=1, [t2.c2]), output([t2.c2], [t2.c1], [t2.c3]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 42(end)  ************** 

***************   Case 43   ***************

SQL: select /*+ full(opt.t1 hint.t2)*/ * from opt.t1, hint.t2 where opt.t1.c1 = hint.t2.b; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |684 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |669 |
|2 |  HASH JOIN                  |        |90       |637 |
|3 |   EXCHANGE IN DISTR         |        |100      |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|5 |     TABLE SCAN              |t2      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.a, t2.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.a, t2.b)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.b], [t2.a], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.b]), other_conds(nil)
  3 - output([t2.b], [t2.a]), filter(nil)
  4 - (#keys=1, [t2.b]), output([t2.b], [t2.a]), filter(nil), is_single, dop=1
  5 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 43(end)  ************** 

***************   Case 44   ***************

SQL: select /*+ full(opt.t1) use_merge(ta)*/ * from opt.t1 as ta , opt.t2 as tb where ta.c1 = tb.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |ta      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |tb      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.c1, tb.c2, tb.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.c1, tb.c2, tb.c3)]), filter(nil), dop=1
  2 - output([ta.c1], [tb.c1], [ta.c2], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c1 = tb.c1]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil)
  4 - (#keys=1, [ta.c1]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  5 - output([ta.c1], [ta.c2]), filter(nil)
  6 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  7 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  8 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."ta"@"SEL$1" "opt"."tb"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."tb"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."tb"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "opt"."tb"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 44(end)  ************** 

***************   Case 45   ***************

SQL: select /*+ full(opt.ta) use_merge(ta)*/ * from opt.t1 as ta , opt.t2 as tb where ta.c1 = tb.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |ta      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |tb      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.c1, tb.c2, tb.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(ta.c1, ta.c2, tb.c1, tb.c2, tb.c3)]), filter(nil), dop=1
  2 - output([ta.c1], [tb.c1], [ta.c2], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c1 = tb.c1]), other_conds(nil)
  3 - output([ta.c1], [ta.c2]), filter(nil)
  4 - (#keys=1, [ta.c1]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  5 - output([ta.c1], [ta.c2]), filter(nil)
  6 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  7 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  8 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."ta"@"SEL$1" "opt"."tb"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."tb"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."tb"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "opt"."tb"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.tb"@"SEL$1" "opt.ta"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.ta"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.ta"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."tb"@"SEL$1")
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 45(end)  ************** 

***************   Case 46   ***************

SQL: select /*+ full(opt.t1 opt.t2) use_merge(opt.t1), use_nl(opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |270      |1523|
|1 | EXCHANGE OUT DISTR           |:EX10001|270      |1436|
|2 |  MERGE JOIN                  |        |270      |1248|
|3 |   SORT                       |        |300      |673 |
|4 |    EXCHANGE IN DISTR         |        |300      |464 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |391 |
|6 |      PX PARTITION ITERATOR   |        |300      |233 |
|7 |       TABLE SCAN             |t2      |300      |233 |
|8 |   SORT                       |        |500      |490 |
|9 |    PX PARTITION ITERATOR     |        |500      |387 |
|10|     TABLE SCAN               |t1      |500      |387 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2], [t2.c1], [t2.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), sort_keys([t2.c2, ASC])
  4 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c2], [t2.c1], [t2.c3]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  8 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  9 - output([t1.c1], [t1.c2]), filter(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_MERGE(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 46(end)  ************** 

***************   Case 47   ***************

SQL: select /*+ full(opt.t1 opt.t2) use_merge(opt.t1), use_bnl(opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |270      |1321|
|1 | EXCHANGE OUT DISTR          |:EX10001|270      |1234|
|2 |  HASH JOIN                  |        |270      |1046|
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |300      |464 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |391 |
|7 |     PX PARTITION ITERATOR   |        |300      |233 |
|8 |      TABLE SCAN             |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2], [t1.c2], [t2.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  5 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil)
  6 - (#keys=1, [t2.c2]), output([t2.c2], [t2.c1], [t2.c3]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 47(end)  ************** 

***************   Case 48   ***************

SQL: select /*+ full(opt.t1 hint.t2) use_merge(test), use_nl(opt.t1)*/ * from opt.t1, hint.t2 where opt.t1.c1 = hint.t2.b; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |687 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |671 |
|2 |  HASH JOIN                  |        |90       |639 |
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |100      |106 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|7 |     TABLE SCAN              |t2      |100      |78  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.a, t2.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.a, t2.b)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.b], [t1.c2], [t2.a]), filter(nil), 
      equal_conds([t1.c1 = t2.b]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  5 - output([t2.b], [t2.a]), filter(nil)
  6 - (#keys=1, [t2.b]), output([t2.b], [t2.a]), filter(nil), is_single, dop=1
  7 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "hint"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "hint"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."t2"@"SEL$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "hint.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t2"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 48(end)  ************** 

***************   Case 49   ***************

SQL: select /*+ full(opt.t1 hint.t2) use_merge(test), use_bnl(opt.t1)*/ * from opt.t1, hint.t2 where opt.t1.c1 = hint.t2.b; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |684 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |669 |
|2 |  HASH JOIN                  |        |90       |637 |
|3 |   EXCHANGE IN DISTR         |        |100      |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|5 |     TABLE SCAN              |t2      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.a, t2.b)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.a, t2.b)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.b], [t2.a], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.b]), other_conds(nil)
  3 - output([t2.b], [t2.a]), filter(nil)
  4 - (#keys=1, [t2.b]), output([t2.b], [t2.a]), filter(nil), is_single, dop=1
  5 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 49(end)  ************** 

***************   Case 50   ***************

SQL: select /*+ ordered use_merge(ta,tb,tc,td)*/ * from opt.t1 as ta, opt.t2 as tb , hint.t1 as tc, hint.t2 as td where ta.c1 = tc.a and ta.c2 = tb.c1 and tb.c1 = td.b; 

=====================================================================
|ID|OPERATOR                           |NAME         |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |MERGE JOIN                         |             |27       |2131|
|1 | SORT                              |             |90       |1983|
|2 |  MERGE JOIN                       |             |90       |1931|
|3 |   PX COORDINATOR MERGE SORT       |             |450      |1818|
|4 |    EXCHANGE OUT DISTR             |:EX10001     |450      |1674|
|5 |     SORT                          |             |450      |1359|
|6 |      MERGE JOIN                   |             |450      |1022|
|7 |       EXCHANGE IN MERGE SORT DISTR|             |500      |528 |
|8 |        EXCHANGE OUT DISTR (PKEY)  |:EX10000     |500      |481 |
|9 |         PX PARTITION ITERATOR     |             |500      |387 |
|10|          TABLE SCAN               |ta(idx_t1_c2)|500      |387 |
|11|       SORT                        |             |300      |299 |
|12|        PX PARTITION ITERATOR      |             |300      |233 |
|13|         TABLE SCAN                |tb           |300      |233 |
|14|   TABLE SCAN                      |tc           |100      |78  |
|15| SORT                              |             |100      |133 |
|16|  TABLE SCAN                       |td           |100      |78  |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b], [td.a], [td.b]), filter(nil), 
      equal_conds([tb.c1 = td.b]), other_conds(nil)
  1 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b]), filter(nil), sort_keys([tb.c1, ASC])
  2 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b]), filter(nil), 
      equal_conds([ta.c1 = tc.a]), other_conds(nil)
  3 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), sort_keys([ta.c1, ASC])
  4 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), dop=1
  5 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), sort_keys([ta.c1, ASC])
  6 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c2 = tb.c1]), other_conds(nil)
  7 - output([ta.c1], [ta.c2]), filter(nil), sort_keys([ta.c2, ASC]), Local Order
  8 - (#keys=1, [ta.c2]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  9 - output([ta.c1], [ta.c2]), filter(nil)
  10 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  11 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), sort_keys([tb.c1, ASC]), local merge sort
  12 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  13 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])
  14 - output([tc.a], [tc.b]), filter(nil), 
      access([tc.a], [tc.b]), partitions(p0)
  15 - output([td.a], [td.b]), filter(nil), sort_keys([td.b, ASC])
  16 - output([td.a], [td.b]), filter(nil), 
      access([td.a], [td.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ((("opt"."ta"@"SEL$1" "opt"."tb"@"SEL$1") "hint"."tc"@"SEL$1") "hint"."td"@"SEL$1"))
      USE_MERGE(@"SEL$1" "hint"."td"@"SEL$1")
      USE_MERGE(@"SEL$1" "hint"."tc"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."tc"@"SEL$1" LOCAL LOCAL)
      USE_MERGE(@"SEL$1" "opt"."tb"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."tb"@"SEL$1" PARTITION NONE)
=======
      LEADING(@"SEL$1" ((("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" )"hint.tc"@"SEL$1" )"hint.td"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.td"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.td"@"SEL$1" ) LOCAL LOCAL)
      USE_MERGE(@"SEL$1" ("hint.tc"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tc"@"SEL$1" ) LOCAL LOCAL)
      USE_MERGE(@"SEL$1" ("opt.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.tb"@"SEL$1" ) PARTITION NONE)
>>>>>>> implement spm part1
      INDEX(@"SEL$1" "opt"."ta"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "opt"."tb"@"SEL$1")
      FULL(@"SEL$1" "hint"."tc"@"SEL$1")
      FULL(@"SEL$1" "hint"."td"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 50(end)  ************** 

***************   Case 51   ***************

SQL: select /*+ ordered use_nl(ta tb tc td)*/ * from opt.t1 as ta, opt.t2 as tb , hint.t1 as tc, hint.t2 as td where ta.c1 = tc.a and ta.c2 = tb.c1 and tb.c1 = td.b; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |NESTED-LOOP JOIN               |             |27       |7567|
|1 | NESTED-LOOP JOIN              |             |90       |6761|
|2 |  PX COORDINATOR               |             |450      |4320|
|3 |   EXCHANGE OUT DISTR          |:EX10001     |450      |4176|
|4 |    NESTED-LOOP JOIN           |             |450      |3861|
|5 |     EXCHANGE IN DISTR         |             |500      |528 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000     |500      |481 |
|7 |       PX PARTITION ITERATOR   |             |500      |387 |
|8 |        TABLE SCAN             |ta(idx_t1_c2)|500      |387 |
|9 |     PX PARTITION ITERATOR     |             |1        |18  |
|10|      TABLE GET                |tb           |1        |18  |
|11|  TABLE GET                    |tc           |1        |5   |
|12| MATERIAL                      |             |100      |79  |
|13|  TABLE SCAN                   |td           |100      |78  |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b], [td.a], [td.b]), filter(nil), 
      conds([tb.c1 = td.b]), nl_params_(nil)
  1 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b]), filter(nil), 
      conds(nil), nl_params_([ta.c1])
  2 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil)
  3 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), dop=1
  4 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      conds(nil), nl_params_([ta.c2])
  5 - output([ta.c1], [ta.c2], [PARTITION_ID]), filter(nil)
  6 - (#keys=1, [ta.c2]), output([ta.c1], [ta.c2], [PARTITION_ID]), filter(nil), dop=1
  7 - output([ta.c1], [ta.c2]), filter(nil)
  8 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  9 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  10 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])
  11 - output([tc.a], [tc.b]), filter(nil), 
      access([tc.a], [tc.b]), partitions(p0)
  12 - output([td.a], [td.b]), filter(nil)
  13 - output([td.a], [td.b]), filter(nil), 
      access([td.a], [td.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ((("opt"."ta"@"SEL$1" "opt"."tb"@"SEL$1") "hint"."tc"@"SEL$1") "hint"."td"@"SEL$1"))
      USE_NL(@"SEL$1" "hint"."td"@"SEL$1")
      USE_NL_MATERIALIZATION(@"SEL$1" "hint"."td"@"SEL$1")
      USE_NL(@"SEL$1" "hint"."tc"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."tc"@"SEL$1" LOCAL LOCAL)
      USE_NL(@"SEL$1" "opt"."tb"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."tb"@"SEL$1" PARTITION NONE)
=======
      LEADING(@"SEL$1" ((("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" )"hint.tc"@"SEL$1" )"hint.td"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.td"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.td"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.td"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.tc"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tc"@"SEL$1" ) LOCAL LOCAL)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("hint.tc"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.tb"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.tb"@"SEL$1" ))
>>>>>>> implement spm part1
      INDEX(@"SEL$1" "opt"."ta"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "opt"."tb"@"SEL$1")
      FULL(@"SEL$1" "hint"."tc"@"SEL$1")
      FULL(@"SEL$1" "hint"."td"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 51(end)  ************** 

***************   Case 52   ***************

SQL: select /*+ ordered use_bnl(ta tb tc td)*/ * from opt.t1 as ta, opt.t2 as tb , hint.t1 as tc, hint.t2 as td where ta.c1 = tc.a and ta.c2 = tb.c1 and tb.c1 = td.b; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |HASH JOIN                      |        |27       |1760|
|1 | HASH JOIN                     |        |90       |1634|
|2 |  PX COORDINATOR               |        |450      |1413|
|3 |   EXCHANGE OUT DISTR          |:EX10001|450      |1269|
|4 |    HASH JOIN                  |        |450      |954 |
|5 |     EXCHANGE IN DISTR         |        |500      |528 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|7 |       PX PARTITION ITERATOR   |        |500      |387 |
|8 |        TABLE SCAN             |ta      |500      |387 |
|9 |     PX PARTITION ITERATOR     |        |300      |233 |
|10|      TABLE SCAN               |tb      |300      |233 |
|11|  TABLE SCAN                   |tc      |100      |78  |
|12| TABLE SCAN                    |td      |100      |78  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b], [td.a], [td.b]), filter(nil), 
      equal_conds([tb.c1 = td.b]), other_conds(nil)
  1 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b]), filter(nil), 
      equal_conds([ta.c1 = tc.a]), other_conds(nil)
  2 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil)
  3 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), dop=1
  4 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c2 = tb.c1]), other_conds(nil)
  5 - output([ta.c1], [ta.c2]), filter(nil)
  6 - (#keys=1, [ta.c2]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  7 - output([ta.c1], [ta.c2]), filter(nil)
  8 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  9 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  10 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])
  11 - output([tc.a], [tc.b]), filter(nil), 
      access([tc.a], [tc.b]), partitions(p0)
  12 - output([td.a], [td.b]), filter(nil), 
      access([td.a], [td.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ((("opt"."ta"@"SEL$1" "opt"."tb"@"SEL$1") "hint"."tc"@"SEL$1") "hint"."td"@"SEL$1"))
      USE_HASH(@"SEL$1" "hint"."td"@"SEL$1")
      USE_HASH(@"SEL$1" "hint"."tc"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."tc"@"SEL$1" LOCAL LOCAL)
      USE_HASH(@"SEL$1" "opt"."tb"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."tb"@"SEL$1" PARTITION NONE)
=======
      LEADING(@"SEL$1" ((("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" )"hint.tc"@"SEL$1" )"hint.td"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.td"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.td"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("hint.tc"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tc"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("opt.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.tb"@"SEL$1" ) PARTITION NONE)
>>>>>>> implement spm part1
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "opt"."tb"@"SEL$1")
      FULL(@"SEL$1" "hint"."tc"@"SEL$1")
      FULL(@"SEL$1" "hint"."td"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 52(end)  ************** 

***************   Case 53   ***************

SQL: select /*+ ordered*/ * from opt.t1 as ta, opt.t2 as tb , hint.t1 as tc, hint.t2 as td where ta.c1 = tc.a and ta.c2 = tb.c1 and tb.c1 = td.b; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |HASH JOIN                      |        |27       |1760|
|1 | HASH JOIN                     |        |90       |1634|
|2 |  PX COORDINATOR               |        |450      |1413|
|3 |   EXCHANGE OUT DISTR          |:EX10001|450      |1269|
|4 |    HASH JOIN                  |        |450      |954 |
|5 |     EXCHANGE IN DISTR         |        |500      |528 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|7 |       PX PARTITION ITERATOR   |        |500      |387 |
|8 |        TABLE SCAN             |ta      |500      |387 |
|9 |     PX PARTITION ITERATOR     |        |300      |233 |
|10|      TABLE SCAN               |tb      |300      |233 |
|11|  TABLE SCAN                   |tc      |100      |78  |
|12| TABLE SCAN                    |td      |100      |78  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b], [td.a], [td.b]), filter(nil), 
      equal_conds([tb.c1 = td.b]), other_conds(nil)
  1 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3], [tc.a], [tc.b]), filter(nil), 
      equal_conds([ta.c1 = tc.a]), other_conds(nil)
  2 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil)
  3 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), dop=1
  4 - output([ta.c1], [ta.c2], [tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      equal_conds([ta.c2 = tb.c1]), other_conds(nil)
  5 - output([ta.c1], [ta.c2]), filter(nil)
  6 - (#keys=1, [ta.c2]), output([ta.c1], [ta.c2]), filter(nil), dop=1
  7 - output([ta.c1], [ta.c2]), filter(nil)
  8 - output([ta.c1], [ta.c2]), filter(nil), 
      access([ta.c1], [ta.c2]), partitions(p[0-4])
  9 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil)
  10 - output([tb.c1], [tb.c2], [tb.c3]), filter(nil), 
      access([tb.c1], [tb.c2], [tb.c3]), partitions(p[0-2])
  11 - output([tc.a], [tc.b]), filter(nil), 
      access([tc.a], [tc.b]), partitions(p0)
  12 - output([td.a], [td.b]), filter(nil), 
      access([td.a], [td.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ((("opt"."ta"@"SEL$1" "opt"."tb"@"SEL$1") "hint"."tc"@"SEL$1") "hint"."td"@"SEL$1"))
      USE_HASH(@"SEL$1" "hint"."td"@"SEL$1")
      USE_HASH(@"SEL$1" "hint"."tc"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."tc"@"SEL$1" LOCAL LOCAL)
      USE_HASH(@"SEL$1" "opt"."tb"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."tb"@"SEL$1" PARTITION NONE)
=======
      LEADING(@"SEL$1" ((("opt.ta"@"SEL$1" "opt.tb"@"SEL$1" )"hint.tc"@"SEL$1" )"hint.td"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.td"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.td"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("hint.tc"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.tc"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("opt.tb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.tb"@"SEL$1" ) PARTITION NONE)
>>>>>>> implement spm part1
      FULL(@"SEL$1" "opt"."ta"@"SEL$1")
      FULL(@"SEL$1" "opt"."tb"@"SEL$1")
      FULL(@"SEL$1" "hint"."tc"@"SEL$1")
      FULL(@"SEL$1" "hint"."td"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 53(end)  ************** 

***************   Case 54   ***************

SQL: select /*+ leading(test, opt.t1 opt.t2) */ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 54(end)  ************** 

***************   Case 55   ***************

SQL: select /*+ leading(opt.t1 opt.t1 opt.t2) use_merge(opt.t1), use_nl(opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1301|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1205|
|2 |  MERGE JOIN                   |        |300      |995 |
|3 |   SORT                        |        |300      |299 |
|4 |    PX PARTITION ITERATOR      |        |300      |233 |
|5 |     TABLE SCAN                |t2      |300      |233 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |500      |528 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |481 |
|8 |     PX PARTITION ITERATOR     |        |500      |387 |
|9 |      TABLE SCAN               |t1      |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_MERGE(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 55(end)  ************** 

***************   Case 56   ***************

SQL: select /*+ leading(opt.t1 opt.t1 opt.t2) use_merge(opt.t1), use_bnl(opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 56(end)  ************** 

***************   Case 57   ***************

SQL: select /*+ leading(opt.t1 opt.t2) */ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 57(end)  ************** 

***************   Case 58   ***************

SQL: select /*+ leading(opt.t1 opt.t2 ha hb) */ * from opt.t1, opt.t2, hint.t1 as ha, hint.t2 as hb where opt.t1.c1 = opt.t2.c1 and opt.t1.c1 = ha.a and opt.t2.c2 = hb.b; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |HASH JOIN                      |        |49       |1559|
|1 | HASH JOIN                     |        |60       |1441|
|2 |  PX COORDINATOR               |        |300      |1260|
|3 |   EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|4 |    HASH JOIN                  |        |300      |954 |
|5 |     EXCHANGE IN DISTR         |        |500      |528 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|7 |       PX PARTITION ITERATOR   |        |500      |387 |
|8 |        TABLE SCAN             |t1      |500      |387 |
|9 |     PX PARTITION ITERATOR     |        |300      |233 |
|10|      TABLE SCAN               |t2      |300      |233 |
|11|  TABLE SCAN                   |ha      |100      |78  |
|12| TABLE SCAN                    |hb      |100      |78  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b], [hb.a], [hb.b]), filter(nil), 
      equal_conds([t2.c2 = hb.b]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b]), filter(nil), 
      equal_conds([t1.c1 = ha.a]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  11 - output([ha.a], [ha.b]), filter(nil), 
      access([ha.a], [ha.b]), partitions(p0)
  12 - output([hb.a], [hb.b]), filter(nil), 
      access([hb.a], [hb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ((("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1") "hint"."ha"@"SEL$1") "hint"."hb"@"SEL$1"))
      USE_HASH(@"SEL$1" "hint"."hb"@"SEL$1")
      USE_HASH(@"SEL$1" "hint"."ha"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."ha"@"SEL$1" LOCAL LOCAL)
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
=======
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"hint.ha"@"SEL$1" )"hint.hb"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.hb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.hb"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("hint.ha"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.ha"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
>>>>>>> implement spm part1
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "hint"."ha"@"SEL$1")
      FULL(@"SEL$1" "hint"."hb"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 58(end)  ************** 

***************   Case 59   ***************

SQL: select /*+ leading(opt.t1 opt.t2 ha hb) use_merge(opt.t1 ha) use_nl(opt.t1 hb)*/ * from opt.t1, opt.t2, hint.t1 as ha, hint.t2 as hb where opt.t1.c1 = opt.t2.c1 and opt.t1.c1 = ha.a and opt.t2.c2 = hb.b; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |NESTED-LOOP JOIN                |        |49       |2145|
|1 | MERGE JOIN                     |        |60       |1575|
|2 |  PX COORDINATOR MERGE SORT     |        |300      |1471|
|3 |   EXCHANGE OUT DISTR           |:EX10001|300      |1375|
|4 |    SORT                        |        |300      |1165|
|5 |     HASH JOIN                  |        |300      |954 |
|6 |      EXCHANGE IN DISTR         |        |500      |528 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|8 |        PX PARTITION ITERATOR   |        |500      |387 |
|9 |         TABLE SCAN             |t1      |500      |387 |
|10|      PX PARTITION ITERATOR     |        |300      |233 |
|11|       TABLE SCAN               |t2      |300      |233 |
|12|  TABLE SCAN                    |ha      |100      |78  |
|13| MATERIAL                       |        |100      |79  |
|14|  TABLE SCAN                    |hb      |100      |78  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b], [hb.a], [hb.b]), filter(nil), 
      conds([t2.c2 = hb.b]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b]), filter(nil), 
      equal_conds([t1.c1 = ha.a]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC])
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  12 - output([ha.a], [ha.b]), filter(nil), 
      access([ha.a], [ha.b]), partitions(p0)
  13 - output([hb.a], [hb.b]), filter(nil)
  14 - output([hb.a], [hb.b]), filter(nil), 
      access([hb.a], [hb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ((("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1") "hint"."ha"@"SEL$1") "hint"."hb"@"SEL$1"))
      USE_NL(@"SEL$1" "hint"."hb"@"SEL$1")
      USE_NL_MATERIALIZATION(@"SEL$1" "hint"."hb"@"SEL$1")
      USE_MERGE(@"SEL$1" "hint"."ha"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."ha"@"SEL$1" LOCAL LOCAL)
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
=======
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"hint.ha"@"SEL$1" )"hint.hb"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.hb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.hb"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("hint.hb"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("hint.ha"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.ha"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
>>>>>>> implement spm part1
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "hint"."ha"@"SEL$1")
      FULL(@"SEL$1" "hint"."hb"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 59(end)  ************** 

***************   Case 60   ***************

SQL: select /*+ leading(opt.t1 opt.t2 ha hb) use_merge(opt.t1 ha) use_bnl(opt.t1 hb)*/ * from opt.t1, opt.t2, hint.t1 as ha, hint.t2 as hb where opt.t1.c1 = opt.t2.c1 and opt.t1.c1 = ha.a and opt.t2.c2 = hb.b; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |HASH JOIN                       |        |49       |1693|
|1 | MERGE JOIN                     |        |60       |1575|
|2 |  PX COORDINATOR MERGE SORT     |        |300      |1471|
|3 |   EXCHANGE OUT DISTR           |:EX10001|300      |1375|
|4 |    SORT                        |        |300      |1165|
|5 |     HASH JOIN                  |        |300      |954 |
|6 |      EXCHANGE IN DISTR         |        |500      |528 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|8 |        PX PARTITION ITERATOR   |        |500      |387 |
|9 |         TABLE SCAN             |t1      |500      |387 |
|10|      PX PARTITION ITERATOR     |        |300      |233 |
|11|       TABLE SCAN               |t2      |300      |233 |
|12|  TABLE SCAN                    |ha      |100      |78  |
|13| TABLE SCAN                     |hb      |100      |78  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b], [hb.a], [hb.b]), filter(nil), 
      equal_conds([t2.c2 = hb.b]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b]), filter(nil), 
      equal_conds([t1.c1 = ha.a]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC])
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC])
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  12 - output([ha.a], [ha.b]), filter(nil), 
      access([ha.a], [ha.b]), partitions(p0)
  13 - output([hb.a], [hb.b]), filter(nil), 
      access([hb.a], [hb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ((("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1") "hint"."ha"@"SEL$1") "hint"."hb"@"SEL$1"))
      USE_HASH(@"SEL$1" "hint"."hb"@"SEL$1")
      USE_MERGE(@"SEL$1" "hint"."ha"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."ha"@"SEL$1" LOCAL LOCAL)
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
=======
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"hint.ha"@"SEL$1" )"hint.hb"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.hb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.hb"@"SEL$1" ) LOCAL LOCAL)
      USE_MERGE(@"SEL$1" ("hint.ha"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.ha"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
>>>>>>> implement spm part1
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "hint"."ha"@"SEL$1")
      FULL(@"SEL$1" "hint"."hb"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 60(end)  ************** 

***************   Case 61   ***************

SQL: select /*+ leading(test, opt.t1 opt.t2) use_merge(test opt.t1 opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1301|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1205|
|2 |  MERGE JOIN                   |        |300      |995 |
|3 |   SORT                        |        |300      |299 |
|4 |    PX PARTITION ITERATOR      |        |300      |233 |
|5 |     TABLE SCAN                |t2      |300      |233 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |500      |528 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |481 |
|8 |     PX PARTITION ITERATOR     |        |500      |387 |
|9 |      TABLE SCAN               |t1      |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_MERGE(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 61(end)  ************** 

***************   Case 62   ***************

SQL: select /*+ leading(test, opt.t1 opt.t2) use_merge(test opt.t1) use_nl(test opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |300      |1301|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1205|
|2 |  MERGE JOIN                   |        |300      |995 |
|3 |   SORT                        |        |300      |299 |
|4 |    PX PARTITION ITERATOR      |        |300      |233 |
|5 |     TABLE SCAN                |t2      |300      |233 |
|6 |   EXCHANGE IN MERGE SORT DISTR|        |500      |528 |
|7 |    EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |481 |
|8 |     PX PARTITION ITERATOR     |        |500      |387 |
|9 |      TABLE SCAN               |t1      |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_MERGE(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 62(end)  ************** 

***************   Case 63   ***************

SQL: select /*+ leading(test, opt.t1 opt.t2) use_merge(test opt.t1) use_bnl(test opt.t2)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 63(end)  ************** 

***************   Case 64   ***************

SQL: select /*+ leading(opt.t1 opt.t1 opt.t2) use_nl(opt.t1 opt.t3 opt.t5)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 64(end)  ************** 

***************   Case 65   ***************

SQL: select /*+ leading(opt.t1 opt.t1 opt.t2) use_bnl(opt.t1 opt.t3 opt.t5)*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 65(end)  ************** 

***************   Case 66   ***************

SQL: select /*+ leading(opt.t1 opt.t2) use_nl()*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 66(end)  ************** 

***************   Case 67   ***************

SQL: select /*+ leading(opt.t1 opt.t2) use_bnl()*/ * from opt.t1, opt.t2 where opt.t1.c1 = opt.t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 67(end)  ************** 

***************   Case 68   ***************

SQL: select /*+ leading(opt.t1 opt.t2 ha hb) use_nl(ta hint.t1 hint.t2 tb)*/ * from opt.t1, opt.t2, hint.t1 as ha, hint.t2 as hb where opt.t1.c1 = opt.t2.c1 and opt.t1.c1 = ha.a and opt.t2.c2 = hb.b; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |HASH JOIN                      |        |49       |1559|
|1 | HASH JOIN                     |        |60       |1441|
|2 |  PX COORDINATOR               |        |300      |1260|
|3 |   EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|4 |    HASH JOIN                  |        |300      |954 |
|5 |     EXCHANGE IN DISTR         |        |500      |528 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|7 |       PX PARTITION ITERATOR   |        |500      |387 |
|8 |        TABLE SCAN             |t1      |500      |387 |
|9 |     PX PARTITION ITERATOR     |        |300      |233 |
|10|      TABLE SCAN               |t2      |300      |233 |
|11|  TABLE SCAN                   |ha      |100      |78  |
|12| TABLE SCAN                    |hb      |100      |78  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b], [hb.a], [hb.b]), filter(nil), 
      equal_conds([t2.c2 = hb.b]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b]), filter(nil), 
      equal_conds([t1.c1 = ha.a]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  11 - output([ha.a], [ha.b]), filter(nil), 
      access([ha.a], [ha.b]), partitions(p0)
  12 - output([hb.a], [hb.b]), filter(nil), 
      access([hb.a], [hb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ((("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1") "hint"."ha"@"SEL$1") "hint"."hb"@"SEL$1"))
      USE_HASH(@"SEL$1" "hint"."hb"@"SEL$1")
      USE_HASH(@"SEL$1" "hint"."ha"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."ha"@"SEL$1" LOCAL LOCAL)
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
=======
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"hint.ha"@"SEL$1" )"hint.hb"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.hb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.hb"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("hint.ha"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.ha"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
>>>>>>> implement spm part1
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "hint"."ha"@"SEL$1")
      FULL(@"SEL$1" "hint"."hb"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 68(end)  ************** 

***************   Case 69   ***************

SQL: select /*+ leading(opt.t1 opt.t2 ha hb) use_bnl(ta hint.t1 hint.t2 tb)*/ * from opt.t1, opt.t2, hint.t1 as ha, hint.t2 as hb where opt.t1.c1 = opt.t2.c1 and opt.t1.c1 = ha.a and opt.t2.c2 = hb.b; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |HASH JOIN                      |        |49       |1559|
|1 | HASH JOIN                     |        |60       |1441|
|2 |  PX COORDINATOR               |        |300      |1260|
|3 |   EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|4 |    HASH JOIN                  |        |300      |954 |
|5 |     EXCHANGE IN DISTR         |        |500      |528 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|7 |       PX PARTITION ITERATOR   |        |500      |387 |
|8 |        TABLE SCAN             |t1      |500      |387 |
|9 |     PX PARTITION ITERATOR     |        |300      |233 |
|10|      TABLE SCAN               |t2      |300      |233 |
|11|  TABLE SCAN                   |ha      |100      |78  |
|12| TABLE SCAN                    |hb      |100      |78  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b], [hb.a], [hb.b]), filter(nil), 
      equal_conds([t2.c2 = hb.b]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [ha.a], [ha.b]), filter(nil), 
      equal_conds([t1.c1 = ha.a]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])
  11 - output([ha.a], [ha.b]), filter(nil), 
      access([ha.a], [ha.b]), partitions(p0)
  12 - output([hb.a], [hb.b]), filter(nil), 
      access([hb.a], [hb.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ((("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1") "hint"."ha"@"SEL$1") "hint"."hb"@"SEL$1"))
      USE_HASH(@"SEL$1" "hint"."hb"@"SEL$1")
      USE_HASH(@"SEL$1" "hint"."ha"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "hint"."ha"@"SEL$1" LOCAL LOCAL)
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
=======
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"hint.ha"@"SEL$1" )"hint.hb"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("hint.hb"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.hb"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("hint.ha"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.ha"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
>>>>>>> implement spm part1
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "hint"."ha"@"SEL$1")
      FULL(@"SEL$1" "hint"."hb"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 69(end)  ************** 

***************   Case 70   ***************

SQL: select t1.c1, v.c1 from t1, (select t2.c1 from t2, t4) v; 

===============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST  |
---------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |             |15000000 |776917|
|1 | NESTED-LOOP JOIN CARTESIAN|             |30000    |2938  |
|2 |  TABLE SCAN               |t4(idx_t4_c2)|100      |78    |
|3 |  MATERIAL                 |             |300      |281   |
|4 |   PX COORDINATOR          |             |300      |280   |
|5 |    EXCHANGE OUT DISTR     |:EX10000     |300      |263   |
|6 |     PX PARTITION ITERATOR |             |300      |233   |
|7 |      TABLE SCAN           |t2           |300      |233   |
|8 | MATERIAL                  |             |500      |468   |
|9 |  PX COORDINATOR           |             |500      |466   |
|10|   EXCHANGE OUT DISTR      |:EX20000     |500      |439   |
|11|    PX PARTITION ITERATOR  |             |500      |387   |
|12|     TABLE SCAN            |t1           |500      |387   |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output(nil), filter(nil), 
      access([t4.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil)
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter(nil), dop=1
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), dop=1
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("opt"."t4"@"SEL$2" "opt"."t2"@"SEL$2") "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      USE_NL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      INDEX(@"SEL$CFEA49FE" "opt"."t4"@"SEL$2" "idx_t4_c2")
      FULL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      FULL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("opt.t4"@"SEL$1" "opt.t2"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c2")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 70(end)  ************** 

***************   Case 71   ***************

SQL: select t1.c1, v.c1 from t1, (select/*+index(t4 primary)*/ t2.c1 from t2, t4) v; 

==========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST  |
----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |15000000 |776917|
|1 | NESTED-LOOP JOIN CARTESIAN|        |30000    |2938  |
|2 |  TABLE SCAN               |t4      |100      |78    |
|3 |  MATERIAL                 |        |300      |281   |
|4 |   PX COORDINATOR          |        |300      |280   |
|5 |    EXCHANGE OUT DISTR     |:EX10000|300      |263   |
|6 |     PX PARTITION ITERATOR |        |300      |233   |
|7 |      TABLE SCAN           |t2      |300      |233   |
|8 | MATERIAL                  |        |500      |468   |
|9 |  PX COORDINATOR           |        |500      |466   |
|10|   EXCHANGE OUT DISTR      |:EX20000|500      |439   |
|11|    PX PARTITION ITERATOR  |        |500      |387   |
|12|     TABLE SCAN            |t1      |500      |387   |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output(nil), filter(nil), 
      access([t4.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil)
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter(nil), dop=1
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), dop=1
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("opt"."t4"@"SEL$2" "opt"."t2"@"SEL$2") "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      USE_NL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      FULL(@"SEL$CFEA49FE" "opt"."t4"@"SEL$2")
      FULL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      FULL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("opt.t4"@"SEL$1" "opt.t2"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 71(end)  ************** 

***************   Case 72   ***************

SQL: select/*+no_rewrite*/ t1.c1, v.c1 from t1, (select/*+index(t4 primary)*/ t2.c1 from t2, t4) v; 

===========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST  |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |        |15000000 |777442|
|1 | SUBPLAN SCAN               |v       |30000    |3464  |
|2 |  NESTED-LOOP JOIN CARTESIAN|        |30000    |2938  |
|3 |   TABLE SCAN               |t4      |100      |78    |
|4 |   MATERIAL                 |        |300      |281   |
|5 |    PX COORDINATOR          |        |300      |280   |
|6 |     EXCHANGE OUT DISTR     |:EX10000|300      |263   |
|7 |      PX PARTITION ITERATOR |        |300      |233   |
|8 |       TABLE SCAN           |t2      |300      |233   |
|9 | MATERIAL                   |        |500      |468   |
|10|  PX COORDINATOR            |        |500      |466   |
|11|   EXCHANGE OUT DISTR       |:EX20000|500      |439   |
|12|    PX PARTITION ITERATOR   |        |500      |387   |
|13|     TABLE SCAN             |t1      |500      |387   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [v.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([v.c1]), filter(nil), 
      access([v.c1])
  2 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  3 - output(nil), filter(nil), 
      access([t4.c1]), partitions(p0)
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter(nil)
  6 - output([t2.c1]), filter(nil), dop=1
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), dop=1
  12 - output([t1.c1]), filter(nil)
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("v"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" "opt"."t1"@"SEL$1")
      LEADING(@"SEL$2" ("opt"."t4"@"SEL$2" "opt"."t2"@"SEL$2"))
      USE_NL(@"SEL$2" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$2" "opt"."t2"@"SEL$2" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$2" "opt"."t2"@"SEL$2")
      FULL(@"SEL$2" "opt"."t4"@"SEL$2")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("v"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      LEADING(@"SEL$2" ("opt.t4"@"SEL$2" "opt.t2"@"SEL$2" ))
      USE_NL(@"SEL$2" ("opt.t2"@"SEL$2" ))
      PQ_DISTRIBUTE(@"SEL$2" ("opt.t2"@"SEL$2" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$2" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$2" "opt"."t4"@"SEL$2")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      NO_REWRITE
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 72(end)  ************** 

***************   Case 73   ***************

SQL: select t1.c1, v.c1 from t1, (select/*+leading(t2)*/ t2.c1 from t2, t4) v; 

===============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST  |
---------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |             |15000000 |782073|
|1 | NESTED-LOOP JOIN CARTESIAN|             |30000    |8095  |
|2 |  PX COORDINATOR           |             |300      |280   |
|3 |   EXCHANGE OUT DISTR      |:EX10000     |300      |263   |
|4 |    PX PARTITION ITERATOR  |             |300      |233   |
|5 |     TABLE SCAN            |t2           |300      |233   |
|6 |  MATERIAL                 |             |100      |78    |
|7 |   TABLE SCAN              |t4(idx_t4_c2)|100      |78    |
|8 | MATERIAL                  |             |500      |468   |
|9 |  PX COORDINATOR           |             |500      |466   |
|10|   EXCHANGE OUT DISTR      |:EX20000     |500      |439   |
|11|    PX PARTITION ITERATOR  |             |500      |387   |
|12|     TABLE SCAN            |t1           |500      |387   |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1]), filter(nil)
  3 - output([t2.c1]), filter(nil), dop=1
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  6 - output(nil), filter(nil)
  7 - output(nil), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), dop=1
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("opt"."t2"@"SEL$2" "opt"."t4"@"SEL$2") "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      USE_NL(@"SEL$CFEA49FE" "opt"."t4"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t4"@"SEL$2" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t4"@"SEL$2")
      FULL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      INDEX(@"SEL$CFEA49FE" "opt"."t4"@"SEL$2" "idx_t4_c2")
      FULL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("opt.t2"@"SEL$1" "opt.t4"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t4"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t4"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t4"@"SEL$1" ))
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c2")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 73(end)  ************** 

***************   Case 74   ***************

SQL: select t1.c1, v.c1 from t1, (select/*+read_consistency(weak)*/ t2.c1 from t2, t4) v; 

===============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST  |
---------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |             |15000000 |776917|
|1 | NESTED-LOOP JOIN CARTESIAN|             |30000    |2938  |
|2 |  TABLE SCAN               |t4(idx_t4_c2)|100      |78    |
|3 |  MATERIAL                 |             |300      |281   |
|4 |   PX COORDINATOR          |             |300      |280   |
|5 |    EXCHANGE OUT DISTR     |:EX10000     |300      |263   |
|6 |     PX PARTITION ITERATOR |             |300      |233   |
|7 |      TABLE SCAN           |t2           |300      |233   |
|8 | MATERIAL                  |             |500      |468   |
|9 |  PX COORDINATOR           |             |500      |466   |
|10|   EXCHANGE OUT DISTR      |:EX20000     |500      |439   |
|11|    PX PARTITION ITERATOR  |             |500      |387   |
|12|     TABLE SCAN            |t1           |500      |387   |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output(nil), filter(nil), 
      access([t4.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil)
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter(nil), dop=1
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil), dop=1
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("opt"."t4"@"SEL$2" "opt"."t2"@"SEL$2") "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      USE_NL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      INDEX(@"SEL$CFEA49FE" "opt"."t4"@"SEL$2" "idx_t4_c2")
      FULL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      FULL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      MERGE(@"SEL$2" > "SEL$1")
      READ_CONSISTENCY( WEAK )
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("opt.t4"@"SEL$1" "opt.t2"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c2")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      READ_CONSISTENCY("WEAK")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 74(end)  ************** 

***************   Case 75   ***************

SQL: select t1.c1, v.c1 from t1, (select/*+use_nl(t2, t4)*/ t2.c1 from t2, t4 where t2.c1 = t4.c1) v; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN    |        |45000    |3574|
|1 | PX COORDINATOR               |        |90       |786 |
|2 |  EXCHANGE OUT DISTR          |:EX10001|90       |777 |
|3 |   NESTED-LOOP JOIN           |        |90       |760 |
|4 |    EXCHANGE IN DISTR         |        |100      |94  |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|6 |      TABLE SCAN              |t4      |100      |78  |
|7 |    PX PARTITION ITERATOR     |        |1        |18  |
|8 |     TABLE GET                |t2      |1        |18  |
|9 | MATERIAL                     |        |500      |468 |
|10|  PX COORDINATOR              |        |500      |466 |
|11|   EXCHANGE OUT DISTR         |:EX20000|500      |439 |
|12|    PX PARTITION ITERATOR     |        |500      |387 |
|13|     TABLE SCAN               |t1      |500      |387 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil)
  2 - output([t2.c1]), filter(nil), dop=1
  3 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  4 - output([PARTITION_ID], [t4.c1]), filter(nil)
  5 - (#keys=1, [t4.c1]), output([PARTITION_ID], [t4.c1]), filter(nil), is_single, dop=1
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  9 - output([t1.c1]), filter(nil)
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), dop=1
  12 - output([t1.c1]), filter(nil)
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$CFEA49FE" (("opt"."t4"@"SEL$2" "opt"."t2"@"SEL$2") "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      USE_NL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2" PARTITION NONE)
      FULL(@"SEL$CFEA49FE" "opt"."t4"@"SEL$2")
      FULL(@"SEL$CFEA49FE" "opt"."t2"@"SEL$2")
      FULL(@"SEL$CFEA49FE" "opt"."t1"@"SEL$1")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" (("opt.t4"@"SEL$1" "opt.t2"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 75(end)  ************** 

***************   Case 76   ***************

SQL: (select /*+read_consistency(weak)*/ c1 from t1) union (select c1 from t2); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |800      |1152|
|1 | EXCHANGE OUT DISTR          |:EX10001|800      |1108|
|2 |  HASH UNION DISTINCT        |        |800      |1025|
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |300      |280 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|7 |     PX PARTITION ITERATOR   |        |300      |233 |
|8 |      TABLE SCAN             |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  5 - output([t2.c1]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      USE_HASH_SET(@"SET$1")
      PQ_SET(@"SET$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
      READ_CONSISTENCY( WEAK )
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
      READ_CONSISTENCY("WEAK")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 76(end)  ************** 

***************   Case 77   ***************

SQL: (select /*+read_consistency(weak)*/ c1 from t1) union (select /*+read_consistency(strong)*/ c1 from t2); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |800      |1152|
|1 | EXCHANGE OUT DISTR          |:EX10001|800      |1108|
|2 |  HASH UNION DISTINCT        |        |800      |1025|
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |300      |280 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|7 |     PX PARTITION ITERATOR   |        |300      |233 |
|8 |      TABLE SCAN             |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  5 - output([t2.c1]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      USE_HASH_SET(@"SET$1")
      PQ_SET(@"SET$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
      READ_CONSISTENCY( WEAK )
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 77(end)  ************** 

***************   Case 78   ***************

SQL: select * from opt.t1 ignore index (primary); 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |500      |481 |
|2 |  PX PARTITION ITERATOR|             |500      |387 |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 78(end)  ************** 

***************   Case 79   ***************

SQL: select /*+ index(@a0123456789012345678 t4@a0123456789012345678 idx_t4_c3)*/ * from t1 where c1 in (select/*+qb_name(a0123456789012345678)*/ c1 from t4); 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR               |             |10       |176 |
|1 | EXCHANGE OUT DISTR          |:EX10001     |10       |175 |
|2 |  NESTED-LOOP JOIN           |             |10       |172 |
|3 |   EXCHANGE IN DISTR         |             |10       |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000     |10       |105 |
|5 |     SUBPLAN SCAN            |VIEW2        |10       |104 |
|6 |      HASH DISTINCT          |             |10       |104 |
|7 |       TABLE SCAN            |t4(idx_t4_c3)|100      |78  |
|8 |   PX PARTITION ITERATOR     |             |1        |29  |
|9 |    TABLE GET                |t1           |1        |29  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  3 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  6 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$229D0D08" ("VIEW2"@"SEL$0BA0FCD5" "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$229D0D08" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$229D0D08" "opt"."t1"@"SEL$1" PARTITION NONE)
      USE_HASH_DISTINCT(@"SEL$97DDBBDC")
      INDEX(@"SEL$97DDBBDC" "opt"."t4"@"A0123456789012345678" "idx_t4_c3")
      FULL(@"SEL$229D0D08" "opt"."t1"@"SEL$1")
      UNNEST(@"A0123456789012345678")
      SEMI_TO_INNER(@"SEL$0BA0FCD5" "VIEW1")
      MERGE(@"A0123456789012345678" < "SEL$BC75C441")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("VIEW2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      INDEX(@"SEL$2" "opt"."t4"@"SEL$2" "idx_t4_c3")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 79(end)  ************** 

***************   Case 80   ***************

SQL: select /*+ index(@a01234567890123456789 t4@a01234567890123456789 idx_t4_c3)*/ * from t1 where c1 in (select/*+qb_name(a01234567890123456789)*/ c1 from t4); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |10       |154 |
|1 | EXCHANGE OUT DISTR          |:EX10001|10       |153 |
|2 |  NESTED-LOOP JOIN           |        |10       |150 |
|3 |   EXCHANGE IN DISTR         |        |10       |84  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|10       |83  |
|5 |     SUBPLAN SCAN            |VIEW2   |10       |82  |
|6 |      MERGE DISTINCT         |        |10       |82  |
|7 |       TABLE SCAN            |t4      |100      |78  |
|8 |   PX PARTITION ITERATOR     |        |1        |29  |
|9 |    TABLE GET                |t1      |1        |29  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  3 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  6 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$E5385516" ("VIEW2"@"SEL$6FCAE2AA" "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$E5385516" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$E5385516" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$8A1445BC" "opt"."t4"@"SEL$2")
      FULL(@"SEL$E5385516" "opt"."t1"@"SEL$1")
      UNNEST(@"SEL$2")
      SEMI_TO_INNER(@"SEL$6FCAE2AA" "VIEW1")
      MERGE(@"SEL$2" < "SEL$7BD09C5F")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("VIEW2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$2" "opt"."t4"@"SEL$2")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 80(end)  ************** 

***************   Case 81   ***************

SQL: select /*+ index(@SEL$1 t4  idx_t4_c3)*/ * from t1 where c1 in (select/*+qb_name(yz)*/ c1 from t4); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |10       |154 |
|1 | EXCHANGE OUT DISTR          |:EX10001|10       |153 |
|2 |  NESTED-LOOP JOIN           |        |10       |150 |
|3 |   EXCHANGE IN DISTR         |        |10       |84  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|10       |83  |
|5 |     SUBPLAN SCAN            |VIEW2   |10       |82  |
|6 |      MERGE DISTINCT         |        |10       |82  |
|7 |       TABLE SCAN            |t4      |100      |78  |
|8 |   PX PARTITION ITERATOR     |        |1        |29  |
|9 |    TABLE GET                |t1      |1        |29  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  3 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  6 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$28655DBE" ("VIEW2"@"SEL$8623AD9A" "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$28655DBE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$28655DBE" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$ECCDB03E" "opt"."t4"@"YZ")
      FULL(@"SEL$28655DBE" "opt"."t1"@"SEL$1")
      UNNEST(@"YZ")
      SEMI_TO_INNER(@"SEL$8623AD9A" "VIEW1")
      MERGE(@"YZ" < "SEL$B68D94F7")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("VIEW2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$2" "opt"."t4"@"SEL$2")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 81(end)  ************** 

***************   Case 82   ***************

SQL: select /*+ leading(@SEL$1 t4  t1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |660 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |649 |
|2 |  HASH JOIN                  |        |90       |624 |
|3 |   EXCHANGE IN DISTR         |        |100      |94  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|5 |     TABLE SCAN              |t4      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil), dop=1
  2 - output([t4.c1], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t4.c1]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$260306CE" ("opt"."t4"@"YZ" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$260306CE" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$260306CE" "opt"."t4"@"YZ")
      FULL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      MERGE(@"YZ" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 82(end)  ************** 

***************   Case 83   ***************

SQL: select /*+ leading(@SEL$1 t1  t4)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |663 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |652 |
|2 |  HASH JOIN                  |        |90       |627 |
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |100      |94  |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|7 |     TABLE SCAN              |t4      |100      |78  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil), dop=1
  2 - output([t4.c1], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  5 - output([t4.c1]), filter(nil)
  6 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$260306CE" ("opt"."t1"@"SEL$1" "opt"."t4"@"YZ"))
      USE_HASH(@"SEL$260306CE" "opt"."t4"@"YZ")
      PQ_DISTRIBUTE(@"SEL$260306CE" "opt"."t4"@"YZ" NONE PARTITION)
      FULL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$260306CE" "opt"."t4"@"YZ")
      MERGE(@"YZ" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t4"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t4"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t4"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 83(end)  ************** 

***************   Case 84   ***************

SQL: select /*+ leading(@SEL$1 t1@SEL$1  t4@YZ)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |663 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |652 |
|2 |  HASH JOIN                  |        |90       |627 |
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |100      |94  |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|7 |     TABLE SCAN              |t4      |100      |78  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil), dop=1
  2 - output([t4.c1], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  5 - output([t4.c1]), filter(nil)
  6 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$260306CE" ("opt"."t1"@"SEL$1" "opt"."t4"@"YZ"))
      USE_HASH(@"SEL$260306CE" "opt"."t4"@"YZ")
      PQ_DISTRIBUTE(@"SEL$260306CE" "opt"."t4"@"YZ" NONE PARTITION)
      FULL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$260306CE" "opt"."t4"@"YZ")
      MERGE(@"YZ" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t4"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t4"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t4"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 84(end)  ************** 

***************   Case 85   ***************

SQL: select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |660 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |649 |
|2 |  HASH JOIN                  |        |90       |624 |
|3 |   EXCHANGE IN DISTR         |        |100      |94  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|5 |     TABLE SCAN              |t4      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil), dop=1
  2 - output([t4.c1], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t4.c1]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$260306CE" ("opt"."t4"@"YZ" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$260306CE" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$260306CE" "opt"."t4"@"YZ")
      FULL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      MERGE(@"YZ" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 85(end)  ************** 

***************   Case 86   ***************

SQL: select /*+ leading(@SEL$1 t_a@YZ  t1@SEL$1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4 t_a) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |660 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |649 |
|2 |  HASH JOIN                  |        |90       |624 |
|3 |   EXCHANGE IN DISTR         |        |100      |94  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|5 |     TABLE SCAN              |t_a     |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t_a.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t_a.c1)]), filter(nil), dop=1
  2 - output([t_a.c1], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t_a.c1 = t1.c1]), other_conds(nil)
  3 - output([t_a.c1]), filter(nil)
  4 - (#keys=1, [t_a.c1]), output([t_a.c1]), filter(nil), is_single, dop=1
  5 - output([t_a.c1]), filter(nil), 
      access([t_a.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$260306CE" ("opt"."t_a"@"YZ" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$260306CE" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$260306CE" "opt"."t_a"@"YZ")
      FULL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      MERGE(@"YZ" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t_a"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t_a"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 86(end)  ************** 

***************   Case 87   ***************

SQL: select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4 t_a) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |660 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |649 |
|2 |  HASH JOIN                  |        |90       |624 |
|3 |   EXCHANGE IN DISTR         |        |100      |94  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|5 |     TABLE SCAN              |t_a     |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t_a.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t_a.c1)]), filter(nil), dop=1
  2 - output([t_a.c1], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t_a.c1 = t1.c1]), other_conds(nil)
  3 - output([t_a.c1]), filter(nil)
  4 - (#keys=1, [t_a.c1]), output([t_a.c1]), filter(nil), is_single, dop=1
  5 - output([t_a.c1]), filter(nil), 
      access([t_a.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$260306CE" ("opt"."t_a"@"YZ" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$260306CE" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$260306CE" "opt"."t_a"@"YZ")
      FULL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      MERGE(@"YZ" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t_a"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t_a"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 87(end)  ************** 

***************   Case 88   ***************

SQL: select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1) use_nl(@SEL$1 t1@SEL$1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |794 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |782 |
|2 |  NESTED-LOOP JOIN           |        |90       |757 |
|3 |   EXCHANGE IN DISTR         |        |100      |94  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|5 |     TABLE SCAN              |t4      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |1        |29  |
|7 |    TABLE GET                |t1      |1        |29  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil), dop=1
  2 - output([t4.c1], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t4.c1])
  3 - output([t4.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1], [PARTITION_ID]), filter(nil), is_single, dop=1
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$260306CE" ("opt"."t4"@"YZ" "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$260306CE" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$260306CE" "opt"."t4"@"YZ")
      FULL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      MERGE(@"YZ" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 88(end)  ************** 

***************   Case 89   ***************

SQL: select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1) use_bnl(@SEL$1 t1@SEL$1)*/ * from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |660 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |649 |
|2 |  HASH JOIN                  |        |90       |624 |
|3 |   EXCHANGE IN DISTR         |        |100      |94  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|5 |     TABLE SCAN              |t4      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil), dop=1
  2 - output([t4.c1], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t4.c1]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$260306CE" ("opt"."t4"@"YZ" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$260306CE" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$260306CE" "opt"."t4"@"YZ")
      FULL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      MERGE(@"YZ" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 89(end)  ************** 

***************   Case 90   ***************

SQL: select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1) */ * from t1 , (select/*+qb_name(yz) use_merge(@SEL$1 t1@SEL$1)*/ c1 from t4) t where t.c1 = t1.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |655 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |643 |
|2 |  MERGE JOIN                 |        |90       |619 |
|3 |   EXCHANGE IN DISTR         |        |100      |94  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|5 |     TABLE SCAN              |t4      |100      |78  |
|6 |   SORT                      |        |500      |490 |
|7 |    PX PARTITION ITERATOR    |        |500      |387 |
|8 |     TABLE SCAN              |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t4.c1)]), filter(nil), dop=1
  2 - output([t4.c1], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  3 - output([t4.c1]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  5 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$260306CE" ("opt"."t4"@"YZ" "opt"."t1"@"SEL$1"))
      USE_MERGE(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$260306CE" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$260306CE" "opt"."t4"@"YZ")
      FULL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      MERGE(@"YZ" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 90(end)  ************** 

***************   Case 91   ***************

SQL: select c1 from t1 union select /*+index(@SEL$1 t1 idx_t1_c2)*/ c1 from t2; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR               |             |800      |1152|
|1 | EXCHANGE OUT DISTR          |:EX10001     |800      |1108|
|2 |  HASH UNION DISTINCT        |             |800      |1025|
|3 |   PX PARTITION ITERATOR     |             |500      |387 |
|4 |    TABLE SCAN               |t1(idx_t1_c2)|500      |387 |
|5 |   EXCHANGE IN DISTR         |             |300      |280 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000     |300      |263 |
|7 |     PX PARTITION ITERATOR   |             |300      |233 |
|8 |      TABLE SCAN             |t2           |300      |233 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  5 - output([t2.c1]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      USE_HASH_SET(@"SET$1")
      PQ_SET(@"SET$1" NONE PARTITION)
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 91(end)  ************** 

***************   Case 92   ***************

SQL: select t1.c1 from t1, t2 where t1.c1 = t2.c1 union select/*+leading(@SEL$1 t1 t2) use_merge(@SEL1 t2@SEL$1)*/ c1 from t2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |600      |1562|
|1 | EXCHANGE OUT DISTR           |:EX10001|600      |1506|
|2 |  HASH UNION DISTINCT         |        |600      |1393|
|3 |   HASH JOIN                  |        |300      |891 |
|4 |    EXCHANGE IN DISTR         |        |500      |466 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |439 |
|6 |      PX PARTITION ITERATOR   |        |500      |387 |
|7 |       TABLE SCAN             |t1      |500      |387 |
|8 |    PX PARTITION ITERATOR     |        |300      |233 |
|9 |     TABLE SCAN               |t2      |300      |233 |
|10|   PX PARTITION ITERATOR      |        |300      |233 |
|11|    TABLE SCAN                |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1]), filter(nil)
  5 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      USE_HASH_SET(@"SET$1")
      PQ_SET(@"SET$1" NONE)
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 92(end)  ************** 

***************   Case 93   ***************

SQL: select/*+leading(@SEL$1 t2 t1)*/ t1.c1 from t1, t2 where t1.c1 = t2.c1 union select/*+leading(@SEL$1 t1 t2) use_merge(@SEL1 t2@SEL$1)*/ c1 from t2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |600      |1561|
|1 | EXCHANGE OUT DISTR           |:EX10001|600      |1505|
|2 |  HASH UNION DISTINCT         |        |600      |1393|
|3 |   HASH JOIN                  |        |300      |890 |
|4 |    PX PARTITION ITERATOR     |        |300      |233 |
|5 |     TABLE SCAN               |t2      |300      |233 |
|6 |    EXCHANGE IN DISTR         |        |500      |466 |
|7 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |439 |
|8 |      PX PARTITION ITERATOR   |        |500      |387 |
|9 |       TABLE SCAN             |t1      |500      |387 |
|10|   PX PARTITION ITERATOR      |        |300      |233 |
|11|    TABLE SCAN                |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t2.c1]), filter(nil)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])
  6 - output([t1.c1]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil)
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      USE_HASH_SET(@"SET$1")
      PQ_SET(@"SET$1" NONE)
      LEADING(@"SEL$1" ("opt"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$2" "opt"."t2"@"SEL$2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 93(end)  ************** 

***************   Case 94   ***************

SQL: (select /*+ leading(@SEL$1 t4@YZ  t1@SEL$1) */ t1.c1 from t1 , (select/*+qb_name(yz) use_merge(@SEL$1 t1@SEL$1)*/ c1 from t4) t where t.c1 = t1.c1) union select c1 from t3; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |290      |1007|
|1 | EXCHANGE OUT DISTR             |:EX10002|290      |980 |
|2 |  HASH UNION DISTINCT           |        |290      |925 |
|3 |   EXCHANGE IN DISTR            |        |90       |640 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|90       |632 |
|5 |     MERGE JOIN                 |        |90       |615 |
|6 |      EXCHANGE IN DISTR         |        |100      |94  |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|8 |        TABLE SCAN              |t4      |100      |78  |
|9 |      SORT                      |        |500      |488 |
|10|       PX PARTITION ITERATOR    |        |500      |387 |
|11|        TABLE SCAN              |t1      |500      |387 |
|12|   PX PARTITION ITERATOR        |        |200      |155 |
|13|    TABLE SCAN                  |t3      |200      |155 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  6 - output([t4.c1]), filter(nil)
  7 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  12 - output([t3.c1]), filter(nil)
  13 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      USE_HASH_SET(@"SET$1")
      PQ_SET(@"SET$1" PARTITION NONE)
      LEADING(@"SEL$260306CE" ("opt"."t4"@"YZ" "opt"."t1"@"SEL$1"))
      USE_MERGE(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$260306CE" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$260306CE" "opt"."t4"@"YZ")
      FULL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$2" "opt"."t3"@"SEL$2")
      MERGE(@"YZ" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      FULL(@"SEL$3" "opt"."t3"@"SEL$3")
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 94(end)  ************** 

***************   Case 95   ***************

SQL: (select t1.c1 from t1 , (select/*+qb_name(yz)*/ c1 from t4) t where t.c1 = t1.c1) union select/*+leading(@SEL$1 t4@YZ t1@SEL$1) use_merge(@SEL$1 t1@SEL$1)*/ c1 from t3; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |290      |1007|
|1 | EXCHANGE OUT DISTR             |:EX10002|290      |980 |
|2 |  HASH UNION DISTINCT           |        |290      |925 |
|3 |   EXCHANGE IN DISTR            |        |90       |640 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|90       |632 |
|5 |     MERGE JOIN                 |        |90       |615 |
|6 |      EXCHANGE IN DISTR         |        |100      |94  |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|8 |        TABLE SCAN              |t4      |100      |78  |
|9 |      SORT                      |        |500      |488 |
|10|       PX PARTITION ITERATOR    |        |500      |387 |
|11|        TABLE SCAN              |t1      |500      |387 |
|12|   PX PARTITION ITERATOR        |        |200      |155 |
|13|    TABLE SCAN                  |t3      |200      |155 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  6 - output([t4.c1]), filter(nil)
  7 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  8 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  9 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  12 - output([t3.c1]), filter(nil)
  13 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      USE_HASH_SET(@"SET$1")
      PQ_SET(@"SET$1" PARTITION NONE)
      LEADING(@"SEL$260306CE" ("opt"."t4"@"YZ" "opt"."t1"@"SEL$1"))
      USE_MERGE(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$260306CE" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$260306CE" "opt"."t4"@"YZ")
      FULL(@"SEL$260306CE" "opt"."t1"@"SEL$1")
      FULL(@"SEL$2" "opt"."t3"@"SEL$2")
      MERGE(@"YZ" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      FULL(@"SEL$3" "opt"."t3"@"SEL$3")
      LEADING(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 95(end)  ************** 

***************   Case 96   ***************

SQL: select/*+index(@SEL$1 t4 idx_t4_c2) */t1.c1 from t1 where t1.c1 in (select t4.c1 from t4 group by t4.c2); 

==================================================================
|ID|OPERATOR                     |NAME            |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR               |                |7        |132 |
|1 | EXCHANGE OUT DISTR          |:EX10001        |7        |131 |
|2 |  NESTED-LOOP JOIN           |                |7        |130 |
|3 |   EXCHANGE IN DISTR         |                |7        |87  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000        |7        |86  |
|5 |     SUBPLAN SCAN            |VIEW2           |7        |86  |
|6 |      MERGE DISTINCT         |                |7        |86  |
|7 |       SORT                  |                |10       |85  |
|8 |        MERGE GROUP BY       |                |10       |82  |
|9 |         TABLE SCAN          |t4(idx_t4_c2_c3)|100      |78  |
|10|   PX PARTITION ITERATOR     |                |1        |29  |
|11|    TABLE GET                |t1              |1        |29  |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  3 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  6 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  7 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t4.c1]), filter(nil), 
      group([t4.c2]), agg_func(nil)
  9 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$E5385516" ("VIEW2"@"SEL$6FCAE2AA" "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$E5385516" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$E5385516" "opt"."t1"@"SEL$1" PARTITION NONE)
      INDEX(@"SEL$8A1445BC" "opt"."t4"@"SEL$2" "idx_t4_c2_c3")
      FULL(@"SEL$E5385516" "opt"."t1"@"SEL$1")
      UNNEST(@"SEL$2")
      SEMI_TO_INNER(@"SEL$6FCAE2AA" "VIEW1")
      MERGE(@"SEL$2" < "SEL$7BD09C5F")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("VIEW2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      NO_USE_HASH_AGGREGATION(@"SEL$2")
      INDEX(@"SEL$2" "opt"."t4"@"SEL$2" "idx_t4_c2")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 96(end)  ************** 

***************   Case 97   ***************

SQL: select/*+index(@SEL$2 t4 idx_t4_c2) */t1.c1 from t1 where t1.c1 in (select t4.c1 from t4 group by t4.c2); 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR               |             |7        |132 |
|1 | EXCHANGE OUT DISTR          |:EX10001     |7        |131 |
|2 |  NESTED-LOOP JOIN           |             |7        |130 |
|3 |   EXCHANGE IN DISTR         |             |7        |87  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000     |7        |86  |
|5 |     SUBPLAN SCAN            |VIEW2        |7        |86  |
|6 |      MERGE DISTINCT         |             |7        |86  |
|7 |       SORT                  |             |10       |85  |
|8 |        MERGE GROUP BY       |             |10       |82  |
|9 |         TABLE SCAN          |t4(idx_t4_c2)|100      |78  |
|10|   PX PARTITION ITERATOR     |             |1        |29  |
|11|    TABLE GET                |t1           |1        |29  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  3 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  6 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  7 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t4.c1]), filter(nil), 
      group([t4.c2]), agg_func(nil)
  9 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  10 - output([t1.c1]), filter(nil)
  11 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$E5385516" ("VIEW2"@"SEL$6FCAE2AA" "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$E5385516" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$E5385516" "opt"."t1"@"SEL$1" PARTITION NONE)
      INDEX(@"SEL$8A1445BC" "opt"."t4"@"SEL$2" "idx_t4_c2")
      FULL(@"SEL$E5385516" "opt"."t1"@"SEL$1")
      UNNEST(@"SEL$2")
      SEMI_TO_INNER(@"SEL$6FCAE2AA" "VIEW1")
      MERGE(@"SEL$2" < "SEL$7BD09C5F")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("VIEW2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      NO_USE_HASH_AGGREGATION(@"SEL$2")
      INDEX(@"SEL$2" "opt"."t4"@"SEL$2" "idx_t4_c2")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 97(end)  ************** 

***************   Case 98   ***************

SQL: select/*+index(@SEL$2 t4 idx_t4_c2) */t1.c1 from t1 where t1.c1 in (select/*+index(t4 idx_t4_c3)*/ t4.c1 from t4, (select t5.c1 from t5) t_a where t4.c2 > 1 and t4.c2 < 3 and t_a.c1 = t4.c1 group by t4.c2); 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |PX COORDINATOR                   |             |7        |563 |
|1 | EXCHANGE OUT DISTR              |:EX10002     |7        |563 |
|2 |  NESTED-LOOP JOIN               |             |7        |562 |
|3 |   EXCHANGE IN DISTR             |             |7        |518 |
|4 |    EXCHANGE OUT DISTR (PKEY)    |:EX10001     |7        |518 |
|5 |     SUBPLAN SCAN                |VIEW2        |7        |517 |
|6 |      MERGE DISTINCT             |             |7        |517 |
|7 |       SORT                      |             |10       |517 |
|8 |        HASH GROUP BY            |             |10       |514 |
|9 |         HASH JOIN               |             |244      |454 |
|10|          TABLE SCAN             |t4(idx_t4_c2)|100      |78  |
|11|          EXCHANGE IN DISTR      |             |300      |280 |
|12|           EXCHANGE OUT DISTR    |:EX10000     |300      |263 |
|13|            PX PARTITION ITERATOR|             |300      |233 |
|14|             TABLE SCAN          |t5           |300      |233 |
|15|   PX PARTITION ITERATOR         |             |1        |29  |
|16|    TABLE GET                    |t1           |1        |29  |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  3 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  6 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  7 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t4.c1]), filter(nil), 
      group([t4.c2]), agg_func(nil)
  9 - output([t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t5.c1 = t4.c1]), other_conds(nil)
  10 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  11 - output([t5.c1]), filter(nil)
  12 - output([t5.c1]), filter(nil), dop=1
  13 - output([t5.c1]), filter(nil)
  14 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p[0-2])
  15 - output([t1.c1]), filter(nil)
  16 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$4E43146C" ("VIEW2"@"SEL$4E6CEC69" "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$4E43146C" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$4E43146C" "opt"."t1"@"SEL$1" PARTITION NONE)
      USE_HASH_AGGREGATION(@"SEL$65E1ED7C")
      LEADING(@"SEL$65E1ED7C" ("opt"."t4"@"SEL$2" "opt"."t5"@"SEL$3"))
      USE_HASH(@"SEL$65E1ED7C" "opt"."t5"@"SEL$3")
      PQ_DISTRIBUTE(@"SEL$65E1ED7C" "opt"."t5"@"SEL$3" LOCAL LOCAL)
      INDEX(@"SEL$65E1ED7C" "opt"."t4"@"SEL$2" "idx_t4_c2")
      FULL(@"SEL$65E1ED7C" "opt"."t5"@"SEL$3")
      FULL(@"SEL$4E43146C" "opt"."t1"@"SEL$1")
      MERGE(@"SEL$3" > "SEL$2")
      UNNEST(@"SEL$B9DE6649")
      SEMI_TO_INNER(@"SEL$4E6CEC69" "VIEW1")
      MERGE(@"SEL$B9DE6649" < "SEL$D0ABDD25")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("VIEW2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_HASH_AGGREGATION(@"SEL$2")
      LEADING(@"SEL$2" ("opt.t4"@"SEL$2" "opt.t5"@"SEL$2" ))
      USE_HASH(@"SEL$2" ("opt.t5"@"SEL$2" ))
      PQ_DISTRIBUTE(@"SEL$2" ("opt.t5"@"SEL$2" ) LOCAL LOCAL)
      INDEX(@"SEL$2" "opt"."t4"@"SEL$2" "idx_t4_c2")
      FULL(@"SEL$2" "opt"."t5"@"SEL$2")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 98(end)  ************** 

***************   Case 99   ***************

SQL: select/*+index(@SEL$2 t4 idx_t4_c2) */t1.c1 from t1 where t1.c1 in (select/*+index(t4 idx_t4_c3)*/ t4.c1 from t4, (select t5.c1 from t5) t_a where t4.c3 > 1 and t4.c3 < 3 and t_a.c1 = t4.c1 group by t4.c2); 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |PX COORDINATOR                   |             |7        |564 |
|1 | EXCHANGE OUT DISTR              |:EX10002     |7        |563 |
|2 |  NESTED-LOOP JOIN               |             |7        |562 |
|3 |   EXCHANGE IN DISTR             |             |7        |519 |
|4 |    EXCHANGE OUT DISTR (PKEY)    |:EX10001     |7        |518 |
|5 |     SUBPLAN SCAN                |VIEW2        |7        |518 |
|6 |      MERGE DISTINCT             |             |7        |518 |
|7 |       SORT                      |             |10       |517 |
|8 |        HASH GROUP BY            |             |10       |514 |
|9 |         HASH JOIN               |             |244      |454 |
|10|          EXCHANGE IN DISTR      |             |300      |280 |
|11|           EXCHANGE OUT DISTR    |:EX10000     |300      |263 |
|12|            PX PARTITION ITERATOR|             |300      |233 |
|13|             TABLE SCAN          |t5           |300      |233 |
|14|          TABLE SCAN             |t4(idx_t4_c3)|100      |78  |
|15|   PX PARTITION ITERATOR         |             |1        |29  |
|16|    TABLE GET                    |t1           |1        |29  |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  3 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  6 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  7 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t4.c1]), filter(nil), 
      group([t4.c2]), agg_func(nil)
  9 - output([t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t5.c1 = t4.c1]), other_conds(nil)
  10 - output([t5.c1]), filter(nil)
  11 - output([t5.c1]), filter(nil), dop=1
  12 - output([t5.c1]), filter(nil)
  13 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p[0-2])
  14 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  15 - output([t1.c1]), filter(nil)
  16 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$4E43146C" ("VIEW2"@"SEL$4E6CEC69" "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$4E43146C" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$4E43146C" "opt"."t1"@"SEL$1" PARTITION NONE)
      USE_HASH_AGGREGATION(@"SEL$65E1ED7C")
      LEADING(@"SEL$65E1ED7C" ("opt"."t5"@"SEL$3" "opt"."t4"@"SEL$2"))
      USE_HASH(@"SEL$65E1ED7C" "opt"."t4"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$65E1ED7C" "opt"."t4"@"SEL$2" LOCAL LOCAL)
      FULL(@"SEL$65E1ED7C" "opt"."t5"@"SEL$3")
      INDEX(@"SEL$65E1ED7C" "opt"."t4"@"SEL$2" "idx_t4_c3")
      FULL(@"SEL$4E43146C" "opt"."t1"@"SEL$1")
      MERGE(@"SEL$3" > "SEL$2")
      UNNEST(@"SEL$B9DE6649")
      SEMI_TO_INNER(@"SEL$4E6CEC69" "VIEW1")
      MERGE(@"SEL$B9DE6649" < "SEL$D0ABDD25")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("VIEW2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_HASH_AGGREGATION(@"SEL$2")
      LEADING(@"SEL$2" ("opt.t4"@"SEL$2" "opt.t5"@"SEL$2" ))
      USE_HASH(@"SEL$2" ("opt.t5"@"SEL$2" ))
      PQ_DISTRIBUTE(@"SEL$2" ("opt.t5"@"SEL$2" ) LOCAL LOCAL)
      INDEX(@"SEL$2" "opt"."t4"@"SEL$2" "idx_t4_c3")
      FULL(@"SEL$2" "opt"."t5"@"SEL$2")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 99(end)  ************** 

***************   Case 100   ***************

SQL: select/*+index(@SEL$2 t4 idx_t4_c2) leading(@SEL$2 t5@SEL$3 t4@SEL$2)*/t1.c1 from t1 where t1.c1 in (select t4.c1 from t4, (select t5.c1 from t5) t_a where t_a.c1 = t4.c1 group by t4.c2); 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |PX COORDINATOR                   |             |7        |564 |
|1 | EXCHANGE OUT DISTR              |:EX10002     |7        |563 |
|2 |  NESTED-LOOP JOIN               |             |7        |562 |
|3 |   EXCHANGE IN DISTR             |             |7        |519 |
|4 |    EXCHANGE OUT DISTR (PKEY)    |:EX10001     |7        |518 |
|5 |     SUBPLAN SCAN                |VIEW2        |7        |518 |
|6 |      MERGE DISTINCT             |             |7        |517 |
|7 |       SORT                      |             |10       |517 |
|8 |        HASH GROUP BY            |             |10       |514 |
|9 |         HASH JOIN               |             |244      |454 |
|10|          EXCHANGE IN DISTR      |             |300      |280 |
|11|           EXCHANGE OUT DISTR    |:EX10000     |300      |263 |
|12|            PX PARTITION ITERATOR|             |300      |233 |
|13|             TABLE SCAN          |t5           |300      |233 |
|14|          TABLE SCAN             |t4(idx_t4_c2)|100      |78  |
|15|   PX PARTITION ITERATOR         |             |1        |29  |
|16|    TABLE GET                    |t1           |1        |29  |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  3 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  6 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  7 - output([t4.c1]), filter(nil), sort_keys([t4.c1, ASC])
  8 - output([t4.c1]), filter(nil), 
      group([t4.c2]), agg_func(nil)
  9 - output([t4.c1], [t4.c2]), filter(nil), 
      equal_conds([t5.c1 = t4.c1]), other_conds(nil)
  10 - output([t5.c1]), filter(nil)
  11 - output([t5.c1]), filter(nil), dop=1
  12 - output([t5.c1]), filter(nil)
  13 - output([t5.c1]), filter(nil), 
      access([t5.c1]), partitions(p[0-2])
  14 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0)
  15 - output([t1.c1]), filter(nil)
  16 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$4E43146C" ("VIEW2"@"SEL$4E6CEC69" "opt"."t1"@"SEL$1"))
      USE_NL(@"SEL$4E43146C" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$4E43146C" "opt"."t1"@"SEL$1" PARTITION NONE)
      USE_HASH_AGGREGATION(@"SEL$65E1ED7C")
      LEADING(@"SEL$65E1ED7C" ("opt"."t5"@"SEL$3" "opt"."t4"@"SEL$2"))
      USE_HASH(@"SEL$65E1ED7C" "opt"."t4"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$65E1ED7C" "opt"."t4"@"SEL$2" LOCAL LOCAL)
      FULL(@"SEL$65E1ED7C" "opt"."t5"@"SEL$3")
      INDEX(@"SEL$65E1ED7C" "opt"."t4"@"SEL$2" "idx_t4_c2")
      FULL(@"SEL$4E43146C" "opt"."t1"@"SEL$1")
      MERGE(@"SEL$3" > "SEL$2")
      UNNEST(@"SEL$B9DE6649")
      SEMI_TO_INNER(@"SEL$4E6CEC69" "VIEW1")
      MERGE(@"SEL$B9DE6649" < "SEL$D0ABDD25")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("VIEW2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_HASH_AGGREGATION(@"SEL$2")
      LEADING(@"SEL$2" ("opt.t5"@"SEL$2" "opt.t4"@"SEL$2" ))
      USE_HASH(@"SEL$2" ("opt.t4"@"SEL$2" ))
      PQ_DISTRIBUTE(@"SEL$2" ("opt.t4"@"SEL$2" ) LOCAL LOCAL)
      FULL(@"SEL$2" "opt"."t5"@"SEL$2")
      INDEX(@"SEL$2" "opt"."t4"@"SEL$2" "idx_t4_c2")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 100(end)  ************** 

***************   Case 101   ***************

SQL: select * from hint.t1 where a in (select * from (select max(t1.a) from hint.t1, hint.t2) as tt); 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |NESTED-LOOP JOIN             |            |1        |3095|
|1 | SUBPLAN SCAN                |VIEW1       |1        |3090|
|2 |  SCALAR GROUP BY            |            |1        |3090|
|3 |   NESTED-LOOP JOIN CARTESIAN|            |10000    |2736|
|4 |    TABLE SCAN               |t1(idx_t1_a)|100      |78  |
|5 |    MATERIAL                 |            |100      |78  |
|6 |     TABLE SCAN              |t2          |100      |78  |
|7 | TABLE GET                   |t1          |1        |5   |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      conds(nil), nl_params_([VIEW1.max(t1.a)])
  1 - output([VIEW1.max(t1.a)]), filter(nil), 
      access([VIEW1.max(t1.a)])
  2 - output([T_FUN_MAX(t1.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(t1.a)])
  3 - output([t1.a]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  5 - output(nil), filter(nil)
  6 - output(nil), filter(nil), 
      access([t2.a]), partitions(p0)
  7 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$E5385516" ("VIEW1"@"SEL$1" "hint"."t1"@"SEL$1"))
      USE_NL(@"SEL$E5385516" "hint"."t1"@"SEL$1")
      LEADING(@"SEL$1AE1580B" ("hint"."t1"@"SEL$3" "hint"."t2"@"SEL$3"))
      USE_NL(@"SEL$1AE1580B" "hint"."t2"@"SEL$3")
      USE_NL_MATERIALIZATION(@"SEL$1AE1580B" "hint"."t2"@"SEL$3")
      INDEX(@"SEL$1AE1580B" "hint"."t1"@"SEL$3" "idx_t1_a")
      FULL(@"SEL$1AE1580B" "hint"."t2"@"SEL$3")
      FULL(@"SEL$E5385516" "hint"."t1"@"SEL$1")
      UNNEST(@"SEL$2")
      SEMI_TO_INNER(@"SEL$6FCAE2AA" "VIEW1")
      MERGE(@"SEL$3" < "SEL$2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t1"@"SEL$1" ) LOCAL LOCAL)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t1"@"SEL$1" ))
      LEADING(@"SEL$3" ("hint.t1"@"SEL$3" "hint.t2"@"SEL$3" ))
      USE_NL(@"SEL$3" ("hint.t2"@"SEL$3" ))
      PQ_DISTRIBUTE(@"SEL$3" ("hint.t2"@"SEL$3" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$3" ("hint.t2"@"SEL$3" ))
      INDEX(@"SEL$3" "hint"."t1"@"SEL$3" "idx_t1_a")
      FULL(@"SEL$3" "hint"."t2"@"SEL$3")
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 101(end)  ************** 

***************   Case 102   ***************

SQL: select   /*+ BEGIN_OUTLINE_DATA USE_NL(@"SEL$3" "hint.t2"@"SEL$3") LEADING(@"SEL$3" "hint.t2"@"SEL$3" "hint.t1"@"SEL$3") END_OUTLINE_DATA */* from hint.t1 where a in (select * from (select max(t1.a) from hint.t1, hint.t2) as tt); 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |NESTED-LOOP JOIN             |            |1        |3095|
|1 | SUBPLAN SCAN                |VIEW1       |1        |3090|
|2 |  SCALAR GROUP BY            |            |1        |3090|
|3 |   NESTED-LOOP JOIN CARTESIAN|            |10000    |2736|
|4 |    TABLE SCAN               |t2          |100      |78  |
|5 |    MATERIAL                 |            |100      |78  |
|6 |     TABLE SCAN              |t1(idx_t1_a)|100      |78  |
|7 | TABLE GET                   |t1          |1        |5   |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      conds(nil), nl_params_([VIEW1.max(t1.a)])
  1 - output([VIEW1.max(t1.a)]), filter(nil), 
      access([VIEW1.max(t1.a)])
  2 - output([T_FUN_MAX(t1.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(t1.a)])
  3 - output([t1.a]), filter(nil), 
      conds(nil), nl_params_(nil)
  4 - output(nil), filter(nil), 
      access([t2.a]), partitions(p0)
  5 - output([t1.a]), filter(nil)
  6 - output([t1.a]), filter(nil), 
      access([t1.a]), partitions(p0)
  7 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$E5385516" ("VIEW1"@"SEL$1" "hint"."t1"@"SEL$1"))
      USE_NL(@"SEL$E5385516" "hint"."t1"@"SEL$1")
      LEADING(@"SEL$1AE1580B" ("hint"."t2"@"SEL$3" "hint"."t1"@"SEL$3"))
      USE_NL(@"SEL$1AE1580B" "hint"."t1"@"SEL$3")
      USE_NL_MATERIALIZATION(@"SEL$1AE1580B" "hint"."t1"@"SEL$3")
      FULL(@"SEL$1AE1580B" "hint"."t2"@"SEL$3")
      INDEX(@"SEL$1AE1580B" "hint"."t1"@"SEL$3" "idx_t1_a")
      FULL(@"SEL$E5385516" "hint"."t1"@"SEL$1")
      UNNEST(@"SEL$2")
      SEMI_TO_INNER(@"SEL$6FCAE2AA" "VIEW1")
      MERGE(@"SEL$3" < "SEL$2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "hint.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("hint.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("hint.t1"@"SEL$1" ) LOCAL LOCAL)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("hint.t1"@"SEL$1" ))
      LEADING(@"SEL$3" ("hint.t2"@"SEL$3" "hint.t1"@"SEL$3" ))
      USE_NL(@"SEL$3" ("hint.t1"@"SEL$3" ))
      PQ_DISTRIBUTE(@"SEL$3" ("hint.t1"@"SEL$3" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$3" ("hint.t1"@"SEL$3" ))
      FULL(@"SEL$3" "hint"."t2"@"SEL$3")
      INDEX(@"SEL$3" "hint"."t1"@"SEL$3" "idx_t1_a")
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 102(end)  ************** 

***************   Case 103   ***************

SQL: select t1.c1 from t1, (select t2.c1 from t2, (select t3.c1 from t3) t_a where t_a.c1 = t2.c1) t_a1 where t_a1.c1 = t1.c1 and t1.c1 in (select t4.c1 from t4); 

================================================================
|ID|OPERATOR                           |NAME    |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                     |        |3        |250 |
|1 | EXCHANGE OUT DISTR                |:EX10003|3        |249 |
|2 |  NESTED-LOOP JOIN                 |        |3        |248 |
|3 |   EXCHANGE IN DISTR               |        |4        |222 |
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10002|4        |221 |
|5 |     NESTED-LOOP JOIN              |        |4        |220 |
|6 |      EXCHANGE IN DISTR            |        |10       |153 |
|7 |       EXCHANGE OUT DISTR (PKEY)   |:EX10001|10       |152 |
|8 |        NESTED-LOOP JOIN           |        |10       |150 |
|9 |         EXCHANGE IN DISTR         |        |10       |84  |
|10|          EXCHANGE OUT DISTR (PKEY)|:EX10000|10       |83  |
|11|           SUBPLAN SCAN            |VIEW2   |10       |82  |
|12|            MERGE DISTINCT         |        |10       |82  |
|13|             TABLE SCAN            |t4      |100      |78  |
|14|         PX PARTITION ITERATOR     |        |1        |29  |
|15|          TABLE GET                |t1      |1        |29  |
|16|      PX PARTITION ITERATOR        |        |1        |12  |
|17|       TABLE GET                   |t3      |1        |12  |
|18|   PX PARTITION ITERATOR           |        |1        |18  |
|19|    TABLE GET                      |t2      |1        |18  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  6 - output([t1.c1], [PARTITION_ID]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  9 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  10 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  11 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  12 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([t1.c1]), filter(nil)
  15 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  16 - output(nil), filter(nil)
  17 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1])
  18 - output(nil), filter(nil)
  19 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$9F01FF23" ((("VIEW2"@"SEL$1C11F6CF" "opt"."t1"@"SEL$1") "opt"."t3"@"SEL$3") "opt"."t2"@"SEL$2"))
      USE_NL(@"SEL$9F01FF23" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$9F01FF23" "opt"."t2"@"SEL$2" PARTITION NONE)
      USE_NL(@"SEL$9F01FF23" "opt"."t3"@"SEL$3")
      PQ_DISTRIBUTE(@"SEL$9F01FF23" "opt"."t3"@"SEL$3" PARTITION NONE)
      USE_NL(@"SEL$9F01FF23" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$9F01FF23" "opt"."t1"@"SEL$1" PARTITION NONE)
      FULL(@"SEL$A0E8BF28" "opt"."t4"@"SEL$4")
      FULL(@"SEL$9F01FF23" "opt"."t1"@"SEL$1")
      FULL(@"SEL$9F01FF23" "opt"."t3"@"SEL$3")
      FULL(@"SEL$9F01FF23" "opt"."t2"@"SEL$2")
      MERGE(@"SEL$3" > "SEL$2")
      MERGE(@"SEL$B9DE6649" > "SEL$1")
      UNNEST(@"SEL$4")
      SEMI_TO_INNER(@"SEL$1C11F6CF" "VIEW1")
      MERGE(@"SEL$4" < "SEL$01E9366A")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ((("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" )"opt.t3"@"SEL$1" )"opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t3"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t3"@"SEL$1" ) PARTITION NONE)
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      FULL(@"SEL$1" "opt"."t4"@"SEL$1")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t3"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 103(end)  ************** 

***************   Case 104   ***************

SQL: select /*+ leading(@SEL$1 t1 t4 t3 t2) index(@SEL$4 t4 idx_t4_c3)*/ t1.c1 from t1, (select t2.c1 from t2, (select t3.c1 from t3) t_a where t_a.c1 = t2.c1) t_a1 where t_a1.c1 = t1.c1 and t1.c1 in (select t4.c1 from t4); 

=====================================================================
|ID|OPERATOR                           |NAME         |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |PX COORDINATOR                     |             |3        |271 |
|1 | EXCHANGE OUT DISTR                |:EX10003     |3        |271 |
|2 |  NESTED-LOOP JOIN                 |             |3        |270 |
|3 |   EXCHANGE IN DISTR               |             |4        |243 |
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10002     |4        |243 |
|5 |     NESTED-LOOP JOIN              |             |4        |242 |
|6 |      EXCHANGE IN DISTR            |             |10       |175 |
|7 |       EXCHANGE OUT DISTR (PKEY)   |:EX10001     |10       |174 |
|8 |        NESTED-LOOP JOIN           |             |10       |172 |
|9 |         EXCHANGE IN DISTR         |             |10       |106 |
|10|          EXCHANGE OUT DISTR (PKEY)|:EX10000     |10       |105 |
|11|           SUBPLAN SCAN            |VIEW2        |10       |104 |
|12|            HASH DISTINCT          |             |10       |104 |
|13|             TABLE SCAN            |t4(idx_t4_c3)|100      |78  |
|14|         PX PARTITION ITERATOR     |             |1        |29  |
|15|          TABLE GET                |t1           |1        |29  |
|16|      PX PARTITION ITERATOR        |             |1        |12  |
|17|       TABLE GET                   |t3           |1        |12  |
|18|   PX PARTITION ITERATOR           |             |1        |18  |
|19|    TABLE GET                      |t2           |1        |18  |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  6 - output([t1.c1], [PARTITION_ID]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  9 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  10 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  11 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  12 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([t1.c1]), filter(nil)
  15 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  16 - output(nil), filter(nil)
  17 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1])
  18 - output(nil), filter(nil)
  19 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$9F01FF23" ((("VIEW2"@"SEL$1C11F6CF" "opt"."t1"@"SEL$1") "opt"."t3"@"SEL$3") "opt"."t2"@"SEL$2"))
      USE_NL(@"SEL$9F01FF23" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$9F01FF23" "opt"."t2"@"SEL$2" PARTITION NONE)
      USE_NL(@"SEL$9F01FF23" "opt"."t3"@"SEL$3")
      PQ_DISTRIBUTE(@"SEL$9F01FF23" "opt"."t3"@"SEL$3" PARTITION NONE)
      USE_NL(@"SEL$9F01FF23" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$9F01FF23" "opt"."t1"@"SEL$1" PARTITION NONE)
      USE_HASH_DISTINCT(@"SEL$A0E8BF28")
      INDEX(@"SEL$A0E8BF28" "opt"."t4"@"SEL$4" "idx_t4_c3")
      FULL(@"SEL$9F01FF23" "opt"."t1"@"SEL$1")
      FULL(@"SEL$9F01FF23" "opt"."t3"@"SEL$3")
      FULL(@"SEL$9F01FF23" "opt"."t2"@"SEL$2")
      MERGE(@"SEL$3" > "SEL$2")
      MERGE(@"SEL$B9DE6649" > "SEL$1")
      UNNEST(@"SEL$4")
      SEMI_TO_INNER(@"SEL$1C11F6CF" "VIEW1")
      MERGE(@"SEL$4" < "SEL$01E9366A")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t4"@"SEL$1" )"opt.t3"@"SEL$1" )"opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t3"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t3"@"SEL$1" ) PARTITION NONE)
      USE_HASH(@"SEL$1" ("opt.t4"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t4"@"SEL$1" ) NONE PARTITION)
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c3")
      FULL(@"SEL$1" "opt"."t3"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 104(end)  ************** 

***************   Case 105   ***************

SQL: select /*+ leading(@SEL1 t1 t4 t3 t2) index(@SEL$4 t4 idx_t4_c3)*/ t1.c1 from t1, (select t2.c1 from t2, (select t3.c1 from t3) t_a where t_a.c1 = t2.c1) t_a1 where t_a1.c1 = t1.c1 and t1.c1 in (select t4.c1 from t4); 

=====================================================================
|ID|OPERATOR                           |NAME         |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |PX COORDINATOR                     |             |3        |271 |
|1 | EXCHANGE OUT DISTR                |:EX10003     |3        |271 |
|2 |  NESTED-LOOP JOIN                 |             |3        |270 |
|3 |   EXCHANGE IN DISTR               |             |4        |243 |
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10002     |4        |243 |
|5 |     NESTED-LOOP JOIN              |             |4        |242 |
|6 |      EXCHANGE IN DISTR            |             |10       |175 |
|7 |       EXCHANGE OUT DISTR (PKEY)   |:EX10001     |10       |174 |
|8 |        NESTED-LOOP JOIN           |             |10       |172 |
|9 |         EXCHANGE IN DISTR         |             |10       |106 |
|10|          EXCHANGE OUT DISTR (PKEY)|:EX10000     |10       |105 |
|11|           SUBPLAN SCAN            |VIEW2        |10       |104 |
|12|            HASH DISTINCT          |             |10       |104 |
|13|             TABLE SCAN            |t4(idx_t4_c3)|100      |78  |
|14|         PX PARTITION ITERATOR     |             |1        |29  |
|15|          TABLE GET                |t1           |1        |29  |
|16|      PX PARTITION ITERATOR        |             |1        |12  |
|17|       TABLE GET                   |t3           |1        |12  |
|18|   PX PARTITION ITERATOR           |             |1        |18  |
|19|    TABLE GET                      |t2           |1        |18  |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  6 - output([t1.c1], [PARTITION_ID]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  9 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  10 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  11 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  12 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([t1.c1]), filter(nil)
  15 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  16 - output(nil), filter(nil)
  17 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1])
  18 - output(nil), filter(nil)
  19 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$9F01FF23" ((("VIEW2"@"SEL$1C11F6CF" "opt"."t1"@"SEL$1") "opt"."t3"@"SEL$3") "opt"."t2"@"SEL$2"))
      USE_NL(@"SEL$9F01FF23" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$9F01FF23" "opt"."t2"@"SEL$2" PARTITION NONE)
      USE_NL(@"SEL$9F01FF23" "opt"."t3"@"SEL$3")
      PQ_DISTRIBUTE(@"SEL$9F01FF23" "opt"."t3"@"SEL$3" PARTITION NONE)
      USE_NL(@"SEL$9F01FF23" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$9F01FF23" "opt"."t1"@"SEL$1" PARTITION NONE)
      USE_HASH_DISTINCT(@"SEL$A0E8BF28")
      INDEX(@"SEL$A0E8BF28" "opt"."t4"@"SEL$4" "idx_t4_c3")
      FULL(@"SEL$9F01FF23" "opt"."t1"@"SEL$1")
      FULL(@"SEL$9F01FF23" "opt"."t3"@"SEL$3")
      FULL(@"SEL$9F01FF23" "opt"."t2"@"SEL$2")
      MERGE(@"SEL$3" > "SEL$2")
      MERGE(@"SEL$B9DE6649" > "SEL$1")
      UNNEST(@"SEL$4")
      SEMI_TO_INNER(@"SEL$1C11F6CF" "VIEW1")
      MERGE(@"SEL$4" < "SEL$01E9366A")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ((("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" )"opt.t3"@"SEL$1" )"opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t3"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t3"@"SEL$1" ) PARTITION NONE)
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c3")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      FULL(@"SEL$1" "opt"."t3"@"SEL$1")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 105(end)  ************** 

***************   Case 106   ***************

SQL: select /*+index(@SEL$3 t5@SEL$3 idx_t5_c2) index(@SEL$4 t4 idx_t4_c3)*/ t1.c1 from t1, (select t2.c1 from t2, (select t5.c1 from t5 group by t5.c2) t_a where t_a.c1 = t2.c1) t_a1 where t_a1.c1 = t1.c1 and t1.c1 in (select t4.c1 from t4); 

========================================================================
|ID|OPERATOR                              |NAME         |EST. ROWS|COST|
------------------------------------------------------------------------
|0 |PX COORDINATOR                        |             |2        |582 |
|1 | EXCHANGE OUT DISTR                   |:EX10005     |2        |582 |
|2 |  NESTED-LOOP JOIN                    |             |2        |581 |
|3 |   EXCHANGE IN DISTR                  |             |2        |568 |
|4 |    EXCHANGE OUT DISTR (PKEY)         |:EX10004     |2        |568 |
|5 |     HASH JOIN                        |             |2        |567 |
|6 |      EXCHANGE IN DISTR               |             |10       |175 |
|7 |       EXCHANGE OUT DISTR             |:EX10001     |10       |174 |
|8 |        NESTED-LOOP JOIN              |             |10       |172 |
|9 |         EXCHANGE IN DISTR            |             |10       |106 |
|10|          EXCHANGE OUT DISTR (PKEY)   |:EX10000     |10       |105 |
|11|           SUBPLAN SCAN               |VIEW2        |10       |104 |
|12|            HASH DISTINCT             |             |10       |104 |
|13|             TABLE SCAN               |t4(idx_t4_c3)|100      |78  |
|14|         PX PARTITION ITERATOR        |             |1        |29  |
|15|          TABLE GET                   |t1           |1        |29  |
|16|      EXCHANGE IN DISTR               |             |100      |366 |
|17|       EXCHANGE OUT DISTR             |:EX10003     |100      |361 |
|18|        SUBPLAN SCAN                  |t_a          |100      |351 |
|19|         MERGE GROUP BY               |             |100      |349 |
|20|          EXCHANGE IN MERGE SORT DISTR|             |100      |344 |
|21|           EXCHANGE OUT DISTR (HASH)  |:EX10002     |100      |330 |
|22|            PX PARTITION ITERATOR     |             |100      |303 |
|23|             MERGE GROUP BY           |             |100      |303 |
|24|              TABLE SCAN              |t5(idx_t5_c2)|300      |290 |
|25|   PX PARTITION ITERATOR              |             |1        |18  |
|26|    TABLE GET                         |t2           |1        |18  |
========================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  3 - output([t1.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID]), filter(nil), is_single, dop=1
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t_a.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil)
  7 - output([t1.c1]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.c1])
  9 - output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil)
  10 - (#keys=1, [VIEW2.VIEW1.c1]), output([PARTITION_ID], [VIEW2.VIEW1.c1]), filter(nil), is_single, dop=1
  11 - output([VIEW2.VIEW1.c1]), filter(nil), 
      access([VIEW2.VIEW1.c1])
  12 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  13 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0)
  14 - output([t1.c1]), filter(nil)
  15 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4])
  16 - output([t_a.c1]), filter(nil)
  17 - output([t_a.c1]), filter(nil), dop=1
  18 - output([t_a.c1]), filter(nil), 
      access([t_a.c1])
  19 - output([t5.c1]), filter(nil), 
      group([t5.c2]), agg_func(nil)
  20 - output([t5.c2], [t5.c1]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  21 - (#keys=1, [t5.c2]), output([t5.c2], [t5.c1]), filter(nil), dop=1
  22 - output([t5.c2], [t5.c1]), filter(nil)
  23 - output([t5.c2], [t5.c1]), filter(nil), 
      group([t5.c2]), agg_func(nil)
  24 - output([t5.c2], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c1]), partitions(p[0-2])
  25 - output(nil), filter(nil)
  26 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$75FC60FD" ((("VIEW2"@"SEL$2B49C46C" "opt"."t1"@"SEL$1") "t_a"@"SEL$2") "opt"."t2"@"SEL$2"))
      USE_NL(@"SEL$75FC60FD" "opt"."t2"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$75FC60FD" "opt"."t2"@"SEL$2" PARTITION NONE)
      USE_HASH(@"SEL$75FC60FD" "t_a"@"SEL$2")
      PQ_DISTRIBUTE(@"SEL$75FC60FD" "t_a"@"SEL$2" LOCAL LOCAL)
      USE_NL(@"SEL$75FC60FD" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$75FC60FD" "opt"."t1"@"SEL$1" PARTITION NONE)
      USE_HASH_DISTINCT(@"SEL$0AE88291")
      INDEX(@"SEL$0AE88291" "opt"."t4"@"SEL$4" "idx_t4_c3")
      FULL(@"SEL$75FC60FD" "opt"."t1"@"SEL$1")
      INDEX(@"SEL$3" "opt"."t5"@"SEL$3" "idx_t5_c2")
      FULL(@"SEL$75FC60FD" "opt"."t2"@"SEL$2")
      MERGE(@"SEL$2" > "SEL$1")
      UNNEST(@"SEL$4")
      SEMI_TO_INNER(@"SEL$2B49C46C" "VIEW1")
      MERGE(@"SEL$4" < "SEL$EB14A9B4")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ((("opt.t4"@"SEL$1" "opt.t1"@"SEL$1" )"t_a"@"SEL$1" )"opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t2"@"SEL$1" ) PARTITION NONE)
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("t_a"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("t_a"@"SEL$1" ) LOCAL LOCAL)
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) PARTITION NONE)
      INDEX(@"SEL$1" "opt"."t4"@"SEL$1" "idx_t4_c3")
      FULL(@"SEL$1" "opt"."t1"@"SEL$1")
      NO_USE_HASH_AGGREGATION(@"SEL$3")
      NO_USE_HASH_AGGREGATION(@"SEL$3")
      INDEX(@"SEL$3" "opt"."t5"@"SEL$3" "idx_t5_c2")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 106(end)  ************** 

***************   Case 107   ***************

SQL: select c2 from t_idx use index(t_c2); 

==================================================
|ID|OPERATOR  |NAME               |EST. ROWS|COST|
--------------------------------------------------
|0 |TABLE SCAN|t_idx(idx_t_idx_c2)|100      |78  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_idx.c2]), filter(nil), 
      access([t_idx.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt"."t_idx"@"SEL$1" "idx_t_idx_c2")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 107(end)  ************** 

***************   Case 108   ***************

SQL: select c120 from t_idx use index (idx_t_idx_c2, idx_t_idx_c3, idx_t_idx_c4, idx_t_idx_c5, idx_t_idx_c6, idx_t_idx_c7, idx_t_idx_c8, idx_t_idx_c9, idx_t_idx_c10, idx_t_idx_c11, idx_t_idx_c12, idx_t_idx_c13, idx_t_idx_c14, idx_t_idx_c15, idx_t_idx_c16, idx_t_idx_c17, idx_t_idx_c18, idx_t_idx_c19, idx_t_idx_c20, idx_t_idx_c21, idx_t_idx_c22, idx_t_idx_c23, idx_t_idx_c24, idx_t_idx_c25, idx_t_idx_c26, idx_t_idx_c27, idx_t_idx_c28, idx_t_idx_c29, idx_t_idx_c30, idx_t_idx_c31, idx_t_idx_c32, idx_t_idx_c33, idx_t_idx_c34, idx_t_idx_c35, idx_t_idx_c36, idx_t_idx_c37, idx_t_idx_c38, idx_t_idx_c39, idx_t_idx_c40, idx_t_idx_c41, idx_t_idx_c42, idx_t_idx_c43, idx_t_idx_c44, idx_t_idx_c45, idx_t_idx_c46, idx_t_idx_c47, idx_t_idx_c48, idx_t_idx_c49, idx_t_idx_c50, idx_t_idx_c51, idx_t_idx_c52, idx_t_idx_c53, idx_t_idx_c54, idx_t_idx_c55, idx_t_idx_c56, idx_t_idx_c57, idx_t_idx_c58, idx_t_idx_c59, idx_t_idx_c60, idx_t_idx_c61, idx_t_idx_c62, idx_t_idx_c63, idx_t_idx_c64, idx_t_idx_c65, idx_t_idx_c66, idx_t_idx_c67, idx_t_idx_c68, idx_t_idx_c69, idx_t_idx_c70, idx_t_idx_c71, idx_t_idx_c72, idx_t_idx_c73, idx_t_idx_c74, idx_t_idx_c75, idx_t_idx_c76, idx_t_idx_c77, idx_t_idx_c78, idx_t_idx_c79, idx_t_idx_c80, idx_t_idx_c81, idx_t_idx_c82, idx_t_idx_c83, idx_t_idx_c84, idx_t_idx_c85, idx_t_idx_c86, idx_t_idx_c87, idx_t_idx_c88, idx_t_idx_c89, idx_t_idx_c90, idx_t_idx_c91, idx_t_idx_c92, idx_t_idx_c93, idx_t_idx_c94, idx_t_idx_c95, idx_t_idx_c96, idx_t_idx_c97, idx_t_idx_c98, idx_t_idx_c99, idx_t_idx_c100, idx_t_idx_c101, idx_t_idx_c102, idx_t_idx_c103, idx_t_idx_c104, idx_t_idx_c105, idx_t_idx_c106, idx_t_idx_c107, idx_t_idx_c108, idx_t_idx_c109, idx_t_idx_c110, idx_t_idx_c111, idx_t_idx_c112, idx_t_idx_c113, idx_t_idx_c114, idx_t_idx_c115, idx_t_idx_c116, idx_t_idx_c117, idx_t_idx_c118, idx_t_idx_c119, idx_t_idx_c120, idx_t_idx_c121, idx_t_idx_c122, idx_t_idx_c123, idx_t_idx_c124, idx_t_idx_c125, idx_t_idx_c126, idx_t_idx_c127, idx_t_idx_c128, idx_t_idx_c129) where c120 = 1; 

====================================================
|ID|OPERATOR  |NAME                 |EST. ROWS|COST|
----------------------------------------------------
|0 |TABLE SCAN|t_idx(idx_t_idx_c120)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_idx.c120]), filter(nil), 
      access([t_idx.c120]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt"."t_idx"@"SEL$1" "idx_t_idx_c120")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 108(end)  ************** 

***************   Case 109   ***************

SQL: select c120 from t_idx use index (idx_t_idx_c2, idx_t_idx_c2, idx_t_idx_c3, idx_t_idx_c4, idx_t_idx_c5, idx_t_idx_c6, idx_t_idx_c7, idx_t_idx_c8, idx_t_idx_c9, idx_t_idx_c10, idx_t_idx_c11, idx_t_idx_c12, idx_t_idx_c13, idx_t_idx_c14, idx_t_idx_c15, idx_t_idx_c16, idx_t_idx_c17, idx_t_idx_c18, idx_t_idx_c19, idx_t_idx_c20, idx_t_idx_c21, idx_t_idx_c22, idx_t_idx_c23, idx_t_idx_c24, idx_t_idx_c25, idx_t_idx_c26, idx_t_idx_c27, idx_t_idx_c28, idx_t_idx_c29, idx_t_idx_c30, idx_t_idx_c31, idx_t_idx_c32, idx_t_idx_c33, idx_t_idx_c34, idx_t_idx_c35, idx_t_idx_c36, idx_t_idx_c37, idx_t_idx_c38, idx_t_idx_c39, idx_t_idx_c40, idx_t_idx_c41, idx_t_idx_c42, idx_t_idx_c43, idx_t_idx_c44, idx_t_idx_c45, idx_t_idx_c46, idx_t_idx_c47, idx_t_idx_c48, idx_t_idx_c49, idx_t_idx_c50, idx_t_idx_c51, idx_t_idx_c52, idx_t_idx_c53, idx_t_idx_c54, idx_t_idx_c55, idx_t_idx_c56, idx_t_idx_c57, idx_t_idx_c58, idx_t_idx_c59, idx_t_idx_c60, idx_t_idx_c61, idx_t_idx_c62, idx_t_idx_c63, idx_t_idx_c64, idx_t_idx_c65, idx_t_idx_c66, idx_t_idx_c67, idx_t_idx_c68, idx_t_idx_c69, idx_t_idx_c70, idx_t_idx_c71, idx_t_idx_c72, idx_t_idx_c73, idx_t_idx_c74, idx_t_idx_c75, idx_t_idx_c76, idx_t_idx_c77, idx_t_idx_c78, idx_t_idx_c79, idx_t_idx_c80, idx_t_idx_c81, idx_t_idx_c82, idx_t_idx_c83, idx_t_idx_c84, idx_t_idx_c85, idx_t_idx_c86, idx_t_idx_c87, idx_t_idx_c88, idx_t_idx_c89, idx_t_idx_c90, idx_t_idx_c91, idx_t_idx_c92, idx_t_idx_c93, idx_t_idx_c94, idx_t_idx_c95, idx_t_idx_c96, idx_t_idx_c97, idx_t_idx_c98, idx_t_idx_c99, idx_t_idx_c100, idx_t_idx_c101, idx_t_idx_c102, idx_t_idx_c103, idx_t_idx_c104, idx_t_idx_c105, idx_t_idx_c106, idx_t_idx_c107, idx_t_idx_c108, idx_t_idx_c109, idx_t_idx_c110, idx_t_idx_c111, idx_t_idx_c112, idx_t_idx_c113, idx_t_idx_c114, idx_t_idx_c115, idx_t_idx_c116, idx_t_idx_c117, idx_t_idx_c118, idx_t_idx_c119, idx_t_idx_c120, idx_t_idx_c121, idx_t_idx_c122, idx_t_idx_c123, idx_t_idx_c124, idx_t_idx_c125, idx_t_idx_c126, idx_t_idx_c127, idx_t_idx_c128, idx_t_idx_c129) where c120 = 1; 

====================================================
|ID|OPERATOR  |NAME                 |EST. ROWS|COST|
----------------------------------------------------
|0 |TABLE SCAN|t_idx(idx_t_idx_c120)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_idx.c120]), filter(nil), 
      access([t_idx.c120]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt"."t_idx"@"SEL$1" "idx_t_idx_c120")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 109(end)  ************** 

***************   Case 110   ***************

SQL: select /*+use_plan_cache(none)*/ * from hint.t1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
<<<<<<< HEAD
      USE_PLAN_CACHE( NONE )
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      USE_PLAN_CACHE("NONE")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 110(end)  ************** 

***************   Case 111   ***************

SQL: select /*+use_plan_cache(meaningless)*/ * from hint.t1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 111(end)  ************** 

***************   Case 112   ***************

SQL: select /*+ index(t1 primary) */ * from hint.t1 order by a desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t1(Reverse)|100      |78  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "hint"."t1"@"SEL$1")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 112(end)  ************** 

***************   Case 113   ***************

SQL: select min(a) from z1 za where za.a in (select a from z1); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY|     |1        |46  |
|1 | SUBPLAN SCAN  |VIEW2|1        |46  |
|2 |  TABLE SCAN   |za   |1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(VIEW2.za.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.za.a)])
  1 - output([VIEW2.za.a]), filter(nil), 
      access([VIEW2.za.a])
  2 - output([za.a]), filter(nil), 
      access([za.a]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      FULL(@"SEL$1BEFA784" "opt"."za"@"SEL$1")
      UNNEST(@"SEL$2")
      SEMI_TO_INNER(@"SEL$6FCAE2AA" "VIEW1")
      MERGE(@"SEL$2" > "SEL$E5385516")
      ELIMINATE_JOIN(@"SEL$FE336D0E" "opt"."z1"@"SEL$FE336D0E")
      FAST_MINMAX(@"SEL$277F5D16")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      FULL(@"SEL$3" "opt"."za"@"SEL$3")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 113(end)  ************** 

***************   Case 114   ***************

SQL: select /*+ INDEX(@SEL$3 opt.z1@SEL$2 z1_b)*/ min(a) from z1 za where za.a in (select a from z1); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |SCALAR GROUP BY|     |1        |46  |
|1 | SUBPLAN SCAN  |VIEW2|1        |46  |
|2 |  TABLE SCAN   |za   |1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(VIEW2.za.a)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.za.a)])
  1 - output([VIEW2.za.a]), filter(nil), 
      access([VIEW2.za.a])
  2 - output([za.a]), filter(nil), 
      access([za.a]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      FULL(@"SEL$1BEFA784" "opt"."za"@"SEL$1")
      UNNEST(@"SEL$2")
      SEMI_TO_INNER(@"SEL$6FCAE2AA" "VIEW1")
      MERGE(@"SEL$2" > "SEL$E5385516")
      ELIMINATE_JOIN(@"SEL$FE336D0E" "opt"."z1"@"SEL$FE336D0E")
      FAST_MINMAX(@"SEL$277F5D16")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      FULL(@"SEL$3" "opt"."za"@"SEL$3")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 114(end)  ************** 

***************   Case 115   ***************

SQL: select /*+index(z1 z1_b)*/ * from z1 ignore key(a); 

=======================================
|ID|OPERATOR  |NAME    |EST. ROWS|COST|
---------------------------------------
|0 |TABLE SCAN|z1(z1_b)|100      |102 |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([z1.a], [z1.b], [z1.c], [z1.d]), filter(nil), 
      access([z1.a], [z1.b], [z1.c], [z1.d]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      INDEX(@"SEL$1" "opt"."z1"@"SEL$1" "z1_b")
<<<<<<< HEAD
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 115(end)  ************** 

***************   Case 116   ***************

SQL: select /*+index(z1 z1_b)*/ * from z1 ignore key(z1_b); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|z1  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([z1.a], [z1.b], [z1.c], [z1.d]), filter(nil), 
      access([z1.a], [z1.b], [z1.c], [z1.d]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      FULL(@"SEL$1" "opt"."z1"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      INDEX(@"SEL$1" "opt"."z1"@"SEL$1" "z1_b")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 116(end)  ************** 

***************   Case 117   ***************

SQL: select /*+use_hash(t1,t2) no_use_hash_aggregation*/* from t1 left join t2 using(c2) group by t1.c2 order by t1.c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |MERGE GROUP BY            |             |100      |2291|
|1 | SORT                     |             |1216     |2236|
|2 |  HASH OUTER JOIN         |             |1216     |1186|
|3 |   PX COORDINATOR         |             |500      |528 |
|4 |    EXCHANGE OUT DISTR    |:EX10000     |500      |481 |
|5 |     PX PARTITION ITERATOR|             |500      |387 |
|6 |      TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
|7 |   PX COORDINATOR         |             |300      |464 |
|8 |    EXCHANGE OUT DISTR    |:EX20000     |300      |391 |
|9 |     PX PARTITION ITERATOR|             |300      |233 |
|10|      TABLE SCAN          |t2           |300      |233 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  1 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c2 = t2.c2]), other_conds(nil)
  3 - output([t1.c2], [t1.c1]), filter(nil)
  4 - output([t1.c2], [t1.c1]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil)
  8 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), dop=1
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" LOCAL LOCAL)
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      NO_USE_HASH_AGGREGATION(@"SEL$1")
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 117(end)  ************** 

***************   Case 118   ***************

SQL: select /*+use_hash(t1,t2) no_use_hash_aggregation*/* from t1 left join t2 using(c2) group by t1.c2 order by t2.c3 limit 3; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |TOP-N SORT                 |             |3        |2304|
|1 | MERGE GROUP BY            |             |100      |2291|
|2 |  SORT                     |             |1216     |2236|
|3 |   HASH OUTER JOIN         |             |1216     |1186|
|4 |    PX COORDINATOR         |             |500      |528 |
|5 |     EXCHANGE OUT DISTR    |:EX10000     |500      |481 |
|6 |      PX PARTITION ITERATOR|             |500      |387 |
|7 |       TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
|8 |    PX COORDINATOR         |             |300      |464 |
|9 |     EXCHANGE OUT DISTR    |:EX20000     |300      |391 |
|10|      PX PARTITION ITERATOR|             |300      |233 |
|11|       TABLE SCAN          |t2           |300      |233 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t1.c1], [t2.c1], [t2.c3]), filter(nil), sort_keys([t2.c3, ASC]), topn(3)
  1 - output([t2.c3], [t1.c2], [t1.c1], [t2.c1]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  2 - output([t2.c3], [t1.c2], [t1.c1], [t2.c1]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t2.c3], [t1.c2], [t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2]), other_conds(nil)
  4 - output([t1.c2], [t1.c1]), filter(nil)
  5 - output([t1.c2], [t1.c1]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])
  8 - output([t2.c3], [t2.c1], [t2.c2]), filter(nil)
  9 - output([t2.c3], [t2.c1], [t2.c2]), filter(nil), dop=1
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("opt"."t1"@"SEL$1" "opt"."t2"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t2"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t2"@"SEL$1" LOCAL LOCAL)
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      NO_USE_HASH_AGGREGATION(@"SEL$1")
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      FULL(@"SEL$1" "opt"."t2"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 118(end)  ************** 

***************   Case 119   ***************

SQL: select /*+ use_bnl(hint.t2, opt.t1)*/ * from hint.t2, opt.t1 where opt.t1.c2 = hint.t2.a; 

==========================================================
|ID|OPERATOR                |NAME         |EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH JOIN               |             |451      |749 |
|1 | TABLE SCAN             |t2           |100      |78  |
|2 | PX COORDINATOR         |             |500      |528 |
|3 |  EXCHANGE OUT DISTR    |:EX10000     |500      |481 |
|4 |   PX PARTITION ITERATOR|             |500      |387 |
|5 |    TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.a], [t2.b], [t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t2.a]), other_conds(nil)
  1 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4])

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      LEADING(@"SEL$1" ("hint"."t2"@"SEL$1" "opt"."t1"@"SEL$1"))
      USE_HASH(@"SEL$1" "opt"."t1"@"SEL$1")
      PQ_DISTRIBUTE(@"SEL$1" "opt"."t1"@"SEL$1" LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("hint.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.t1"@"SEL$1" ) LOCAL LOCAL)
      FULL(@"SEL$1" "hint"."t2"@"SEL$1")
      INDEX(@"SEL$1" "opt"."t1"@"SEL$1" "idx_t1_c2")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 119(end)  ************** 

***************   Case 120   ***************

SQL: select /*+ leading (b a) */ distinct * from hint_t1 a, hint_v1 b; 

=======================================================
|ID|OPERATOR                   |NAME   |EST. ROWS|COST|
-------------------------------------------------------
|0 |HASH DISTINCT              |       |71       |5289|
|1 | NESTED-LOOP JOIN CARTESIAN|       |10000    |2736|
|2 |  TABLE SCAN               |hint_t2|100      |78  |
|3 |  MATERIAL                 |       |100      |78  |
|4 |   TABLE SCAN              |a      |100      |78  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [hint_t2.c2]), filter(nil), 
      distinct([a.c1], [hint_t2.c2])
  1 - output([a.c1], [hint_t2.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([hint_t2.c2]), filter(nil), 
      access([hint_t2.c2]), partitions(p0)
  3 - output([a.c1]), filter(nil)
  4 - output([a.c1]), filter(nil), 
      access([a.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      USE_HASH_DISTINCT(@"SEL$CFEA49FE")
      LEADING(@"SEL$CFEA49FE" ("opt"."hint_t2"@"SEL$2" "opt"."a"@"SEL$1"))
      USE_NL(@"SEL$CFEA49FE" "opt"."a"@"SEL$1")
      USE_NL_MATERIALIZATION(@"SEL$CFEA49FE" "opt"."a"@"SEL$1")
      FULL(@"SEL$CFEA49FE" "opt"."hint_t2"@"SEL$2")
      FULL(@"SEL$CFEA49FE" "opt"."a"@"SEL$1")
      MERGE(@"SEL$2" > "SEL$1")
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      LEADING(@"SEL$1" ("opt.hint_t2"@"SEL$1" "opt.a"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.a"@"SEL$1" ))
      PQ_DISTRIBUTE(@"SEL$1" ("opt.a"@"SEL$1" ) LOCAL LOCAL)
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.a"@"SEL$1" ))
      FULL(@"SEL$1" "opt"."hint_t2"@"SEL$1")
      FULL(@"SEL$1" "opt"."a"@"SEL$1")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 120(end)  ************** 

***************   Case 121   ***************

SQL: select /*+read_consistency(weak)*/ * from (select distinct * from hint_t1) as a limit 5; 

==========================================
|ID|OPERATOR      |NAME   |EST. ROWS|COST|
------------------------------------------
|0 |LIMIT         |       |5        |49  |
|1 | HASH DISTINCT|       |5        |49  |
|2 |  TABLE SCAN  |hint_t1|7        |46  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([hint_t1.c1]), filter(nil), limit(5), offset(nil)
  1 - output([hint_t1.c1]), filter(nil), 
      distinct([hint_t1.c1])
  2 - output([hint_t1.c1]), filter(nil), 
      access([hint_t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
<<<<<<< HEAD
      USE_HASH_DISTINCT(@"SEL$F53088DF")
      FULL(@"SEL$F53088DF" "opt"."hint_t1"@"SEL$2")
      MERGE(@"SEL$2" < "SEL$1")
      READ_CONSISTENCY( WEAK )
      OPTIMIZER_FEATURES_ENABLE('4.0.0.0')
=======
      FULL(@"SEL$2" "opt"."hint_t1"@"SEL$2")
      READ_CONSISTENCY("WEAK")
>>>>>>> implement spm part1
      END_OUTLINE_DATA
  */

*************** Case 121(end)  ************** 

