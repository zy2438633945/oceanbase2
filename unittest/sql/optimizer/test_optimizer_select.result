***************   Case 1   ***************

SQL: select * from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 1(end)  ************** 

***************   Case 2   ***************

SQL: select c1 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 2(end)  ************** 

***************   Case 3   ***************

SQL: select c2 from t1 order by c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |500      |567 |
|1 | EXCHANGE OUT DISTR       |:EX10000     |500      |540 |
|2 |  SORT                    |             |500      |488 |
|3 |   PX PARTITION ITERATOR  |             |500      |387 |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2], [INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  3 - output([t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 3(end)  ************** 

***************   Case 4   ***************

SQL: select c1, c2 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 4(end)  ************** 

***************   Case 5   ***************

SQL: select c1 + c2 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1 + t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1 + t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 5(end)  ************** 

***************   Case 6   ***************

SQL: select c1 from t1 limit 100; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |LIMIT                    |        |100      |248 |
|1 | PX COORDINATOR          |        |100      |247 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|100      |241 |
|3 |   LIMIT                 |        |100      |231 |
|4 |    PX PARTITION ITERATOR|        |100      |229 |
|5 |     TABLE SCAN          |t1      |100      |229 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 6(end)  ************** 

***************   Case 7   ***************

SQL: select * from t1 limit 100; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |LIMIT                    |        |100      |261 |
|1 | PX COORDINATOR          |        |100      |259 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|100      |250 |
|3 |   LIMIT                 |        |100      |231 |
|4 |    PX PARTITION ITERATOR|        |100      |229 |
|5 |     TABLE SCAN          |t1      |100      |229 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 7(end)  ************** 

***************   Case 8   ***************

SQL: select * from t1 order by c1,c2 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |100      |279 |
|1 | PX COORDINATOR MERGE SORT |        |100      |278 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|100      |268 |
|3 |   TOP-N SORT              |        |100      |250 |
|4 |    PX PARTITION ITERATOR  |        |100      |229 |
|5 |     TABLE SCAN            |t1      |100      |229 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), topn(100), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 8(end)  ************** 

***************   Case 9   ***************

SQL: select c1 from t1 order by c1 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |100      |267 |
|1 | PX COORDINATOR MERGE SORT |        |100      |265 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|100      |260 |
|3 |   TOP-N SORT              |        |100      |249 |
|4 |    PX PARTITION ITERATOR  |        |100      |229 |
|5 |     TABLE SCAN            |t1      |100      |229 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), topn(100), local merge sort
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 9(end)  ************** 

***************   Case 10   ***************

SQL: select c1 from t1 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |100      |279 |
|1 | PX COORDINATOR MERGE SORT |             |100      |278 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |100      |268 |
|3 |   TOP-N SORT              |             |100      |250 |
|4 |    PX PARTITION ITERATOR  |             |100      |229 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|100      |229 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(100), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 10(end)  ************** 

***************   Case 11   ***************

SQL: select c1 from t1 where c1 > 0 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |100      |281 |
|1 | PX COORDINATOR MERGE SORT |             |100      |279 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |100      |270 |
|3 |   TOP-N SORT              |             |100      |251 |
|4 |    PX PARTITION ITERATOR  |             |100      |230 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|100      |230 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(100), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 11(end)  ************** 

***************   Case 12   ***************

SQL: select c1 from t1 where c1 > 0 and c2 < 0 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |5        |230 |
|1 | PX COORDINATOR MERGE SORT |             |5        |230 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |5        |229 |
|3 |   TOP-N SORT              |             |5        |228 |
|4 |    PX PARTITION ITERATOR  |             |5        |227 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|5        |227 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(100), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(NULL,MAX ; 0,MIN), 
      range_cond([t1.c2 < ?])

*************** Case 12(end)  ************** 

***************   Case 13   ***************

SQL: select c1 from t1 group by c1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 13(end)  ************** 

***************   Case 14   ***************

SQL: select c2, sum(c1) from t1 group by c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |528 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |509 |
|2 |  MERGE GROUP BY               |             |100      |469 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |462 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |448 |
|5 |     PX PARTITION ITERATOR     |             |100      |418 |
|6 |      MERGE GROUP BY           |             |100      |418 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |387 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 14(end)  ************** 

***************   Case 15   ***************

SQL: select c2, avg(c1) from t1 group by c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |576 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |550 |
|2 |  MERGE GROUP BY               |             |100      |492 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |483 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |465 |
|5 |     PX PARTITION ITERATOR     |             |100      |427 |
|6 |      MERGE GROUP BY           |             |100      |427 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |387 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 15(end)  ************** 

***************   Case 16   ***************

SQL: select c1, c1 + c2 from t1 where c1 > 0 limit 100; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |LIMIT                    |        |100      |261 |
|1 | PX COORDINATOR          |        |100      |259 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|100      |250 |
|3 |   LIMIT                 |        |100      |231 |
|4 |    PX PARTITION ITERATOR|        |100      |229 |
|5 |     TABLE SCAN          |t1      |100      |229 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 16(end)  ************** 

***************   Case 17   ***************

SQL: select c1 from t1 where c1 > 0; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 17(end)  ************** 

***************   Case 18   ***************

SQL: select c2 from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |311 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |309 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |296 |
|3 |   LIMIT                         |             |100      |269 |
|4 |    MERGE GROUP BY               |             |100      |267 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |262 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |252 |
|7 |       PX PARTITION ITERATOR     |             |100      |234 |
|8 |        MERGE GROUP BY           |             |100      |234 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|100      |229 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c2]), filter(nil), dop=1
  3 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  5 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  7 - output([t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 18(end)  ************** 

***************   Case 19   ***************

SQL: select sum(c1) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |349 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |347 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |328 |
|3 |   LIMIT                         |             |100      |288 |
|4 |    MERGE GROUP BY               |             |100      |287 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |279 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |265 |
|7 |       PX PARTITION ITERATOR     |             |100      |236 |
|8 |        MERGE GROUP BY           |             |100      |236 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|100      |229 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  7 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      force partition granule.
  8 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 19(end)  ************** 

***************   Case 20   ***************

SQL: select sum(c1) from t1 where c1 > 0 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |350 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |348 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |330 |
|3 |   LIMIT                         |             |100      |289 |
|4 |    MERGE GROUP BY               |             |100      |288 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |280 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |266 |
|7 |       PX PARTITION ITERATOR     |             |100      |237 |
|8 |        MERGE GROUP BY           |             |100      |237 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|100      |230 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  7 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      force partition granule.
  8 - output([t1.c2], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 20(end)  ************** 

***************   Case 21   ***************

SQL: select count(c1) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |340 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |338 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |321 |
|3 |   LIMIT                         |             |100      |285 |
|4 |    MERGE GROUP BY               |             |100      |283 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |276 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |263 |
|7 |       PX PARTITION ITERATOR     |             |100      |236 |
|8 |        MERGE GROUP BY           |             |100      |236 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|100      |229 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  5 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  7 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  8 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 21(end)  ************** 

***************   Case 22   ***************

SQL: select count(distinct c1) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |340 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |338 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |321 |
|3 |   LIMIT                         |             |100      |285 |
|4 |    MERGE GROUP BY               |             |100      |283 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |276 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |263 |
|7 |       PX PARTITION ITERATOR     |             |100      |236 |
|8 |        MERGE GROUP BY           |             |100      |236 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|100      |229 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  5 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  7 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  8 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(t1.c1)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 22(end)  ************** 

***************   Case 23   ***************

SQL: select count(*) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |314 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |312 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |299 |
|3 |   LIMIT                         |             |100      |272 |
|4 |    MERGE GROUP BY               |             |100      |270 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |264 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |254 |
|7 |       PX PARTITION ITERATOR     |             |100      |235 |
|8 |        MERGE GROUP BY           |             |100      |235 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|100      |229 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  5 - output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), dop=1
  7 - output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), 
      force partition granule.
  8 - output([t1.c2], [T_FUN_COUNT(*)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(*)])
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 23(end)  ************** 

***************   Case 24   ***************

SQL: select sum(c1), count(*) from t1 group by c2 order by c2 limit 100; 

===================================================================
|ID|OPERATOR                         |NAME         |EST. ROWS|COST|
-------------------------------------------------------------------
|0 |LIMIT                            |             |100      |390 |
|1 | PX COORDINATOR MERGE SORT       |             |100      |388 |
|2 |  EXCHANGE OUT DISTR             |:EX10001     |100      |362 |
|3 |   LIMIT                         |             |100      |305 |
|4 |    MERGE GROUP BY               |             |100      |303 |
|5 |     EXCHANGE IN MERGE SORT DISTR|             |100      |293 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |276 |
|7 |       PX PARTITION ITERATOR     |             |100      |238 |
|8 |        MERGE GROUP BY           |             |100      |238 |
|9 |         TABLE SCAN              |t1(idx_t1_c2)|100      |229 |
===================================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), limit(100), offset(nil)
  1 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), dop=1
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), limit(100), offset(nil)
  4 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  6 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), dop=1
  7 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), 
      force partition granule.
  8 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(*)])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 24(end)  ************** 

***************   Case 25   ***************

SQL: select c2, count(c1) from t1 group by c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |519 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |502 |
|2 |  MERGE GROUP BY               |             |100      |466 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |459 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |446 |
|5 |     PX PARTITION ITERATOR     |             |100      |418 |
|6 |      MERGE GROUP BY           |             |100      |418 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |387 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 25(end)  ************** 

***************   Case 26   ***************

SQL: select t1.c1 from t1, t2 limit 100; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |LIMIT                        |        |100      |414 |
|1 | NESTED-LOOP JOIN CARTESIAN  |        |100      |413 |
|2 |  SUBPLAN SCAN               |VIEW1   |1        |228 |
|3 |   LIMIT                     |        |1        |227 |
|4 |    PX COORDINATOR           |        |1        |227 |
|5 |     EXCHANGE OUT DISTR      |:EX10000|1        |227 |
|6 |      LIMIT                  |        |1        |227 |
|7 |       PX PARTITION ITERATOR |        |1        |227 |
|8 |        TABLE SCAN           |t1      |1        |227 |
|9 |  MATERIAL                   |        |100      |160 |
|10|   SUBPLAN SCAN              |VIEW2   |100      |159 |
|11|    LIMIT                    |        |100      |158 |
|12|     PX COORDINATOR          |        |100      |156 |
|13|      EXCHANGE OUT DISTR     |:EX20000|100      |150 |
|14|       LIMIT                 |        |100      |140 |
|15|        PX PARTITION ITERATOR|        |100      |138 |
|16|         TABLE SCAN          |t2      |100      |138 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([VIEW1.t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  3 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  7 - output([t1.c1]), filter(nil), 
      force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output(nil), filter(nil)
  10 - output(nil), filter(nil), 
      access(nil)
  11 - output([1]), filter(nil), limit(100), offset(nil)
  12 - output(nil), filter(nil)
  13 - output(nil), filter(nil), dop=1
  14 - output(nil), filter(nil), limit(100), offset(nil)
  15 - output(nil), filter(nil), 
      force partition granule.
  16 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 26(end)  ************** 

***************   Case 27   ***************

SQL: select t1.c1 from t1, t2 where t1.c1=t2.c1 limit 100; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |LIMIT                          |        |100      |633 |
|1 | PX COORDINATOR                |        |100      |631 |
|2 |  EXCHANGE OUT DISTR           |:EX10001|100      |621 |
|3 |   LIMIT                       |        |100      |603 |
|4 |    HASH JOIN                  |        |100      |601 |
|5 |     PX PARTITION ITERATOR     |        |300      |233 |
|6 |      TABLE SCAN               |t2      |300      |233 |
|7 |     EXCHANGE IN DISTR         |        |167      |257 |
|8 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|167      |247 |
|9 |       PX PARTITION ITERATOR   |        |167      |230 |
|10|        TABLE SCAN             |t1      |167      |230 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil)
  8 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  9 - output([t1.c1]), filter(nil), 
      force partition granule.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 27(end)  ************** 

***************   Case 28   ***************

SQL: select t1.c1 from t1, t2, t3 where t1.c1=t2.c1       and t1.c2>t2.c2       and t2.c3=t3.c3       and t3.c1>10; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |HASH JOIN                     |        |82       |1300|
|1 | PX COORDINATOR               |        |100      |158 |
|2 |  EXCHANGE OUT DISTR          |:EX10000|100      |137 |
|3 |   PX PARTITION ITERATOR      |        |100      |93  |
|4 |    TABLE SCAN                |t3      |100      |93  |
|5 | PX COORDINATOR               |        |100      |1056|
|6 |  EXCHANGE OUT DISTR          |:EX20001|100      |1024|
|7 |   HASH JOIN                  |        |100      |954 |
|8 |    EXCHANGE IN DISTR         |        |500      |528 |
|9 |     EXCHANGE OUT DISTR (PKEY)|:EX20000|500      |481 |
|10|      PX PARTITION ITERATOR   |        |500      |387 |
|11|       TABLE SCAN             |t1      |500      |387 |
|12|    PX PARTITION ITERATOR     |        |300      |233 |
|13|     TABLE SCAN               |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t3.c3]), filter(nil)
  2 - output([t3.c3]), filter(nil), dop=1
  3 - output([t3.c3]), filter(nil), 
      force partition granule.
  4 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(10 ; MAX), 
      range_cond([t3.c1 > ?])
  5 - output([t1.c1], [t2.c3]), filter(nil)
  6 - output([t1.c1], [t2.c3]), filter(nil), dop=1
  7 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 28(end)  ************** 

***************   Case 29   ***************

SQL: select opt.t3.c2 from opt.t1,t2,t3 where t1.c1+t2.c1=t3.c1; 

==============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST  |
--------------------------------------------------------------
|0 |PX COORDINATOR                 |        |150000   |166619|
|1 | EXCHANGE OUT DISTR            |:EX10003|150000   |141301|
|2 |  HASH JOIN                    |        |150000   |87585 |
|3 |   PX PARTITION ITERATOR       |        |200      |155   |
|4 |    TABLE SCAN                 |t3      |200      |155   |
|5 |   EXCHANGE IN DISTR           |        |150000   |50629 |
|6 |    EXCHANGE OUT DISTR (PKEY)  |:EX10002|150000   |36655 |
|7 |     NESTED-LOOP JOIN CARTESIAN|        |150000   |8483  |
|8 |      EXCHANGE IN DISTR        |        |300      |280   |
|9 |       EXCHANGE OUT DISTR      |:EX10000|300      |263   |
|10|        PX PARTITION ITERATOR  |        |300      |233   |
|11|         TABLE SCAN            |t2      |300      |233   |
|12|      MATERIAL                 |        |500      |468   |
|13|       EXCHANGE IN DISTR       |        |500      |466   |
|14|        EXCHANGE OUT DISTR     |:EX10001|500      |439   |
|15|         PX PARTITION ITERATOR |        |500      |387   |
|16|          TABLE SCAN           |t1      |500      |387   |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t3.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t3.c2)]), filter(nil), dop=1
  2 - output([t3.c2]), filter(nil), 
      equal_conds([t1.c1 + t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1], [t3.c2]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1 + t2.c1]), filter(nil)
  6 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1 + t2.c1]), filter(nil), is_single, dop=1
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  8 - output([t2.c1]), filter(nil)
  9 - output([t2.c1]), filter(nil), dop=1
  10 - output([t2.c1]), filter(nil), 
      force partition granule.
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1]), filter(nil)
  13 - output([t1.c1]), filter(nil)
  14 - output([t1.c1]), filter(nil), dop=1
  15 - output([t1.c1]), filter(nil), 
      force partition granule.
  16 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 29(end)  ************** 

***************   Case 30   ***************

SQL: select t1.c1 from t1,t2,t3 where t1.c1=t3.c1 and t1.c2=t2.c2 and t2.c3=t3.c3; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |HASH JOIN                     |        |4        |1673|
|1 | PX COORDINATOR               |        |200      |1022|
|2 |  EXCHANGE OUT DISTR          |:EX10001|200      |965 |
|3 |   HASH JOIN                  |        |200      |842 |
|4 |    PX PARTITION ITERATOR     |        |500      |387 |
|5 |     TABLE SCAN               |t1      |500      |387 |
|6 |    EXCHANGE IN DISTR         |        |200      |285 |
|7 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |244 |
|8 |      PX PARTITION ITERATOR   |        |200      |155 |
|9 |       TABLE SCAN             |t3      |200      |155 |
|10| PX COORDINATOR               |        |300      |428 |
|11|  EXCHANGE OUT DISTR          |:EX20000|300      |366 |
|12|   PX PARTITION ITERATOR      |        |300      |233 |
|13|    TABLE SCAN                |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t2.c2], [t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t3.c1], [t3.c3]), filter(nil)
  7 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c3]), filter(nil), 
      force partition granule.
  9 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t2.c2], [t2.c3]), filter(nil)
  11 - output([t2.c2], [t2.c3]), filter(nil), dop=1
  12 - output([t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  13 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 30(end)  ************** 

***************   Case 31   ***************

SQL: select t1.c1 from t1,t2,t3 where t1.c1=t2.c1 and t1.c1+t2.c1=t3.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |300      |1342|
|1 | EXCHANGE OUT DISTR             |:EX10002|300      |1303|
|2 |  HASH JOIN                     |        |300      |1221|
|3 |   PX PARTITION ITERATOR        |        |200      |155 |
|4 |    TABLE SCAN                  |t3      |200      |155 |
|5 |   EXCHANGE IN DISTR            |        |300      |943 |
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|300      |915 |
|7 |     HASH JOIN                  |        |300      |859 |
|8 |      EXCHANGE IN DISTR         |        |300      |280 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|10|        PX PARTITION ITERATOR   |        |300      |233 |
|11|         TABLE SCAN             |t2      |300      |233 |
|12|      PX PARTITION ITERATOR     |        |500      |387 |
|13|       TABLE SCAN               |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 + t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c1 + t2.c1]), filter(nil)
  6 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1], [t1.c1 + t2.c1]), filter(nil), dop=1
  7 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t2.c1]), filter(nil)
  9 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  10 - output([t2.c1]), filter(nil), 
      force partition granule.
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 31(end)  ************** 

***************   Case 32   ***************

SQL: select t1.c1 from t1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN               |        |487      |7244|
|1 | HASH JOIN                     |        |811      |1519|
|2 |  PX COORDINATOR               |        |200      |822 |
|3 |   EXCHANGE OUT DISTR          |:EX10001|200      |796 |
|4 |    HASH JOIN                  |        |200      |741 |
|5 |     EXCHANGE IN DISTR         |        |200      |187 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |176 |
|7 |       PX PARTITION ITERATOR   |        |200      |155 |
|8 |        TABLE SCAN             |t3      |200      |155 |
|9 |     PX PARTITION ITERATOR     |        |500      |387 |
|10|      TABLE SCAN               |t1      |500      |387 |
|11|  PX COORDINATOR               |        |500      |528 |
|12|   EXCHANGE OUT DISTR          |:EX20000|500      |481 |
|13|    PX PARTITION ITERATOR      |        |500      |387 |
|14|     TABLE SCAN                |tt      |500      |387 |
|15| MATERIAL                      |        |300      |281 |
|16|  PX COORDINATOR               |        |300      |280 |
|17|   EXCHANGE OUT DISTR          |:EX30000|300      |263 |
|18|    PX PARTITION ITERATOR      |        |300      |233 |
|19|     TABLE SCAN                |t2      |300      |233 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil)
  6 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  7 - output([t3.c1]), filter(nil), 
      force partition granule.
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([tt.c1], [tt.c2]), filter(nil)
  12 - output([tt.c1], [tt.c2]), filter(nil), dop=1
  13 - output([tt.c1], [tt.c2]), filter(nil), 
      force partition granule.
  14 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c1]), range(MIN ; MAX)always true
  15 - output([t2.c1]), filter(nil)
  16 - output([t2.c1]), filter(nil)
  17 - output([t2.c1]), filter(nil), dop=1
  18 - output([t2.c1]), filter(nil), 
      force partition granule.
  19 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 32(end)  ************** 

***************   Case 33   ***************

SQL: select t1.c1 from t1, (select * from t2) as t where t1.c1=t.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |943 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |915 |
|2 |  HASH JOIN                  |        |300      |859 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t2      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |500      |387 |
|8 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 33(end)  ************** 

***************   Case 34   ***************

SQL: select t1.c1 from t1, (select * from t2 where c2>1 order by c1 limit 10) as t where t1.c1=t.c1; 

================================================================
|ID|OPERATOR                           |NAME    |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                     |        |10       |213 |
|1 | EXCHANGE OUT DISTR                |:EX10002|10       |212 |
|2 |  NESTED-LOOP JOIN                 |        |10       |210 |
|3 |   EXCHANGE IN DISTR               |        |10       |144 |
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10001|10       |143 |
|5 |     SUBPLAN SCAN                  |t       |10       |142 |
|6 |      LIMIT                        |        |10       |142 |
|7 |       EXCHANGE IN MERGE SORT DISTR|        |10       |142 |
|8 |        EXCHANGE OUT DISTR         |:EX10000|10       |141 |
|9 |         TOP-N SORT                |        |10       |139 |
|10|          PX PARTITION ITERATOR    |        |10       |137 |
|11|           TABLE SCAN              |t2      |10       |137 |
|12|   PX PARTITION ITERATOR           |        |1        |29  |
|13|    TABLE GET                      |t1      |1        |29  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t.c1]), batch_join=false
  3 - output([PARTITION_ID], [t.c1]), filter(nil)
  4 - (#keys=1, [t.c1]), output([PARTITION_ID], [t.c1]), filter(nil), is_single, dop=1
  5 - output([t.c1]), filter(nil), 
      access([t.c1])
  6 - output([t2.c1]), filter(nil), limit(10), offset(nil)
  7 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC])
  8 - output([t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), topn(10), local merge sort
  10 - output([t2.c1]), filter(nil), 
      force partition granule.
  11 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      limit(10), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 34(end)  ************** 

***************   Case 35   ***************

SQL: select c1, c1+c2 from t1 where c1 > 100 order by c2 + c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |1        |228 |
|1 | EXCHANGE OUT DISTR       |:EX10000|1        |228 |
|2 |  SORT                    |        |1        |227 |
|3 |   PX PARTITION ITERATOR  |        |1        |227 |
|4 |    TABLE SCAN            |t1      |1        |227 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1 + t1.c2)]), filter(nil), sort_keys([t1.c2 + t1.c1, ASC])
  1 - output([t1.c2 + t1.c1], [INTERNAL_FUNCTION(t1.c1, t1.c1 + t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2 + t1.c1], [t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2 + t1.c1, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(100 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 35(end)  ************** 

***************   Case 36   ***************

SQL: select * from t1,t2 where t1.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 36(end)  ************** 

***************   Case 37   ***************

SQL: select t1.c1, t2.c2, t2.c3 from t1,t2 where t1.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1160|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1075|
|2 |  HASH JOIN                  |        |300      |891 |
|3 |   EXCHANGE IN DISTR         |        |500      |466 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |439 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 37(end)  ************** 

***************   Case 38   ***************

SQL: select c2 from t1 order by c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |631 |
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |584 |
|2 |  SORT                    |        |500      |490 |
|3 |   PX PARTITION ITERATOR  |        |500      |387 |
|4 |    TABLE SCAN            |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 38(end)  ************** 

***************   Case 39   ***************

SQL: select t1.c1, t2.c2, t2.c3 from t1,t2 where t1.c1 = t2.c1 order by t1.c2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |300      |1471|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1375|
|2 |  SORT                        |        |300      |1165|
|3 |   HASH JOIN                  |        |300      |954 |
|4 |    EXCHANGE IN DISTR         |        |500      |528 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|6 |      PX PARTITION ITERATOR   |        |500      |387 |
|7 |       TABLE SCAN             |t1      |500      |387 |
|8 |    PX PARTITION ITERATOR     |        |300      |233 |
|9 |     TABLE SCAN               |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2], [INTERNAL_FUNCTION(t1.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c2], [t1.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c2], [t1.c1]), filter(nil)
  5 - (#keys=1, [t1.c1]), output([t1.c2], [t1.c1]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 39(end)  ************** 

***************   Case 40   ***************

SQL: select /*+ INDEX(t1 INVALID_INDEX) */ c1 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 40(end)  ************** 

***************   Case 41   ***************

SQL: select c1 from t1 as t order by c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |567 |
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |540 |
|2 |  SORT                    |        |500      |488 |
|3 |   PX PARTITION ITERATOR  |        |500      |387 |
|4 |    TABLE SCAN            |t       |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t.c1)]), filter(nil), sort_keys([t.c1, ASC])
  1 - output([t.c1], [INTERNAL_FUNCTION(t.c1)]), filter(nil), dop=1
  2 - output([t.c1]), filter(nil), sort_keys([t.c1, ASC]), local merge sort
  3 - output([t.c1]), filter(nil), 
      force partition granule.
  4 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 41(end)  ************** 

***************   Case 42   ***************

SQL: select c1,c2 from t19 where c1 = 1 order by c1, c2 desc; 

===========================================
|ID|OPERATOR  |NAME        |EST. ROWS|COST|
-------------------------------------------
|0 |TABLE SCAN|t19(Reverse)|100      |78  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2]), filter(nil), 
      access([t19.c1], [t19.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t19.c1 = ?])

*************** Case 42(end)  ************** 

***************   Case 43   ***************

SQL: select c1,c2 from t19 where c1 = 1 and c2 = 1 order by c2, c3 desc; 

===========================================
|ID|OPERATOR  |NAME        |EST. ROWS|COST|
-------------------------------------------
|0 |TABLE SCAN|t19(Reverse)|100      |78  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2]), filter(nil), 
      access([t19.c1], [t19.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,1,MIN,MIN ; 1,1,MAX,MAX), 
      range_cond([t19.c1 = ?], [t19.c2 = ?])

*************** Case 43(end)  ************** 

***************   Case 44   ***************

SQL: select c1, c1+c2 from t1 where c1 > 100 limit 1, 10; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |LIMIT                    |        |0        |228 |
|1 | PX COORDINATOR          |        |1        |228 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |227 |
|3 |   LIMIT                 |        |1        |227 |
|4 |    PX PARTITION ITERATOR|        |1        |227 |
|5 |     TABLE SCAN          |t1      |1        |227 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), limit(10), offset(?)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), limit(10 + ?), offset(nil)
  4 - output([t1.c1], [t1.c2], [10 + ?]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2], [10 + ?]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(10 + ?), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(100 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 44(end)  ************** 

***************   Case 45   ***************

SQL: select * from t1 where c1 in (3, 4); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |2        |92  |
|1 | EXCHANGE OUT DISTR    |:EX10000|2        |92  |
|2 |  PX PARTITION ITERATOR|        |2        |91  |
|3 |   TABLE GET           |t1      |2        |91  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[3-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], [4 ; 4], 
      range_cond([t1.c1 IN (?, ?)])

*************** Case 45(end)  ************** 

***************   Case 46   ***************

SQL: select * from t1 where c1 in (3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p3), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 46(end)  ************** 

***************   Case 47   ***************

SQL: select * from t2 left join t3 on t2.c1=t3.c1 and t2.c2<t3.c2 where t2.c3>t3.c3; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |23       |699 |
|1 | EXCHANGE OUT DISTR          |:EX10001|23       |689 |
|2 |  HASH JOIN                  |        |23       |665 |
|3 |   EXCHANGE IN DISTR         |        |200      |310 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |261 |
|5 |     PX PARTITION ITERATOR   |        |200      |155 |
|6 |      TABLE SCAN             |t3      |200      |155 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t3.c1], [t2.c3], [t3.c3], [t2.c2], [t3.c2]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds([t2.c3 > t3.c3], [t2.c2 < t3.c2])
  3 - output([t3.c1], [t3.c3], [t3.c2]), filter(nil)
  4 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c3], [t3.c2]), filter(nil), dop=1
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 47(end)  ************** 

***************   Case 48   ***************

SQL: select t1.c1 from t1 left join t2 on t1.c1=t2.c1 where t2.c2>1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |257      |981 |
|1 | EXCHANGE OUT DISTR          |:EX10001|257      |947 |
|2 |  HASH JOIN                  |        |257      |877 |
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |257      |308 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|257      |284 |
|7 |     PX PARTITION ITERATOR   |        |257      |236 |
|8 |      TABLE SCAN             |t2      |257      |236 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  7 - output([t2.c1]), filter(nil), 
      force partition granule.
  8 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 48(end)  ************** 

***************   Case 49   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 and t1.c1>1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |1460|
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |1300|
|2 |  HASH OUTER JOIN            |        |500      |950 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |285      |232 |
|8 |    TABLE SCAN               |t2      |285      |232 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c1 > ?])
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(1 ; MAX), 
      range_cond([t2.c1 > ?])

*************** Case 49(end)  ************** 

***************   Case 50   ***************

SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is null; 

=========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST|
---------------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN       |        |25       |803 |
|1 | PX COORDINATOR             |        |500      |528 |
|2 |  EXCHANGE OUT DISTR        |:EX10000|500      |481 |
|3 |   PX PARTITION ITERATOR    |        |500      |387 |
|4 |    TABLE SCAN              |t1      |500      |387 |
|5 | MATERIAL                   |        |1        |137 |
|6 |  SUBPLAN SCAN              |VIEW1   |1        |137 |
|7 |   LIMIT                    |        |1        |137 |
|8 |    PX COORDINATOR          |        |1        |137 |
|9 |     EXCHANGE OUT DISTR     |:EX20000|1        |137 |
|10|      LIMIT                 |        |1        |137 |
|11|       PX PARTITION ITERATOR|        |1        |137 |
|12|        TABLE SCAN          |t2      |1        |137 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [?], [?], [?]), filter(nil), 
      conds([t1.c1 > ?]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output(nil), filter(nil)
  6 - output(nil), filter(nil), 
      access(nil)
  7 - output([1]), filter(nil), limit(1), offset(nil)
  8 - output(nil), filter(nil)
  9 - output(nil), filter(nil), dop=1
  10 - output(nil), filter(nil), limit(1), offset(nil)
  11 - output(nil), filter(nil), 
      force partition granule.
  12 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 50(end)  ************** 

***************   Case 51   ***************

SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |150000   |8729|
|1 | PX COORDINATOR           |        |300      |464 |
|2 |  EXCHANGE OUT DISTR      |:EX10000|300      |391 |
|3 |   PX PARTITION ITERATOR  |        |300      |233 |
|4 |    TABLE SCAN            |t2      |300      |233 |
|5 | MATERIAL                 |        |500      |531 |
|6 |  PX COORDINATOR          |        |500      |528 |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500      |481 |
|8 |    PX PARTITION ITERATOR |        |500      |387 |
|9 |     TABLE SCAN           |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 51(end)  ************** 

***************   Case 52   ***************

SQL: select /*+no_use_px*/ t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1198|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1183|
|2 |  HASH JOIN                     |        |120      |1150|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |798 |
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |779 |
|7 |     HASH JOIN                  |        |200      |741 |
|8 |      EXCHANGE IN DISTR         |        |200      |187 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |176 |
|10|        PX PARTITION ITERATOR   |        |200      |155 |
|11|         TABLE SCAN             |t3      |200      |155 |
|12|      PX PARTITION ITERATOR     |        |500      |387 |
|13|       TABLE SCAN               |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  7 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1]), filter(nil)
  9 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  10 - output([t3.c1]), filter(nil), 
      force partition granule.
  11 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 52(end)  ************** 

***************   Case 53   ***************

SQL: select t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2,t3, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN               |        |487      |7244|
|1 | HASH JOIN                     |        |811      |1519|
|2 |  PX COORDINATOR               |        |200      |822 |
|3 |   EXCHANGE OUT DISTR          |:EX10001|200      |796 |
|4 |    HASH JOIN                  |        |200      |741 |
|5 |     EXCHANGE IN DISTR         |        |200      |187 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |176 |
|7 |       PX PARTITION ITERATOR   |        |200      |155 |
|8 |        TABLE SCAN             |t3      |200      |155 |
|9 |     PX PARTITION ITERATOR     |        |500      |387 |
|10|      TABLE SCAN               |t1      |500      |387 |
|11|  PX COORDINATOR               |        |500      |528 |
|12|   EXCHANGE OUT DISTR          |:EX20000|500      |481 |
|13|    PX PARTITION ITERATOR      |        |500      |387 |
|14|     TABLE SCAN                |tt      |500      |387 |
|15| MATERIAL                      |        |300      |281 |
|16|  PX COORDINATOR               |        |300      |280 |
|17|   EXCHANGE OUT DISTR          |:EX30000|300      |263 |
|18|    PX PARTITION ITERATOR      |        |300      |233 |
|19|     TABLE SCAN                |t2      |300      |233 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds([t1.c1 + t2.c1 = tt.c1]), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [tt.c1]), filter(nil), 
      equal_conds([t1.c2 = tt.c2]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1]), filter(nil)
  6 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  7 - output([t3.c1]), filter(nil), 
      force partition granule.
  8 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([tt.c1], [tt.c2]), filter(nil)
  12 - output([tt.c1], [tt.c2]), filter(nil), dop=1
  13 - output([tt.c1], [tt.c2]), filter(nil), 
      force partition granule.
  14 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c1]), range(MIN ; MAX)always true
  15 - output([t2.c1]), filter(nil)
  16 - output([t2.c1]), filter(nil)
  17 - output([t2.c1]), filter(nil), dop=1
  18 - output([t2.c1]), filter(nil), 
      force partition granule.
  19 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 53(end)  ************** 

***************   Case 54   ***************

SQL: select /*+no_use_px*/ t1.c1 from t1 left join t2 t on t1.c1=t.c1,t2 left join t3 on t2.c1=t3.c1, t1 tt where t1.c1=t3.c1 and t1.c2=tt.c2 and t1.c1+t2.c1=tt.c1; 

================================================================
|ID|OPERATOR                           |NAME    |EST. ROWS|COST|
----------------------------------------------------------------
|0 |PX COORDINATOR                     |        |1        |1596|
|1 | EXCHANGE OUT DISTR                |:EX10003|1        |1596|
|2 |  NESTED-LOOP JOIN                 |        |1        |1595|
|3 |   EXCHANGE IN DISTR               |        |3        |1579|
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10002|3        |1579|
|5 |     HASH JOIN                     |        |3        |1578|
|6 |      EXCHANGE IN DISTR            |        |300      |980 |
|7 |       EXCHANGE OUT DISTR (PKEY)   |:EX10001|300      |941 |
|8 |        HASH JOIN                  |        |300      |859 |
|9 |         EXCHANGE IN DISTR         |        |300      |280 |
|10|          EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|11|           PX PARTITION ITERATOR   |        |300      |233 |
|12|            TABLE SCAN             |t2      |300      |233 |
|13|         PX PARTITION ITERATOR     |        |500      |387 |
|14|          TABLE SCAN               |t1      |500      |387 |
|15|      PX PARTITION ITERATOR        |        |500      |387 |
|16|       TABLE SCAN                  |tt      |500      |387 |
|17|   PX PARTITION ITERATOR           |        |1        |12  |
|18|    TABLE GET                      |t3      |1        |12  |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [PARTITION_ID]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 + t2.c1 = tt.c1], [t1.c2 = tt.c2]), other_conds(nil)
  6 - output([t1.c1], [t1.c1 + t2.c1], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1 + t2.c1]), output([t1.c1], [t1.c1 + t2.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t2.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  9 - output([t2.c1]), filter(nil)
  10 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  11 - output([t2.c1]), filter(nil), 
      force partition granule.
  12 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  15 - output([tt.c1], [tt.c2]), filter(nil), 
      affinitize, force partition granule.
  16 - output([tt.c1], [tt.c2]), filter(nil), 
      access([tt.c1], [tt.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([tt.c1]), range(MIN ; MAX)always true
  17 - output(nil), filter(nil), 
      affinitize, force partition granule.
  18 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([? = t3.c1])

*************** Case 54(end)  ************** 

***************   Case 55   ***************

SQL: select * from t1 where true; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 55(end)  ************** 

***************   Case 56   ***************

SQL: select * from t1 left join t2 t on t1.c1=t.c1 where false; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |1464|
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |1304|
|2 |  HASH OUTER JOIN            |        |500      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t       |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t.c1, t.c2, t.c3)]), filter(nil), startup_filter([0])
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t.c1, t.c2, t.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t.c1], [t1.c2], [t.c2], [t.c3]), filter(nil), 
      equal_conds([t1.c1 = t.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 56(end)  ************** 

***************   Case 57   ***************

SQL: select * from t_time where c1 is NULL; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|50       |80  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter([(T_OP_IS, cast(t_time.c1, BIGINT(-1, 0)), NULL, 1)]), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_time.c1]), range(MIN ; MAX)always true

*************** Case 57(end)  ************** 

***************   Case 58   ***************

SQL: select * from t_time where c1 is NULL and c1 < '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|50       |80  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter([(T_OP_IS, cast(t_time.c1, BIGINT(-1, 0)), NULL, 1)]), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_time.c1]), range(NULL ; 2017-01-02), 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) < ?])

*************** Case 58(end)  ************** 

***************   Case 59   ***************

SQL: select * from t_time where c1 is NULL or c1 < '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|56       |80  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter([(T_OP_IS, cast(t_time.c1, BIGINT(-1, 0)), NULL, 1) OR cast(t_time.c1, DATETIME(-1, -1)) < ?]), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_time.c1]), range(MIN ; MAX)always true

*************** Case 59(end)  ************** 

***************   Case 60   ***************

SQL: select * from t_time where c1 is NULL and c1 > '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|50       |80  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter([(T_OP_IS, cast(t_time.c1, BIGINT(-1, 0)), NULL, 1)]), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_time.c1]), range(2017-01-02 ; MAX), 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) > ?])

*************** Case 60(end)  ************** 

***************   Case 61   ***************

SQL: select * from t_time where c1 is NULL or c1 > '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|95       |80  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter([(T_OP_IS, cast(t_time.c1, BIGINT(-1, 0)), NULL, 1) OR cast(t_time.c1, DATETIME(-1, -1)) > ?]), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_time.c1]), range(MIN ; MAX)always true

*************** Case 61(end)  ************** 

***************   Case 62   ***************

SQL: select * from t_time where c1 <=> '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) <=> ?])

*************** Case 62(end)  ************** 

***************   Case 63   ***************

SQL: select * from t_time where not c1 <=> '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|99       |80  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter([(T_OP_NOT, cast(t_time.c1, DATETIME(-1, -1)) <=> ?)]), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_time.c1]), range(MIN ; MAX)always true

*************** Case 63(end)  ************** 

***************   Case 64   ***************

SQL: select * from t_time where c1 > '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|100      |78  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(2017-01-02 ; MAX), 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) > ?])

*************** Case 64(end)  ************** 

***************   Case 65   ***************

SQL: select * from t_time where c1 < '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|100      |78  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(NULL ; 2017-01-02), 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) < ?])

*************** Case 65(end)  ************** 

***************   Case 66   ***************

SQL: select * from t_time where c1 = '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) = ?])

*************** Case 66(end)  ************** 

***************   Case 67   ***************

SQL: select * from t_time where c1 > '2017-01-02' and c1 < '2017-01-03'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|100      |78  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(2017-01-02 ; 2017-01-03), 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) > ?], [cast(t_time.c1, DATETIME(-1, -1)) < ?])

*************** Case 67(end)  ************** 

***************   Case 68   ***************

SQL: select * from t_time where c1 > '2017-01-02' and c1 < '2017-01-03' and c1 < '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|100      |78  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(MAX ; MIN)always false, 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) > ?], [cast(t_time.c1, DATETIME(-1, -1)) < ?], [cast(t_time.c1, DATETIME(-1, -1)) < ?])

*************** Case 68(end)  ************** 

***************   Case 69   ***************

SQL: select * from t_time where c1 > '2017-01-01' and c1 < '2017-01-03' and c1 = '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) > ?], [cast(t_time.c1, DATETIME(-1, -1)) < ?], [cast(t_time.c1, DATETIME(-1, -1)) = ?])

*************** Case 69(end)  ************** 

***************   Case 70   ***************

SQL: select * from t_time where c1 > '2017-01-02' and c1 < '2017-01-03' and c1 = '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range(MAX ; MIN)always false, 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) > ?], [cast(t_time.c1, DATETIME(-1, -1)) < ?], [cast(t_time.c1, DATETIME(-1, -1)) = ?])

*************** Case 70(end)  ************** 

***************   Case 71   ***************

SQL: select * from t_time where c1 >= '2017-01-02' and c1 <= '2017-01-03'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|100      |78  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-03], 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) >= ?], [cast(t_time.c1, DATETIME(-1, -1)) <= ?])

*************** Case 71(end)  ************** 

***************   Case 72   ***************

SQL: select * from t_time where c1 >= '2017-01-02' and c1 <= '2017-01-03' and c1 <= '2017-01-02'; 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|t_time|1        |46  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) >= ?], [cast(t_time.c1, DATETIME(-1, -1)) <= ?], [cast(t_time.c1, DATETIME(-1, -1)) <= ?])

*************** Case 72(end)  ************** 

***************   Case 73   ***************

SQL: select * from t_time where c1 >= '2017-01-01' and c1 <= '2017-01-03' and c1 = '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) >= ?], [cast(t_time.c1, DATETIME(-1, -1)) <= ?], [cast(t_time.c1, DATETIME(-1, -1)) = ?])

*************** Case 73(end)  ************** 

***************   Case 74   ***************

SQL: select * from t_time where c1 >= '2017-01-02' and c1 <= '2017-01-03' and c1 = '2017-01-02'; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|t_time|1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t_time.c1]), filter(nil), 
      access([t_time.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_time.c1]), range[2017-01-02 ; 2017-01-02], 
      range_cond([cast(t_time.c1, DATETIME(-1, -1)) >= ?], [cast(t_time.c1, DATETIME(-1, -1)) <= ?], [cast(t_time.c1, DATETIME(-1, -1)) = ?])

*************** Case 74(end)  ************** 

***************   Case 75   ***************

SQL: select usec_to_time(c1) as modify_time_us from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(usec_to_time(cast(t1.c1, BIGINT(-1, 0))))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(usec_to_time(cast(t1.c1, BIGINT(-1, 0))))]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 75(end)  ************** 

***************   Case 76   ***************

SQL: select c1, repeat('ob', 2) as db_name from t1 order by c2 limit 100; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |100      |279 |
|1 | PX COORDINATOR MERGE SORT |             |100      |278 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |100      |268 |
|3 |   TOP-N SORT              |             |100      |250 |
|4 |    PX PARTITION ITERATOR  |             |100      |229 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|100      |229 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(100), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 76(end)  ************** 

***************   Case 77   ***************

SQL: select 'ob' from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(?)]), filter(nil), dop=1
  2 - output(nil), filter(nil), 
      force partition granule.
  3 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 77(end)  ************** 

***************   Case 78   ***************

SQL: select c1, 'ob' from t1 where c1 > 100 order by c2; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |1        |228 |
|1 | EXCHANGE OUT DISTR       |:EX10000|1        |228 |
|2 |  SORT                    |        |1        |227 |
|3 |   PX PARTITION ITERATOR  |        |1        |227 |
|4 |    TABLE SCAN            |t1      |1        |227 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, ?)]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2], [INTERNAL_FUNCTION(t1.c1, ?)]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(100 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 78(end)  ************** 

***************   Case 79   ***************

SQL: select c1, 1 + 1 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, ?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, ?)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 79(end)  ************** 

***************   Case 80   ***************

SQL: select c1, 1 + 1 from t1 order by c1 limit 100; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |100      |267 |
|1 | PX COORDINATOR MERGE SORT |        |100      |265 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|100      |260 |
|3 |   TOP-N SORT              |        |100      |249 |
|4 |    PX PARTITION ITERATOR  |        |100      |229 |
|5 |     TABLE SCAN            |t1      |100      |229 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [?]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), topn(100), local merge sort
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 80(end)  ************** 

***************   Case 81   ***************

SQL: select c1 from t1 union select c2 from t2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |800      |1152|
|1 | EXCHANGE OUT DISTR          |:EX10001|800      |1108|
|2 |  HASH UNION DISTINCT        |        |800      |1025|
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |300      |280 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|7 |     PX PARTITION ITERATOR   |        |300      |233 |
|8 |      TABLE SCAN             |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c2]), filter(nil)
  6 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  7 - output([t2.c2]), filter(nil), 
      force partition granule.
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 81(end)  ************** 

***************   Case 82   ***************

SQL: select c1 from t1 union all select c2 from t2; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |UNION ALL               |        |800      |760 |
|1 | PX COORDINATOR         |        |500      |466 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|3 |   PX PARTITION ITERATOR|        |500      |387 |
|4 |    TABLE SCAN          |t1      |500      |387 |
|5 | PX COORDINATOR         |        |300      |280 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300      |263 |
|7 |   PX PARTITION ITERATOR|        |300      |233 |
|8 |    TABLE SCAN          |t2      |300      |233 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c2]), filter(nil)
  6 - output([t2.c2]), filter(nil), dop=1
  7 - output([t2.c2]), filter(nil), 
      force partition granule.
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 82(end)  ************** 

***************   Case 83   ***************

SQL: (select c1 from t1) except (select c2 from t2) order by c1; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |500      |1473|
|1 | EXCHANGE OUT DISTR           |:EX10001|500      |1445|
|2 |  SORT                        |        |500      |1394|
|3 |   HASH EXCEPT DISTINCT       |        |500      |1025|
|4 |    PX PARTITION ITERATOR     |        |500      |387 |
|5 |     TABLE SCAN               |t1      |500      |387 |
|6 |    EXCHANGE IN DISTR         |        |300      |280 |
|7 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|8 |      PX PARTITION ITERATOR   |        |300      |233 |
|9 |       TABLE SCAN             |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(EXCEPT([1]))]), filter(nil), sort_keys([EXCEPT([1]), ASC])
  1 - output([EXCEPT([1])], [INTERNAL_FUNCTION(EXCEPT([1]))]), filter(nil), dop=1
  2 - output([EXCEPT([1])]), filter(nil), sort_keys([EXCEPT([1]), ASC])
  3 - output([EXCEPT([1])]), filter(nil)
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c2]), filter(nil)
  7 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  8 - output([t2.c2]), filter(nil), 
      force partition granule.
  9 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 83(end)  ************** 

***************   Case 84   ***************

SQL: (select c1 from t1) intersect (select c2 from t2) order by c1 limit 100; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |LIMIT                          |        |100      |955 |
|1 | PX COORDINATOR MERGE SORT     |        |100      |953 |
|2 |  EXCHANGE OUT DISTR           |:EX10001|100      |948 |
|3 |   TOP-N SORT                  |        |100      |937 |
|4 |    HASH INTERSECT DISTINCT    |        |300      |881 |
|5 |     PX PARTITION ITERATOR     |        |500      |387 |
|6 |      TABLE SCAN               |t1      |500      |387 |
|7 |     EXCHANGE IN DISTR         |        |300      |280 |
|8 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|9 |       PX PARTITION ITERATOR   |        |300      |233 |
|10|        TABLE SCAN             |t2      |300      |233 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil), limit(100), offset(nil)
  1 - output([INTERSECT([1])]), filter(nil), sort_keys([INTERSECT([1]), ASC])
  2 - output([INTERSECT([1])]), filter(nil), dop=1
  3 - output([INTERSECT([1])]), filter(nil), sort_keys([INTERSECT([1]), ASC]), topn(100)
  4 - output([INTERSECT([1])]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c2]), filter(nil)
  8 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  9 - output([t2.c2]), filter(nil), 
      force partition granule.
  10 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 84(end)  ************** 

***************   Case 85   ***************

SQL: (select c1 from t1) union (select c1 from t2) order by c1; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |800      |1785|
|1 | EXCHANGE OUT DISTR           |:EX10001|800      |1741|
|2 |  SORT                        |        |800      |1659|
|3 |   HASH UNION DISTINCT        |        |800      |1025|
|4 |    PX PARTITION ITERATOR     |        |500      |387 |
|5 |     TABLE SCAN               |t1      |500      |387 |
|6 |    EXCHANGE IN DISTR         |        |300      |280 |
|7 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|8 |      PX PARTITION ITERATOR   |        |300      |233 |
|9 |       TABLE SCAN             |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), sort_keys([UNION([1]), ASC])
  1 - output([UNION([1])], [INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil), sort_keys([UNION([1]), ASC])
  3 - output([UNION([1])]), filter(nil)
  4 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil)
  7 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 85(end)  ************** 

***************   Case 86   ***************

SQL: (select c1 from t1) union all (select c1 from t2) order by c1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SORT                     |        |800      |1393|
|1 | UNION ALL               |        |800      |760 |
|2 |  PX COORDINATOR         |        |500      |466 |
|3 |   EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
|6 |  PX COORDINATOR         |        |300      |280 |
|7 |   EXCHANGE OUT DISTR    |:EX20000|300      |263 |
|8 |    PX PARTITION ITERATOR|        |300      |233 |
|9 |     TABLE SCAN          |t2      |300      |233 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), sort_keys([UNION([1]), ASC])
  1 - output([UNION([1])]), filter(nil)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 86(end)  ************** 

***************   Case 87   ***************

SQL: (select c2 from t1 order by c1) union (select c1 from t1 order by c2); 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR               |             |1000     |1459|
|1 | EXCHANGE OUT DISTR          |:EX10001     |1000     |1404|
|2 |  HASH UNION DISTINCT        |             |1000     |1301|
|3 |   PX PARTITION ITERATOR     |             |500      |387 |
|4 |    TABLE SCAN               |t1           |500      |387 |
|5 |   EXCHANGE IN DISTR         |             |500      |466 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000     |500      |439 |
|7 |     PX PARTITION ITERATOR   |             |500      |387 |
|8 |      TABLE SCAN             |t1(idx_t1_c2)|500      |387 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  7 - output([t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 87(end)  ************** 

***************   Case 88   ***************

SQL: (select c2 from t1 order by c1) union all (select c1 from t1 order by c2); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1000     |950 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1000     |894 |
|2 |  PX PARTITION ITERATOR|        |1000     |792 |
|3 |   UNION ALL           |        |1000     |792 |
|4 |    TABLE SCAN         |t1      |500      |387 |
|5 |    TABLE SCAN         |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil), 
      partition wise, force partition granule.
  3 - output([UNION([1])]), filter(nil)
  4 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 88(end)  ************** 

***************   Case 89   ***************

SQL: (select c1 from t1 order by c2) union (select c1 from t2 order by c2 limit 2); 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |502      |1001|
|1 | EXCHANGE OUT DISTR               |:EX10002|502      |954 |
|2 |  HASH UNION DISTINCT             |        |502      |860 |
|3 |   PX PARTITION ITERATOR          |        |500      |387 |
|4 |    TABLE SCAN                    |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR              |        |2        |248 |
|6 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|2        |247 |
|7 |     LIMIT                        |        |2        |247 |
|8 |      EXCHANGE IN MERGE SORT DISTR|        |2        |247 |
|9 |       EXCHANGE OUT DISTR         |:EX10000|2        |247 |
|10|        TOP-N SORT                |        |2        |247 |
|11|         PX PARTITION ITERATOR    |        |300      |233 |
|12|          TABLE SCAN              |t2      |300      |233 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), is_single, dop=1
  7 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  8 - output([t2.c1]), filter(nil), sort_keys([t2.c2, ASC])
  9 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  10 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 89(end)  ************** 

***************   Case 90   ***************

SQL: (select c1 from t1 order by c2) union all (select c1 from t2 order by c2 limit 2); 

=========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST|
---------------------------------------------------------
|0 |UNION ALL                   |        |502      |722 |
|1 | PX COORDINATOR             |        |500      |466 |
|2 |  EXCHANGE OUT DISTR        |:EX10000|500      |439 |
|3 |   PX PARTITION ITERATOR    |        |500      |387 |
|4 |    TABLE SCAN              |t1      |500      |387 |
|5 | LIMIT                      |        |2        |247 |
|6 |  PX COORDINATOR MERGE SORT |        |2        |247 |
|7 |   EXCHANGE OUT DISTR       |:EX20000|2        |247 |
|8 |    TOP-N SORT              |        |2        |247 |
|9 |     PX PARTITION ITERATOR  |        |300      |233 |
|10|      TABLE SCAN            |t2      |300      |233 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c2, ASC])
  7 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 90(end)  ************** 

***************   Case 91   ***************

SQL: (select c1 from t1 order by c2) union (select c1 from t2 order by c2 limit 2) union (select c1 from t1 order by c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH DISTINCT                |        |1        |1436|
|1 | UNION ALL                   |        |1002     |1196|
|2 |  PX COORDINATOR             |        |500      |466 |
|3 |   EXCHANGE OUT DISTR        |:EX10000|500      |439 |
|4 |    PX PARTITION ITERATOR    |        |500      |387 |
|5 |     TABLE SCAN              |t1      |500      |387 |
|6 |  LIMIT                      |        |2        |247 |
|7 |   PX COORDINATOR MERGE SORT |        |2        |247 |
|8 |    EXCHANGE OUT DISTR       |:EX20000|2        |247 |
|9 |     TOP-N SORT              |        |2        |247 |
|10|      PX PARTITION ITERATOR  |        |300      |233 |
|11|       TABLE SCAN            |t2      |300      |233 |
|12|  PX COORDINATOR             |        |500      |466 |
|13|   EXCHANGE OUT DISTR        |:EX30000|500      |439 |
|14|    PX PARTITION ITERATOR    |        |500      |387 |
|15|     TABLE SCAN              |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), 
      distinct([UNION([1])])
  1 - output([UNION([1])]), filter(nil)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  7 - output([t2.c1]), filter(nil), sort_keys([t2.c2, ASC])
  8 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  9 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1]), filter(nil)
  13 - output([t1.c1]), filter(nil), dop=1
  14 - output([t1.c1]), filter(nil), 
      force partition granule.
  15 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 91(end)  ************** 

***************   Case 92   ***************

SQL: (select c1 from t1 order by c2) union all (select c1 from t2 order by c2 limit 2) union all (select c1 from t1 order by c1); 

=========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST|
---------------------------------------------------------
|0 |UNION ALL                   |        |1002     |1196|
|1 | PX COORDINATOR             |        |500      |466 |
|2 |  EXCHANGE OUT DISTR        |:EX10000|500      |439 |
|3 |   PX PARTITION ITERATOR    |        |500      |387 |
|4 |    TABLE SCAN              |t1      |500      |387 |
|5 | LIMIT                      |        |2        |247 |
|6 |  PX COORDINATOR MERGE SORT |        |2        |247 |
|7 |   EXCHANGE OUT DISTR       |:EX20000|2        |247 |
|8 |    TOP-N SORT              |        |2        |247 |
|9 |     PX PARTITION ITERATOR  |        |300      |233 |
|10|      TABLE SCAN            |t2      |300      |233 |
|11| PX COORDINATOR             |        |500      |466 |
|12|  EXCHANGE OUT DISTR        |:EX30000|500      |439 |
|13|   PX PARTITION ITERATOR    |        |500      |387 |
|14|    TABLE SCAN              |t1      |500      |387 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  6 - output([t2.c1]), filter(nil), sort_keys([t2.c2, ASC])
  7 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  9 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), dop=1
  13 - output([t1.c1]), filter(nil), 
      force partition granule.
  14 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 92(end)  ************** 

***************   Case 93   ***************

SQL: (select c1 from t1 order by c2 limit 2) union (select c1 from t2 order by c2 limit 2); 

==============================================================
|ID|OPERATOR                    |NAME         |EST. ROWS|COST|
--------------------------------------------------------------
|0 |HASH UNION DISTINCT         |             |4        |477 |
|1 | LIMIT                      |             |2        |228 |
|2 |  PX COORDINATOR MERGE SORT |             |2        |228 |
|3 |   EXCHANGE OUT DISTR       |:EX10000     |2        |228 |
|4 |    TOP-N SORT              |             |2        |228 |
|5 |     PX PARTITION ITERATOR  |             |2        |227 |
|6 |      TABLE SCAN            |t1(idx_t1_c2)|2        |227 |
|7 | LIMIT                      |             |2        |247 |
|8 |  PX COORDINATOR MERGE SORT |             |2        |247 |
|9 |   EXCHANGE OUT DISTR       |:EX20000     |2        |247 |
|10|    TOP-N SORT              |             |2        |247 |
|11|     PX PARTITION ITERATOR  |             |300      |233 |
|12|      TABLE SCAN            |t2           |300      |233 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil), limit(2), offset(nil)
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(2), local merge sort
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(2), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  8 - output([t2.c1]), filter(nil), sort_keys([t2.c2, ASC])
  9 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  10 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 93(end)  ************** 

***************   Case 94   ***************

SQL: (select c1 from t1 order by c2 limit 2) union all (select c1 from t2 order by c2 limit 2); 

==============================================================
|ID|OPERATOR                    |NAME         |EST. ROWS|COST|
--------------------------------------------------------------
|0 |UNION ALL                   |             |4        |475 |
|1 | LIMIT                      |             |2        |228 |
|2 |  PX COORDINATOR MERGE SORT |             |2        |228 |
|3 |   EXCHANGE OUT DISTR       |:EX10000     |2        |228 |
|4 |    TOP-N SORT              |             |2        |228 |
|5 |     PX PARTITION ITERATOR  |             |2        |227 |
|6 |      TABLE SCAN            |t1(idx_t1_c2)|2        |227 |
|7 | LIMIT                      |             |2        |247 |
|8 |  PX COORDINATOR MERGE SORT |             |2        |247 |
|9 |   EXCHANGE OUT DISTR       |:EX20000     |2        |247 |
|10|    TOP-N SORT              |             |2        |247 |
|11|     PX PARTITION ITERATOR  |             |300      |233 |
|12|      TABLE SCAN            |t2           |300      |233 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil), limit(2), offset(nil)
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(2), local merge sort
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(2), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t2.c1]), filter(nil), limit(2), offset(nil)
  8 - output([t2.c1]), filter(nil), sort_keys([t2.c2, ASC])
  9 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  10 - output([t2.c1], [t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  12 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 94(end)  ************** 

***************   Case 95   ***************

SQL: (select c1 from t1) union (select c2 from t1) union (select c2 from t2); 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |HASH DISTINCT            |             |1        |1545|
|1 | UNION ALL               |             |1300     |1234|
|2 |  PX COORDINATOR         |             |500      |466 |
|3 |   EXCHANGE OUT DISTR    |:EX10000     |500      |439 |
|4 |    PX PARTITION ITERATOR|             |500      |387 |
|5 |     TABLE SCAN          |t1           |500      |387 |
|6 |  PX COORDINATOR         |             |500      |466 |
|7 |   EXCHANGE OUT DISTR    |:EX20000     |500      |439 |
|8 |    PX PARTITION ITERATOR|             |500      |387 |
|9 |     TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
|10|  PX COORDINATOR         |             |300      |280 |
|11|   EXCHANGE OUT DISTR    |:EX30000     |300      |263 |
|12|    PX PARTITION ITERATOR|             |300      |233 |
|13|     TABLE SCAN          |t2           |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), 
      distinct([UNION([1])])
  1 - output([UNION([1])]), filter(nil)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t1.c2]), filter(nil)
  7 - output([t1.c2]), filter(nil), dop=1
  8 - output([t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  10 - output([t2.c2]), filter(nil)
  11 - output([t2.c2]), filter(nil), dop=1
  12 - output([t2.c2]), filter(nil), 
      force partition granule.
  13 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 95(end)  ************** 

***************   Case 96   ***************

SQL: (select /*+no_use_px*/ c1 from t1) union (select c2 from t1) union (select c2 from t2) order by c1 limit 100; 

=======================================================================
|ID|OPERATOR                             |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------------
|0 |LIMIT                                |             |1        |1176|
|1 | MERGE DISTINCT                      |             |1        |1176|
|2 |  SORT                               |             |100      |1171|
|3 |   UNION ALL                         |             |300      |968 |
|4 |    LIMIT                            |             |100      |267 |
|5 |     PX COORDINATOR MERGE SORT       |             |100      |265 |
|6 |      EXCHANGE OUT DISTR             |:EX10000     |100      |260 |
|7 |       TOP-N SORT                    |             |100      |249 |
|8 |        PX PARTITION ITERATOR        |             |100      |229 |
|9 |         TABLE SCAN                  |t1           |100      |229 |
|10|    LIMIT                            |             |100      |273 |
|11|     PX COORDINATOR MERGE SORT       |             |100      |272 |
|12|      EXCHANGE OUT DISTR             |:EX20001     |100      |266 |
|13|       LIMIT                         |             |100      |256 |
|14|        MERGE DISTINCT               |             |100      |254 |
|15|         EXCHANGE IN MERGE SORT DISTR|             |100      |249 |
|16|          EXCHANGE OUT DISTR (HASH)  |:EX20000     |100      |244 |
|17|           PX PARTITION ITERATOR     |             |100      |234 |
|18|            MERGE DISTINCT           |             |100      |234 |
|19|             TABLE SCAN              |t1(idx_t1_c2)|100      |229 |
|20|    LIMIT                            |             |100      |422 |
|21|     PX COORDINATOR MERGE SORT       |             |100      |421 |
|22|      EXCHANGE OUT DISTR             |:EX30001     |100      |415 |
|23|       TOP-N SORT                    |             |100      |405 |
|24|        HASH DISTINCT                |             |100      |386 |
|25|         EXCHANGE IN DISTR           |             |100      |341 |
|26|          EXCHANGE OUT DISTR (HASH)  |:EX30000     |100      |335 |
|27|           HASH DISTINCT             |             |100      |325 |
|28|            PX PARTITION ITERATOR    |             |300      |233 |
|29|             TABLE SCAN              |t2           |300      |233 |
=======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), limit(100), offset(nil)
  1 - output([UNION([1])]), filter(nil), 
      distinct([UNION([1])])
  2 - output([UNION([1])]), filter(nil), sort_keys([UNION([1]), ASC])
  3 - output([UNION([1])]), filter(nil)
  4 - output([t1.c1]), filter(nil), limit(100), offset(nil)
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  6 - output([t1.c1]), filter(nil), dop=1
  7 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), topn(100), local merge sort
  8 - output([t1.c1]), filter(nil), 
      force partition granule.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(100), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  11 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  12 - output([t1.c2]), filter(nil), dop=1
  13 - output([t1.c2]), filter(nil), limit(100), offset(nil)
  14 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  15 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  16 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  17 - output([t1.c2]), filter(nil), 
      force partition granule.
  18 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  19 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  20 - output([t2.c2]), filter(nil), limit(100), offset(nil)
  21 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  22 - output([t2.c2]), filter(nil), dop=1
  23 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC]), topn(100)
  24 - output([t2.c2]), filter(nil), 
      distinct([t2.c2])
  25 - output([t2.c2]), filter(nil)
  26 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  27 - output([t2.c2]), filter(nil), 
      distinct([t2.c2])
  28 - output([t2.c2]), filter(nil), 
      force partition granule.
  29 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 96(end)  ************** 

***************   Case 97   ***************

SQL: (select c1 from t1) union (select c2 from t1) intersect (select c2 from t2) order by c1 limit 100; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |TOP-N SORT                     |             |100      |2028|
|1 | HASH INTERSECT DISTINCT       |             |300      |1971|
|2 |  PX COORDINATOR               |             |1000     |1459|
|3 |   EXCHANGE OUT DISTR          |:EX10001     |1000     |1404|
|4 |    HASH UNION DISTINCT        |             |1000     |1301|
|5 |     PX PARTITION ITERATOR     |             |500      |387 |
|6 |      TABLE SCAN               |t1           |500      |387 |
|7 |     EXCHANGE IN DISTR         |             |500      |466 |
|8 |      EXCHANGE OUT DISTR (PKEY)|:EX10000     |500      |439 |
|9 |       PX PARTITION ITERATOR   |             |500      |387 |
|10|        TABLE SCAN             |t1(idx_t1_c2)|500      |387 |
|11|  PX COORDINATOR               |             |300      |280 |
|12|   EXCHANGE OUT DISTR          |:EX20000     |300      |263 |
|13|    PX PARTITION ITERATOR      |             |300      |233 |
|14|     TABLE SCAN                |t2           |300      |233 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil), sort_keys([INTERSECT([1]), ASC]), topn(100)
  1 - output([INTERSECT([1])]), filter(nil)
  2 - output([UNION([1])]), filter(nil)
  3 - output([UNION([1])]), filter(nil), dop=1
  4 - output([UNION([1])]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t1.c2]), filter(nil)
  8 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  9 - output([t1.c2]), filter(nil), 
      force partition granule.
  10 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  11 - output([t2.c2]), filter(nil)
  12 - output([t2.c2]), filter(nil), dop=1
  13 - output([t2.c2]), filter(nil), 
      force partition granule.
  14 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 97(end)  ************** 

***************   Case 98   ***************

SQL: select distinct(c2) from t1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |445 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |440 |
|2 |  MERGE DISTINCT               |             |100      |430 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |425 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |419 |
|5 |     PX PARTITION ITERATOR     |             |100      |409 |
|6 |      MERGE DISTINCT           |             |100      |409 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |387 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  3 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 98(end)  ************** 

***************   Case 99   ***************

SQL: select/*+(use_order_distinct)*/ distinct(c1) from t4; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE DISTINCT|    |10       |82  |
|1 | TABLE SCAN   |t4  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 99(end)  ************** 

***************   Case 100   ***************

SQL: select distinct c1, c2 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 100(end)  ************** 

***************   Case 101   ***************

SQL: select distinct c1, c2 from t4; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|100      |78  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 101(end)  ************** 

***************   Case 102   ***************

SQL: select distinct(t1.c2), t2.c2 from t1, t2 where t1.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |300      |1462|
|1 | EXCHANGE OUT DISTR               |:EX10002|300      |1411|
|2 |  MERGE DISTINCT                  |        |300      |1304|
|3 |   EXCHANGE IN MERGE SORT DISTR   |        |300      |1286|
|4 |    EXCHANGE OUT DISTR (HASH)     |:EX10001|300      |1235|
|5 |     MERGE DISTINCT               |        |300      |1128|
|6 |      SORT                        |        |300      |1110|
|7 |       HASH JOIN                  |        |300      |897 |
|8 |        EXCHANGE IN DISTR         |        |300      |317 |
|9 |         EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |289 |
|10|          PX PARTITION ITERATOR   |        |300      |233 |
|11|           TABLE SCAN             |t2      |300      |233 |
|12|        PX PARTITION ITERATOR     |        |500      |387 |
|13|         TABLE SCAN               |t1      |500      |387 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, t2.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2, t2.c2)]), filter(nil), dop=1
  2 - output([t1.c2], [t2.c2]), filter(nil), 
      distinct([t1.c2], [t2.c2])
  3 - output([t1.c2], [t2.c2]), filter(nil), sort_keys([t1.c2, ASC], [t2.c2, ASC])
  4 - (#keys=2, [t1.c2], [t2.c2]), output([t1.c2], [t2.c2]), filter(nil), dop=1
  5 - output([t1.c2], [t2.c2]), filter(nil), 
      distinct([t1.c2], [t2.c2])
  6 - output([t1.c2], [t2.c2]), filter(nil), sort_keys([t1.c2, ASC], [t2.c2, ASC])
  7 - output([t1.c2], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t2.c2], [t2.c1]), filter(nil)
  9 - (#keys=1, [t2.c1]), output([t2.c2], [t2.c1]), filter(nil), dop=1
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 102(end)  ************** 

***************   Case 103   ***************

SQL: select distinct(t1.c1), t2.c2 from t1, t2 where t1.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1012|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |973 |
|2 |  HASH JOIN                  |        |300      |891 |
|3 |   EXCHANGE IN DISTR         |        |500      |466 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |439 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t2.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t2.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 103(end)  ************** 

***************   Case 104   ***************

SQL: select distinct t4.c1, t4.c2, t2.c2 from t4, t2 where t4.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |482 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |466 |
|2 |  HASH JOIN                  |        |90       |434 |
|3 |   EXCHANGE IN DISTR         |        |100      |106 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|5 |     TABLE SCAN              |t4      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |300      |233 |
|7 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t2.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t4.c1, t4.c2, t2.c2)]), filter(nil), dop=1
  2 - output([t4.c1], [t4.c2], [t2.c2]), filter(nil), 
      equal_conds([t4.c1 = t2.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1], [t4.c2]), filter(nil), is_single, dop=1
  5 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      affinitize, force partition granule.
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 104(end)  ************** 

***************   Case 105   ***************

SQL: select distinct c1 as ali_name from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 105(end)  ************** 

***************   Case 106   ***************

SQL: select distinct c2 as ali_name from t1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |445 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |440 |
|2 |  MERGE DISTINCT               |             |100      |430 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |425 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |419 |
|5 |     PX PARTITION ITERATOR     |             |100      |409 |
|6 |      MERGE DISTINCT           |             |100      |409 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |387 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  3 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 106(end)  ************** 

***************   Case 107   ***************

SQL: select distinct c1 * c2 from t1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |500      |1089|
|1 | EXCHANGE OUT DISTR            |:EX10001|500      |1042|
|2 |  MERGE DISTINCT               |        |500      |948 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |923 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|500      |877 |
|5 |     MERGE DISTINCT            |        |500      |783 |
|6 |      SORT                     |        |500      |758 |
|7 |       PX PARTITION ITERATOR   |        |500      |387 |
|8 |        TABLE SCAN             |t1      |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1 * t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1 * t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1 * t1.c2]), filter(nil), 
      distinct([t1.c1 * t1.c2])
  3 - output([t1.c1 * t1.c2]), filter(nil), sort_keys([t1.c1 * t1.c2, ASC])
  4 - (#keys=1, [t1.c1 * t1.c2]), output([t1.c1 * t1.c2]), filter(nil), dop=1
  5 - output([t1.c1 * t1.c2]), filter(nil), 
      distinct([t1.c1 * t1.c2])
  6 - output([t1.c1 * t1.c2]), filter(nil), sort_keys([t1.c1 * t1.c2, ASC])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 107(end)  ************** 

***************   Case 108   ***************

SQL: select distinct 1, 2 from t1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |LIMIT                    |        |1        |227 |
|1 | PX COORDINATOR          |        |1        |227 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |227 |
|3 |   LIMIT                 |        |1        |227 |
|4 |    PX PARTITION ITERATOR|        |1        |227 |
|5 |     TABLE SCAN          |t1      |1        |227 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?]), filter(nil), limit(1), offset(nil)
  1 - output(nil), filter(nil)
  2 - output(nil), filter(nil), dop=1
  3 - output(nil), filter(nil), limit(1), offset(nil)
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 108(end)  ************** 

***************   Case 109   ***************

SQL: select distinct c2 from t4 order by c2 limit 3; 

====================================================
|ID|OPERATOR       |NAME            |EST. ROWS|COST|
----------------------------------------------------
|0 |LIMIT          |                |3        |46  |
|1 | MERGE DISTINCT|                |3        |46  |
|2 |  TABLE SCAN   |t4(idx_t4_c2_c3)|4        |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t4.c2]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 109(end)  ************** 

***************   Case 110   ***************

SQL: select distinct c2 from t4 order by c2; 

===================================================
|ID|OPERATOR      |NAME            |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE DISTINCT|                |10       |82  |
|1 | TABLE SCAN   |t4(idx_t4_c2_c3)|100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), 
      distinct([t4.c2])
  1 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 110(end)  ************** 

***************   Case 111   ***************

SQL: select distinct c2 from t4 order by c3; 

====================================================
|ID|OPERATOR       |NAME            |EST. ROWS|COST|
----------------------------------------------------
|0 |SORT           |                |10       |85  |
|1 | MERGE DISTINCT|                |10       |82  |
|2 |  TABLE SCAN   |t4(idx_t4_c2_c3)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC])
  1 - output([t4.c3], [t4.c2]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 111(end)  ************** 

***************   Case 112   ***************

SQL: select distinct c1, c2 from t4 order by c3; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c3)|100      |78  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c3], [t4.c1], [t4.c2]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 112(end)  ************** 

***************   Case 113   ***************

SQL: select distinct c2 from t4 order by c3 limit 3; 

====================================================
|ID|OPERATOR       |NAME            |EST. ROWS|COST|
----------------------------------------------------
|0 |TOP-N SORT     |                |3        |83  |
|1 | MERGE DISTINCT|                |10       |82  |
|2 |  TABLE SCAN   |t4(idx_t4_c2_c3)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC]), topn(3)
  1 - output([t4.c3], [t4.c2]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 113(end)  ************** 

***************   Case 114   ***************

SQL: select distinct c2 from t4 order by c3 limit 3; 

====================================================
|ID|OPERATOR       |NAME            |EST. ROWS|COST|
----------------------------------------------------
|0 |TOP-N SORT     |                |3        |83  |
|1 | MERGE DISTINCT|                |10       |82  |
|2 |  TABLE SCAN   |t4(idx_t4_c2_c3)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), sort_keys([t4.c3, ASC]), topn(3)
  1 - output([t4.c3], [t4.c2]), filter(nil), 
      distinct([t4.c2])
  2 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 114(end)  ************** 

***************   Case 115   ***************

SQL: select distinct c2 from t5 order by c3 limit 3; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |LIMIT                            |        |3        |286 |
|1 | PX COORDINATOR MERGE SORT       |        |3        |286 |
|2 |  EXCHANGE OUT DISTR             |:EX10001|3        |286 |
|3 |   TOP-N SORT                    |        |3        |285 |
|4 |    MERGE DISTINCT               |        |100      |279 |
|5 |     EXCHANGE IN MERGE SORT DISTR|        |100      |274 |
|6 |      EXCHANGE OUT DISTR (HASH)  |:EX10000|100      |265 |
|7 |       PX PARTITION ITERATOR     |        |100      |246 |
|8 |        MERGE DISTINCT           |        |100      |246 |
|9 |         TABLE SCAN              |t5      |300      |233 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c2]), filter(nil), limit(3), offset(nil)
  1 - output([t5.c2]), filter(nil), sort_keys([t5.c3, ASC])
  2 - output([t5.c2], [t5.c3]), filter(nil), dop=1
  3 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC]), topn(3)
  4 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  5 - output([t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  6 - (#keys=1, [t5.c2]), output([t5.c2], [t5.c3]), filter(nil), dop=1
  7 - output([t5.c2], [t5.c3]), filter(nil), 
      force partition granule.
  8 - output([t5.c2], [t5.c3]), filter(nil), 
      distinct([t5.c2])
  9 - output([t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 115(end)  ************** 

***************   Case 116   ***************

SQL: select distinct c2 from t5 order by c3; 

==================================================================
|ID|OPERATOR                        |NAME         |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT       |             |100      |363 |
|1 | EXCHANGE OUT DISTR             |:EX10001     |100      |354 |
|2 |  SORT                          |             |100      |335 |
|3 |   MERGE DISTINCT               |             |100      |279 |
|4 |    EXCHANGE IN MERGE SORT DISTR|             |100      |274 |
|5 |     EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |265 |
|6 |      PX PARTITION ITERATOR     |             |100      |246 |
|7 |       MERGE DISTINCT           |             |100      |246 |
|8 |        TABLE SCAN              |t5(idx_t5_c2)|300      |233 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c2)]), filter(nil), sort_keys([t5.c3, ASC])
  1 - output([t5.c3], [INTERNAL_FUNCTION(t5.c2)]), filter(nil), dop=1
  2 - output([t5.c3], [t5.c2]), filter(nil), sort_keys([t5.c3, ASC])
  3 - output([t5.c3], [t5.c2]), filter(nil), 
      distinct([t5.c2])
  4 - output([t5.c3], [t5.c2]), filter(nil), sort_keys([t5.c2, ASC]), Local Order
  5 - (#keys=1, [t5.c2]), output([t5.c3], [t5.c2]), filter(nil), dop=1
  6 - output([t5.c3], [t5.c2]), filter(nil), 
      force partition granule.
  7 - output([t5.c3], [t5.c2]), filter(nil), 
      distinct([t5.c2])
  8 - output([t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 116(end)  ************** 

***************   Case 117   ***************

SQL: select * from t1 where c1 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[7 ; 7], 
      range_cond([t1.c1 = ?])

*************** Case 117(end)  ************** 

***************   Case 118   ***************

SQL: select * from t1 where c1 = 5 or c1 = 7; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |2        |92  |
|1 | EXCHANGE OUT DISTR    |:EX10000|2        |92  |
|2 |  PX PARTITION ITERATOR|        |2        |91  |
|3 |   TABLE GET           |t1      |2        |91  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0, p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], [7 ; 7], 
      range_cond([t1.c1 = ? OR t1.c1 = ?])

*************** Case 118(end)  ************** 

***************   Case 119   ***************

SQL: select * from t1 where c1 = 5 or c1 = 7 or c1 = 8; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |3        |137 |
|1 | EXCHANGE OUT DISTR    |:EX10000|3        |137 |
|2 |  PX PARTITION ITERATOR|        |3        |137 |
|3 |   TABLE GET           |t1      |3        |137 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0, p[2-3]), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], [7 ; 7], [8 ; 8], 
      range_cond([(T_OP_OR, t1.c1 = ?, t1.c1 = ?, t1.c1 = ?)])

*************** Case 119(end)  ************** 

***************   Case 120   ***************

SQL: select c1 as alias_name from t1 where c1 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[7 ; 7], 
      range_cond([t1.c1 = ?])

*************** Case 120(end)  ************** 

***************   Case 121   ***************

SQL: select * from t5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |300      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|300      |314 |
|2 |  PX PARTITION ITERATOR|        |300      |233 |
|3 |   TABLE SCAN          |t5      |300      |233 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 121(end)  ************** 

***************   Case 122   ***************

SQL: select * from t5 where c2 =3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |3        |138 |
|1 | EXCHANGE OUT DISTR    |:EX10000|3        |137 |
|2 |  PX PARTITION ITERATOR|        |3        |137 |
|3 |   TABLE SCAN          |t5      |3        |137 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(3,MIN ; 3,MAX), 
      range_cond([t5.c2 = ?])

*************** Case 122(end)  ************** 

***************   Case 123   ***************

SQL: select * from t5 where c2 = 5 and c3 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t5  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  2 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[5,7 ; 5,7], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 123(end)  ************** 

***************   Case 124   ***************

SQL: select * from t5 where c2 = 6 and c3 = 7; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t5  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  2 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[6,7 ; 6,7], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 124(end)  ************** 

***************   Case 125   ***************

SQL: select * from t5 where c2 = 11 and c3 = 8; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t5  |1        |46  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range[11,8 ; 11,8], 
      range_cond([t5.c2 = ?], [t5.c3 = ?])

*************** Case 125(end)  ************** 

***************   Case 126   ***************

SQL: select c1 from t6; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |300      |280 |
|1 | EXCHANGE OUT DISTR    |:EX10000|300      |263 |
|2 |  PX PARTITION ITERATOR|        |300      |233 |
|3 |   TABLE SCAN          |t6      |300      |233 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t6.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t6.c1)]), filter(nil), dop=1
  2 - output([t6.c1]), filter(nil), 
      force partition granule.
  3 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 126(end)  ************** 

***************   Case 127   ***************

SQL: select * from t6 where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t6  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1], [t6.c2]), filter(nil)
  1 - output([t6.c1], [t6.c2]), filter(nil)
  2 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t6.c1]), range[3 ; 3], 
      range_cond([t6.c1 = ?])

*************** Case 127(end)  ************** 

***************   Case 128   ***************

SQL: select * from t6 where c1 = 10; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t6  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t6.c1], [t6.c2]), filter(nil)
  1 - output([t6.c1], [t6.c2]), filter(nil)
  2 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t6.c1]), range[10 ; 10], 
      range_cond([t6.c1 = ?])

*************** Case 128(end)  ************** 

***************   Case 129   ***************

SQL: select t1.c2 + t2.c1 from t1, t2 where t1.c1 = t2.c2 and t1.c1 and t1.c1 = 1 and t2.c1 = 2; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |55  |
|1 | PX COORDINATOR           |        |1        |46  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t2      |1        |46  |
|4 | PX COORDINATOR           |        |1        |46  |
|5 |  EXCHANGE OUT DISTR      |:EX20000|1        |46  |
|6 |   TABLE GET              |t1      |1        |46  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2 + ?]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil)
  2 - output(nil), filter(nil), is_single, dop=1
  3 - output(nil), filter([? = t2.c2]), 
      access([t2.c2]), partitions(p2), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c2]), filter(nil)
  5 - output([t1.c2]), filter(nil), is_single, dop=1
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 129(end)  ************** 

***************   Case 130   ***************

SQL: select t1.c1 from t1,t2 where t1.c1+1=t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |501      |1036|
|1 | EXCHANGE OUT DISTR          |:EX10001|501      |989 |
|2 |  HASH JOIN                  |        |501      |895 |
|3 |   PX PARTITION ITERATOR     |        |300      |233 |
|4 |    TABLE SCAN               |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR         |        |500      |466 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |439 |
|7 |     PX PARTITION ITERATOR   |        |500      |387 |
|8 |      TABLE SCAN             |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c1 + ?]), filter(nil)
  6 - (#keys=1, [t1.c1 + ?]), output([t1.c1], [t1.c1 + ?]), filter(nil), dop=1
  7 - output([t1.c1]), filter(nil), 
      force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 130(end)  ************** 

***************   Case 131   ***************

SQL: select t1.c1, t2.c1 from t1, t2 where t1.c1 = 1 and t2.c1 = 1 and t1.c1 = t2.c1; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |EXCHANGE IN REMOTE          |    |1        |93  |
|1 | EXCHANGE OUT REMOTE        |    |1        |93  |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |92  |
|3 |   TABLE GET                |t1  |1        |46  |
|4 |   TABLE GET                |t2  |1        |46  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c1]), filter(nil)
  1 - output([t1.c1], [t2.c1]), filter(nil)
  2 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?], [t1.c1 = ?])
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?], [t2.c1 = ?])

*************** Case 131(end)  ************** 

***************   Case 132   ***************

SQL: select /*+ leading(t2 t1 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1756|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1691|
|2 |  HASH JOIN                     |        |120      |1545|
|3 |   EXCHANGE IN DISTR            |        |300      |1263|
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|300      |1167|
|5 |     HASH JOIN                  |        |300      |957 |
|6 |      PX PARTITION ITERATOR     |        |300      |233 |
|7 |       TABLE SCAN               |t2      |300      |233 |
|8 |      EXCHANGE IN DISTR         |        |500      |528 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|10|        PX PARTITION ITERATOR   |        |500      |387 |
|11|         TABLE SCAN             |t1      |500      |387 |
|12|   PX PARTITION ITERATOR        |        |200      |155 |
|13|    TABLE SCAN                  |t3      |200      |155 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t3.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 132(end)  ************** 

***************   Case 133   ***************

SQL: select /*+ leading(t2)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1743|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1677|
|2 |  HASH JOIN                     |        |120      |1532|
|3 |   EXCHANGE IN DISTR            |        |200      |970 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |875 |
|5 |     HASH JOIN                  |        |200      |668 |
|6 |      PX PARTITION ITERATOR     |        |300      |233 |
|7 |       TABLE SCAN               |t2      |300      |233 |
|8 |      EXCHANGE IN DISTR         |        |200      |310 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |261 |
|10|        PX PARTITION ITERATOR   |        |200      |155 |
|11|         TABLE SCAN             |t3      |200      |155 |
|12|   PX PARTITION ITERATOR        |        |500      |387 |
|13|    TABLE SCAN                  |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t3.c1], [t2.c2], [t2.c3], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t3.c1], [t2.c2], [t2.c3], [t3.c2], [t3.c3]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t3.c1], [t2.c2], [t2.c3], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t2.c1], [t3.c1], [t2.c2], [t2.c3], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  10 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 133(end)  ************** 

***************   Case 134   ***************

SQL: select /*+ use_merge(t2)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1625|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1560|
|2 |  HASH JOIN                     |        |120      |1414|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1057|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |993 |
|7 |     HASH JOIN                  |        |200      |853 |
|8 |      EXCHANGE IN DISTR         |        |500      |528 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|10|        PX PARTITION ITERATOR   |        |500      |387 |
|11|         TABLE SCAN             |t1      |500      |387 |
|12|      PX PARTITION ITERATOR     |        |200      |155 |
|13|       TABLE SCAN               |t3      |200      |155 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil)
  9 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 134(end)  ************** 

***************   Case 135   ***************

SQL: select /*+ use_merge(t1)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1625|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1559|
|2 |  HASH JOIN                     |        |120      |1414|
|3 |   EXCHANGE IN DISTR            |        |200      |1057|
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |993 |
|5 |     HASH JOIN                  |        |200      |853 |
|6 |      EXCHANGE IN DISTR         |        |500      |528 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|8 |        PX PARTITION ITERATOR   |        |500      |387 |
|9 |         TABLE SCAN             |t1      |500      |387 |
|10|      PX PARTITION ITERATOR     |        |200      |155 |
|11|       TABLE SCAN               |t3      |200      |155 |
|12|   PX PARTITION ITERATOR        |        |300      |233 |
|13|    TABLE SCAN                  |t2      |300      |233 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil), dop=1
  5 - output([t1.c1], [t3.c1], [t1.c2], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 135(end)  ************** 

***************   Case 136   ***************

SQL: select /*+ use_merge(t2 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1626|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1561|
|2 |  HASH JOIN                     |        |120      |1415|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1058|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |994 |
|7 |     HASH JOIN                  |        |200      |854 |
|8 |      PX PARTITION ITERATOR     |        |200      |155 |
|9 |       TABLE SCAN               |t3      |200      |155 |
|10|      EXCHANGE IN DISTR         |        |500      |528 |
|11|       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|12|        PX PARTITION ITERATOR   |        |500      |387 |
|13|         TABLE SCAN             |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 136(end)  ************** 

***************   Case 137   ***************

SQL: select /*+ use_nl(t2 t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1626|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1561|
|2 |  HASH JOIN                     |        |120      |1415|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1058|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |994 |
|7 |     HASH JOIN                  |        |200      |854 |
|8 |      PX PARTITION ITERATOR     |        |200      |155 |
|9 |       TABLE SCAN               |t3      |200      |155 |
|10|      EXCHANGE IN DISTR         |        |500      |528 |
|11|       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|12|        PX PARTITION ITERATOR   |        |500      |387 |
|13|         TABLE SCAN             |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 137(end)  ************** 

***************   Case 138   ***************

SQL: select /*+ use_merge(t2), use_nl(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1626|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1561|
|2 |  HASH JOIN                     |        |120      |1415|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1058|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |994 |
|7 |     HASH JOIN                  |        |200      |854 |
|8 |      PX PARTITION ITERATOR     |        |200      |155 |
|9 |       TABLE SCAN               |t3      |200      |155 |
|10|      EXCHANGE IN DISTR         |        |500      |528 |
|11|       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|12|        PX PARTITION ITERATOR   |        |500      |387 |
|13|         TABLE SCAN             |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 138(end)  ************** 

***************   Case 139   ***************

SQL: select /*+ ordered, use_merge(t2), use_nl(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

===============================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR                    |        |120      |3527|
|1 | EXCHANGE OUT DISTR               |:EX10002|120      |3461|
|2 |  NESTED-LOOP JOIN                |        |120      |3316|
|3 |   EXCHANGE IN DISTR              |        |300      |1304|
|4 |    EXCHANGE OUT DISTR (PKEY)     |:EX10001|300      |1208|
|5 |     MERGE JOIN                   |        |300      |998 |
|6 |      EXCHANGE IN MERGE SORT DISTR|        |500      |528 |
|7 |       EXCHANGE OUT DISTR (PKEY)  |:EX10000|500      |481 |
|8 |        PX PARTITION ITERATOR     |        |500      |387 |
|9 |         TABLE SCAN               |t1      |500      |387 |
|10|      SORT                        |        |300      |299 |
|11|       PX PARTITION ITERATOR      |        |300      |233 |
|12|        TABLE SCAN                |t2      |300      |233 |
|13|   PX PARTITION ITERATOR          |        |1        |12  |
|14|    TABLE GET                     |t3      |1        |12  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [PARTITION_ID], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  7 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([? = t3.c1])

*************** Case 139(end)  ************** 

***************   Case 140   ***************

SQL: select /*+ use_nl(t2), use_merge(t3)*/ * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c1 = t3.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1626|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1561|
|2 |  HASH JOIN                     |        |120      |1415|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1058|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |994 |
|7 |     HASH JOIN                  |        |200      |854 |
|8 |      PX PARTITION ITERATOR     |        |200      |155 |
|9 |       TABLE SCAN               |t3      |200      |155 |
|10|      EXCHANGE IN DISTR         |        |500      |528 |
|11|       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|12|        PX PARTITION ITERATOR   |        |500      |387 |
|13|         TABLE SCAN             |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t3.c1 = t1.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 140(end)  ************** 

***************   Case 141   ***************

SQL: select /*+ use_nl(t2), use_merge(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1626|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1561|
|2 |  HASH JOIN                     |        |120      |1415|
|3 |   PX PARTITION ITERATOR        |        |300      |233 |
|4 |    TABLE SCAN                  |t2      |300      |233 |
|5 |   EXCHANGE IN DISTR            |        |200      |1058|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |994 |
|7 |     HASH JOIN                  |        |200      |854 |
|8 |      PX PARTITION ITERATOR     |        |200      |155 |
|9 |       TABLE SCAN               |t3      |200      |155 |
|10|      EXCHANGE IN DISTR         |        |500      |528 |
|11|       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|12|        PX PARTITION ITERATOR   |        |500      |387 |
|13|         TABLE SCAN             |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil)
  6 - (#keys=1, [t1.c1]), output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t3.c1], [t3.c2], [t3.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil)
  11 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 141(end)  ************** 

***************   Case 142   ***************

SQL: select /*+ ordered, use_nl(t2), use_merge(t3)*/ * from t1, t2, t3 where t1.c1=t2.c1 and t3.c1 = t2.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |4674|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |4609|
|2 |  MERGE JOIN                    |        |120      |4464|
|3 |   EXCHANGE IN MERGE SORT DISTR |        |300      |4167|
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|300      |4071|
|5 |     NESTED-LOOP JOIN           |        |300      |3861|
|6 |      EXCHANGE IN DISTR         |        |500      |528 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|8 |        PX PARTITION ITERATOR   |        |500      |387 |
|9 |         TABLE SCAN             |t1      |500      |387 |
|10|      PX PARTITION ITERATOR     |        |1        |18  |
|11|       TABLE GET                |t2      |1        |18  |
|12|   SORT                         |        |200      |199 |
|13|    PX PARTITION ITERATOR       |        |200      |155 |
|14|     TABLE SCAN                 |t3      |200      |155 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t3.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, ASC]), Local Order
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  6 - output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil)
  7 - (#keys=1, [t1.c1]), output([t1.c1], [PARTITION_ID], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? = t2.c1])
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c1, ASC]), local merge sort
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      affinitize, force partition granule.
  14 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 142(end)  ************** 

***************   Case 143   ***************

SQL: select /*+ index(t5 idx_t5_c2) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |299 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |298 |
|2 |  PX PARTITION ITERATOR|             |6        |297 |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|6        |297 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 143(end)  ************** 

***************   Case 144   ***************

SQL: select /*+ index(t5 idx_t5_c3) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |299 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |298 |
|2 |  PX PARTITION ITERATOR|             |6        |297 |
|3 |   TABLE SCAN          |t5(idx_t5_c3)|6        |297 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c3], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 144(end)  ************** 

***************   Case 145   ***************

SQL: select /*+ index(t5 primary) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |242 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |241 |
|2 |  PX PARTITION ITERATOR|        |6        |240 |
|3 |   TABLE SCAN          |t5      |6        |240 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 145(end)  ************** 

***************   Case 146   ***************

SQL: select /*+ index(t5 idx_t5_c2) */ * from t5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |300      |411 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |300      |371 |
|2 |  PX PARTITION ITERATOR|             |300      |290 |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|300      |290 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 146(end)  ************** 

***************   Case 147   ***************

SQL: select /*+ full(t5) */ c1, c2 from t5 where c1 = 2 or c2 =5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |242 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |241 |
|2 |  PX PARTITION ITERATOR|        |6        |240 |
|3 |   TABLE SCAN          |t5      |6        |240 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 147(end)  ************** 

***************   Case 148   ***************

SQL: select c1, c2 from t5 use index for join (idx_t5_c2) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |299 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |298 |
|2 |  PX PARTITION ITERATOR|             |6        |297 |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|6        |297 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 148(end)  ************** 

***************   Case 149   ***************

SQL: select c1, c2 from t5 use index for join (idx_t5_c2, primary) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |242 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |241 |
|2 |  PX PARTITION ITERATOR|        |6        |240 |
|3 |   TABLE SCAN          |t5      |6        |240 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 149(end)  ************** 

***************   Case 150   ***************

SQL: select c1, c2 from t5 use index for order by (idx_t5_c2) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |299 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |298 |
|2 |  PX PARTITION ITERATOR|             |6        |297 |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|6        |297 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 150(end)  ************** 

***************   Case 151   ***************

SQL: select c1, c2 from t5 force index for group by (idx_t5_c2) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |299 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |298 |
|2 |  PX PARTITION ITERATOR|             |6        |297 |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|6        |297 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 151(end)  ************** 

***************   Case 152   ***************

SQL: select c1, c2 from t5 use index (primary) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |242 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |241 |
|2 |  PX PARTITION ITERATOR|        |6        |240 |
|3 |   TABLE SCAN          |t5      |6        |240 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 152(end)  ************** 

***************   Case 153   ***************

SQL: select c1, c2 from t1 ignore index (idx_t1_c2) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |402 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |401 |
|2 |  PX PARTITION ITERATOR|        |6        |400 |
|3 |   TABLE SCAN          |t1      |6        |400 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = ? OR t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 153(end)  ************** 

***************   Case 154   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c2) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |242 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |241 |
|2 |  PX PARTITION ITERATOR|        |6        |240 |
|3 |   TABLE SCAN          |t5      |6        |240 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 154(end)  ************** 

***************   Case 155   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c2, idx_t5_c3) where c1 =2 or c2 = 5; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |242 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |241 |
|2 |  PX PARTITION ITERATOR|        |6        |240 |
|3 |   TABLE SCAN          |t5      |6        |240 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 155(end)  ************** 

***************   Case 156   ***************

SQL: select c1, c2 from t5 ignore index (idx_t5_c3, primary) where c1 =2 or c2 = 5; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |6        |299 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |6        |298 |
|2 |  PX PARTITION ITERATOR|             |6        |297 |
|3 |   TABLE SCAN          |t5(idx_t5_c2)|6        |297 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t5.c1]), filter(nil), 
      force partition granule.
  3 - output([t5.c2], [t5.c1]), filter([t5.c1 = ? OR t5.c2 = ?]), 
      access([t5.c2], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 156(end)  ************** 

***************   Case 157   ***************

SQL: select max(c2) from t1 where c1 = 2; 

==============================================
|ID|OPERATOR            |NAME |EST. ROWS|COST|
----------------------------------------------
|0 |EXCHANGE IN REMOTE  |     |1        |46  |
|1 | EXCHANGE OUT REMOTE|     |1        |46  |
|2 |  SCALAR GROUP BY   |     |1        |46  |
|3 |   SUBPLAN SCAN     |VIEW1|1        |46  |
|4 |    TABLE GET       |t1   |1        |46  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t1.c2)]), filter(nil)
  1 - output([T_FUN_MAX(VIEW1.t1.c2)]), filter(nil)
  2 - output([T_FUN_MAX(VIEW1.t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW1.t1.c2)])
  3 - output([VIEW1.t1.c2]), filter(nil), 
      access([VIEW1.t1.c2])
  4 - output([t1.c2]), filter([(T_OP_IS_NOT, t1.c2, NULL, 0)]), 
      access([t1.c2]), partitions(p2), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 157(end)  ************** 

***************   Case 158   ***************

SQL: select @@sql_mode, c1 from t1 limit 1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |LIMIT                    |        |1        |227 |
|1 | PX COORDINATOR          |        |1        |227 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |227 |
|3 |   LIMIT                 |        |1        |227 |
|4 |    PX PARTITION ITERATOR|        |1        |227 |
|5 |     TABLE SCAN          |t1      |1        |227 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 158(end)  ************** 

***************   Case 159   ***************

SQL: select 1+2 from dual; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 159(end)  ************** 

***************   Case 160   ***************

SQL: select 1 + 2 from dual where 1 > 2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter([0])
      values({?})

*************** Case 160(end)  ************** 

***************   Case 161   ***************

SQL: select c1 from t1 where c1 = 0 and c2 = 2; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t1  |1        |46  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[0 ; 0], 
      range_cond([t1.c1 = ?])

*************** Case 161(end)  ************** 

***************   Case 162   ***************

SQL: select /*+ ordered, use_merge(t3) */ * from t2, t3 where t2.c2 = t3.c1 and t2.c1 = 0 and t3.c1 = 0; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |50  |
|1 | TABLE GET                |t2  |1        |46  |
|2 | TABLE GET                |t3  |1        |46  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[0 ; 0], 
      range_cond([t2.c1 = ?])
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t3.c1]), range[0 ; 0], 
      range_cond([t3.c1 = ?])

*************** Case 162(end)  ************** 

***************   Case 163   ***************

SQL: select /*+ use_merge(t3) */ * from t2, t3 where t2.c1 = t3.c2 and t2.c1 = 0 and t3.c1 = 0; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |1        |50  |
|1 | TABLE GET                |t3  |1        |46  |
|2 | TABLE GET                |t2  |1        |46  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter([? = t3.c2]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t3.c1]), range[0 ; 0], 
      range_cond([t3.c1 = ?])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t2.c1]), range[0 ; 0], 
      range_cond([t2.c1 = ?])

*************** Case 163(end)  ************** 

***************   Case 164   ***************

SQL: select c1 as c from t1 partition (p4, p3) as t where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t   |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t.c1]), filter(nil)
  1 - output([t.c1]), filter(nil)
  2 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p3), 
      is_index_back=false, 
      range_key([t.c1]), range[3 ; 3], 
      range_cond([t.c1 = ?])

*************** Case 164(end)  ************** 

***************   Case 165   ***************

SQL: select c1 from t1 partition (p1) where c1 = 3; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 165(end)  ************** 

***************   Case 166   ***************

SQL: select count(*) from t1 partition(p1); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |82  |
|1 | EXCHANGE OUT REMOTE|    |1        |82  |
|2 |  SCALAR GROUP BY   |    |1        |81  |
|3 |   TABLE SCAN       |t1  |100      |78  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil)
  1 - output([T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  3 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 166(end)  ************** 

***************   Case 167   ***************

SQL: select * from t1 partition(p1) join t2 partition(p2) on t1.c1 = t2.c1; 

=================================================
|ID|OPERATOR            |NAME    |EST. ROWS|COST|
-------------------------------------------------
|0 |HASH JOIN           |        |100      |309 |
|1 | PX COORDINATOR     |        |100      |106 |
|2 |  EXCHANGE OUT DISTR|:EX10000|100      |97  |
|3 |   TABLE SCAN       |t1      |100      |78  |
|4 | PX COORDINATOR     |        |100      |155 |
|5 |  EXCHANGE OUT DISTR|:EX20000|100      |131 |
|6 |   TABLE SCAN       |t2      |100      |78  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), is_single, dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), is_single, dop=1
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 167(end)  ************** 

***************   Case 168   ***************

SQL: explain select * from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 168(end)  ************** 

***************   Case 169   ***************

SQL: explain format = json select * from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 169(end)  ************** 

***************   Case 170   ***************

SQL: select sum(c1) from t1 where c1 = 3 group by c2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil)
  2 - output([?]), filter(nil), 
      access([t1.c1]), partitions(p3), 
      is_index_back=false, 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 170(end)  ************** 

***************   Case 171   ***************

SQL: select sum(1) as c from t1 where c1 = 3 group by c2 having c2 = 5 order by c1 limit 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output([?]), filter(nil)
  2 - output([?]), filter([t1.c2 = ?]), 
      access([t1.c2]), partitions(p3), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[3 ; 3], 
      range_cond([t1.c1 = ?])

*************** Case 171(end)  ************** 

***************   Case 172   ***************

SQL: select sum(t7.c2) from t7, t8  where t7.c1 = t8.c1 and t7.c2 = 4 group by t7.c1 order by t7.c1 limit 1; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |LIMIT            |    |1        |56  |
|1 | NESTED-LOOP JOIN|    |1        |56  |
|2 |  TABLE SCAN     |t7  |1        |46  |
|3 |  TABLE GET      |t8  |1        |5   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), limit(1), offset(nil)
  1 - output(nil), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  2 - output([t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])

*************** Case 172(end)  ************** 

***************   Case 173   ***************

SQL: select c1, sum(c1+c2) from t2_no_part where c3 > 100 group by c2, c1; 

=========================================
|ID|OPERATOR  |NAME      |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE SCAN|t2_no_part|0        |79  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t2_no_part.c1], [cast(t2_no_part.c1 + t2_no_part.c2, DECIMAL(12, 0))]), filter([t2_no_part.c3 > ?]), 
      access([t2_no_part.c1], [t2_no_part.c3], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 173(end)  ************** 

***************   Case 174   ***************

SQL: select * from t2_no_part X, t2_no_part Y where X.c1 = Y.c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|X   |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([X.c1], [X.c2], [X.c3], [X.c1], [X.c2], [X.c3]), filter(nil), 
      access([X.c1], [X.c2], [X.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([X.c1]), range(MIN ; MAX)always true

*************** Case 174(end)  ************** 

***************   Case 175   ***************

SQL: select count(*) from t1 group by c1 having c1 = 2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([1]), filter(nil)
  1 - output([1]), filter(nil)
  2 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 175(end)  ************** 

***************   Case 176   ***************

SQL: select sum(c2) from t1 group by c1 having c1 = 2; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil)
  1 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil)
  2 - output([cast(t1.c2, DECIMAL(11, 0))]), filter(nil), 
      access([t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 176(end)  ************** 

***************   Case 177   ***************

SQL: select sum(c1) + count(c2) from t2_no_part; 

==============================================
|ID|OPERATOR       |NAME      |EST. ROWS|COST|
----------------------------------------------
|0 |SCALAR GROUP BY|          |1        |83  |
|1 | TABLE SCAN    |t2_no_part|100      |78  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t2_no_part.c1) + cast(T_FUN_COUNT(t2_no_part.c2), DECIMAL(20, 0))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2_no_part.c1)], [T_FUN_COUNT(t2_no_part.c2)])
  1 - output([t2_no_part.c1], [t2_no_part.c2]), filter(nil), 
      access([t2_no_part.c1], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 177(end)  ************** 

***************   Case 178   ***************

SQL: select sum(c1) from t2_no_part group by c2 order by sum(c1); 

=============================================
|ID|OPERATOR      |NAME      |EST. ROWS|COST|
---------------------------------------------
|0 |SORT          |          |10       |108 |
|1 | HASH GROUP BY|          |10       |106 |
|2 |  TABLE SCAN  |t2_no_part|100      |78  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t2_no_part.c1)]), filter(nil), sort_keys([T_FUN_SUM(t2_no_part.c1), ASC])
  1 - output([T_FUN_SUM(t2_no_part.c1)]), filter(nil), 
      group([t2_no_part.c2]), agg_func([T_FUN_SUM(t2_no_part.c1)])
  2 - output([t2_no_part.c1], [t2_no_part.c2]), filter(nil), 
      access([t2_no_part.c1], [t2_no_part.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t2_no_part.c1]), range(MIN ; MAX)always true

*************** Case 178(end)  ************** 

***************   Case 179   ***************

SQL: select * from t4 where c2 = 3 and c3 = 4; 

===============================================
|ID|OPERATOR  |NAME            |EST. ROWS|COST|
-----------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2_c3)|100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(3,4,MIN ; 3,4,MAX), 
      range_cond([t4.c2 = ?], [t4.c3 = ?])

*************** Case 179(end)  ************** 

***************   Case 180   ***************

SQL: select * from t4 where c1 = 2 and c2 = 3; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t4  |1        |46  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range[2,3 ; 2,3], 
      range_cond([t4.c1 = ?], [t4.c2 = ?])

*************** Case 180(end)  ************** 

***************   Case 181   ***************

SQL: select * from t4, t7 where t4.c1 + 2 + 2 = t7.c1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |205 |
|1 | TABLE SCAN|t7  |100      |78  |
|2 | TABLE SCAN|t4  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t4.c1 + ? + ? = t7.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 181(end)  ************** 

***************   Case 182   ***************

SQL: select sum(c1 + 1) from t4 group by c1, c2; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|100      |78  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(t4.c1 + ?, DECIMAL(12, 0))]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 182(end)  ************** 

***************   Case 183   ***************

SQL: select /*+ frozen_version(10) */ * from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 183(end)  ************** 

***************   Case 184   ***************

SQL: select /*+index(t4 idx_t4_c2_c3)*/ c2, c3 from t4 where c2 = 3 and c3 = 4 and c1 = 5; 

==============================================
|ID|OPERATOR |NAME            |EST. ROWS|COST|
----------------------------------------------
|0 |TABLE GET|t4(idx_t4_c2_c3)|1        |46  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range[3,4,5 ; 3,4,5], 
      range_cond([t4.c2 = ?], [t4.c3 = ?], [t4.c1 = ?])

*************** Case 184(end)  ************** 

***************   Case 185   ***************

SQL: select * from t4 where c1 = 1 and c2 > 5 and c3 > 8; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |54       |79  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c3 > ?]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(1,5 ; 1,MAX), 
      range_cond([t4.c1 = ?], [t4.c2 > ?])

*************** Case 185(end)  ************** 

***************   Case 186   ***************

SQL: select * from t4 where c1 in (1) and c2 in (1, 2, 3, 4, 5); 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t4  |5        |91  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range[1,1 ; 1,1], [1,2 ; 1,2], [1,3 ; 1,3], [1,4 ; 1,4], [1,5 ; 1,5], 
      range_cond([t4.c1 = ?], [t4.c2 IN (?, ?, ?, ?, ?)])

*************** Case 186(end)  ************** 

***************   Case 187   ***************

SQL: select * from t1 where c1 in (c1, 2, 3, 4); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |540 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |494 |
|2 |  PX PARTITION ITERATOR|        |500      |400 |
|3 |   TABLE SCAN          |t1      |500      |400 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([t1.c1 = t1.c1 OR t1.c1 IN (?, ?, ?)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 187(end)  ************** 

***************   Case 188   ***************

SQL: select * from t1 where (1+ 1) in (2); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 188(end)  ************** 

***************   Case 189   ***************

SQL: select * from t1 where 1 in (c1); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([? = t1.c1])

*************** Case 189(end)  ************** 

***************   Case 190   ***************

SQL: select * from t1 where 1 in (c1, c2); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |6        |402 |
|1 | EXCHANGE OUT DISTR    |:EX10000|6        |401 |
|2 |  PX PARTITION ITERATOR|        |6        |400 |
|3 |   TABLE SCAN          |t1      |6        |400 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([? IN (t1.c1, t1.c2)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 190(end)  ************** 

***************   Case 191   ***************

SQL: select * from t1 where c1 = 1 or c2 = 1; 

==========================================================
|ID|OPERATOR                |NAME         |EST. ROWS|COST|
----------------------------------------------------------
|0 |UNION ALL               |             |4        |274 |
|1 | PX COORDINATOR         |             |1        |46  |
|2 |  EXCHANGE OUT DISTR    |:EX10000     |1        |46  |
|3 |   TABLE GET            |t1           |1        |46  |
|4 | PX COORDINATOR         |             |3        |228 |
|5 |  EXCHANGE OUT DISTR    |:EX20000     |3        |228 |
|6 |   PX PARTITION ITERATOR|             |3        |227 |
|7 |    TABLE SCAN          |t1(idx_t1_c2)|3        |227 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([?], [t1.c2]), filter(nil)
  2 - output([t1.c2]), filter(nil), is_single, dop=1
  3 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([t1.c1], [?]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter([lnnvl(cast(t1.c1 = ?, TINYINT(-1, 0)))]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(1,MIN ; 1,MAX), 
      range_cond([t1.c2 = ?])

*************** Case 191(end)  ************** 

***************   Case 192   ***************

SQL: select * from t1 where (1+ 1) in (1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), startup_filter([0])
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 192(end)  ************** 

***************   Case 193   ***************

SQL: select * from t1 where c1 in (1, 2, 3, 4); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |4        |183 |
|1 | EXCHANGE OUT DISTR    |:EX10000|4        |183 |
|2 |  PX PARTITION ITERATOR|        |4        |182 |
|3 |   TABLE GET           |t1      |4        |182 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[1-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], [2 ; 2], [3 ; 3], [4 ; 4], 
      range_cond([t1.c1 IN (?, ?, ?, ?)])

*************** Case 193(end)  ************** 

***************   Case 194   ***************

SQL: select * from t1 where exists (select * from t2 limit 0); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SUBPLAN FILTER            |        |500      |537 |
|1 | PX COORDINATOR           |        |500      |528 |
|2 |  EXCHANGE OUT DISTR      |:EX10000|500      |481 |
|3 |   PX PARTITION ITERATOR  |        |500      |387 |
|4 |    TABLE SCAN            |t1      |500      |387 |
|5 | LIMIT                    |        |0        |0   |
|6 |  PX COORDINATOR          |        |0        |0   |
|7 |   EXCHANGE OUT DISTR     |:EX20000|0        |0   |
|8 |    LIMIT                 |        |0        |0   |
|9 |     PX PARTITION ITERATOR|        |0        |0   |
|10|      TABLE SCAN          |t2      |0        |0   |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), limit(0), offset(nil)
  6 - output(nil), filter(nil)
  7 - output(nil), filter(nil), dop=1
  8 - output(nil), filter(nil), limit(0), offset(nil)
  9 - output(nil), filter(nil), 
      force partition granule.
  10 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(0), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 194(end)  ************** 

***************   Case 195   ***************

SQL: select * from t7,t8 where t7.c1=t8.c1 order by t7.c1,t7.c2; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |188 |
|1 | TABLE SCAN|t7  |100      |78  |
|2 | TABLE SCAN|t8  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 195(end)  ************** 

***************   Case 196   ***************

SQL: select * from t7,t8 where t7.c1=t8.c2 order by t7.c1,t7.c2; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |91       |236 |
|1 | SORT       |    |100      |133 |
|2 |  TABLE SCAN|t8  |100      |78  |
|3 | TABLE SCAN |t7  |100      |78  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c2]), other_conds(nil)
  1 - output([t8.c1], [t8.c2]), filter(nil), sort_keys([t8.c2, ASC])
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 196(end)  ************** 

***************   Case 197   ***************

SQL: select c1/c2 as v,sum(c1) from t1 group by v order by v; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |        |500      |1267|
|1 | EXCHANGE OUT DISTR            |:EX10001|500      |1173|
|2 |  MERGE GROUP BY               |        |500      |973 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |943 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|500      |873 |
|5 |     MERGE GROUP BY            |        |500      |726 |
|6 |      SORT                     |        |500      |698 |
|7 |       PX PARTITION ITERATOR   |        |500      |387 |
|8 |        TABLE SCAN             |t1      |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0)), T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil), sort_keys([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0)), ASC])
  1 - output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [INTERNAL_FUNCTION(cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0)), T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil), dop=1
  2 - output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [T_FUN_SUM(t1.c1)]), filter(nil), sort_keys([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0)), ASC])
  4 - (#keys=1, [cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))]), output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  5 - output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))]), agg_func([T_FUN_SUM(t1.c1)])
  6 - output([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0))], [t1.c1]), filter(nil), sort_keys([cast(t1.c1, DECIMAL(11, 0)) / cast(t1.c2, DECIMAL(11, 0)), ASC])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 197(end)  ************** 

***************   Case 198   ***************

SQL: select c2 from t1 for update; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 198(end)  ************** 

***************   Case 199   ***************

SQL: select * from t2 where exists (select * from t6 where t2.c1=t6.c1 limit 1) for update; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |925 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |840 |
|2 |  HASH JOIN                  |        |300      |656 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t6      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t6.c1]), filter(nil)
  4 - (#keys=1, [t6.c1]), output([t6.c1]), filter(nil), dop=1
  5 - output([t6.c1]), filter(nil), 
      force partition granule.
  6 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 199(end)  ************** 

***************   Case 200   ***************

SQL: select case when t4.c1=0 then 'a' else 'b' end  from t4 order by c3, c2; 

=============================================
|ID|OPERATOR   |NAME         |EST. ROWS|COST|
---------------------------------------------
|0 |SORT       |             |100      |109 |
|1 | TABLE SCAN|t4(idx_t4_c3)|100      |78  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN t4.c1 = ? THEN ? ELSE ? END]), filter(nil), sort_keys([t4.c3, ASC], [t4.c2, ASC]), prefix_pos(1)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c3], [t4.c1], [t4.c2]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 200(end)  ************** 

***************   Case 201   ***************

SQL: select case when t4.c1=0 then 'a' else 'b' end  from t4, t9 where t4.c1 = t9.c1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |91       |180 |
|1 | TABLE SCAN|t4  |100      |78  |
|2 | TABLE SCAN|t9  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN t4.c1 = ? THEN ? ELSE ? END]), filter(nil), 
      equal_conds([t4.c1 = t9.c1]), other_conds(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t9.c1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 201(end)  ************** 

***************   Case 202   ***************

SQL: select * from t4 where t4.c1 = 1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 202(end)  ************** 

***************   Case 203   ***************

SQL: select * from t7 group by c1 order by c1 desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t7(Reverse)|100      |78  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 203(end)  ************** 

***************   Case 204   ***************

SQL: select * from t4 order by c1,c2 desc; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |SORT       |    |100      |109 |
|1 | TABLE SCAN|t4  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), sort_keys([t4.c1, ASC], [t4.c2, DESC]), prefix_pos(1)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 204(end)  ************** 

***************   Case 205   ***************

SQL: select * from t4 order by c1 desc,c2 desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t4(Reverse)|100      |78  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 205(end)  ************** 

***************   Case 206   ***************

SQL: select * from t1 order by c1 limit 2; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |2        |228 |
|1 | PX COORDINATOR MERGE SORT |        |2        |228 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|2        |228 |
|3 |   TOP-N SORT              |        |2        |228 |
|4 |    PX PARTITION ITERATOR  |        |2        |227 |
|5 |     TABLE SCAN            |t1      |2        |227 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), topn(2), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(2), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 206(end)  ************** 

***************   Case 207   ***************

SQL: select * from t1 order by c2 limit 2; 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |LIMIT                      |             |2        |228 |
|1 | PX COORDINATOR MERGE SORT |             |2        |228 |
|2 |  EXCHANGE OUT DISTR       |:EX10000     |2        |228 |
|3 |   TOP-N SORT              |             |2        |228 |
|4 |    PX PARTITION ITERATOR  |             |2        |227 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|2        |227 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), limit(2), offset(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC])
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(2), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(2), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 207(end)  ************** 

***************   Case 208   ***************

SQL: select * from t2 order by c1 limit 2; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |2        |139 |
|1 | PX COORDINATOR MERGE SORT |        |2        |139 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|2        |138 |
|3 |   TOP-N SORT              |        |2        |137 |
|4 |    PX PARTITION ITERATOR  |        |2        |137 |
|5 |     TABLE SCAN            |t2      |2        |137 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), limit(2), offset(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c1, ASC]), topn(2), local merge sort
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      limit(2), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 208(end)  ************** 

***************   Case 209   ***************

SQL: select * from t2 order by c2 limit 2; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |2        |250 |
|1 | PX COORDINATOR MERGE SORT |        |2        |250 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|2        |250 |
|3 |   TOP-N SORT              |        |2        |249 |
|4 |    PX PARTITION ITERATOR  |        |300      |233 |
|5 |     TABLE SCAN            |t2      |300      |233 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), limit(2), offset(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c2, ASC])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c2, ASC]), topn(2)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 209(end)  ************** 

***************   Case 210   ***************

SQL: select * from (select * from t4 union select * from t4) as a; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |200      |161 |
|1 | TABLE SCAN         |t4  |100      |78  |
|2 | TABLE SCAN         |t4  |100      |78  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 210(end)  ************** 

***************   Case 211   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 and t2.c1=2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |1063|
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |903 |
|2 |  HASH RIGHT OUTER JOIN      |        |500      |553 |
|3 |   EXCHANGE IN DISTR         |        |1        |47  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|5 |     TABLE GET               |t2      |1        |46  |
|6 |   PX PARTITION ITERATOR     |        |500      |387 |
|7 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2], [t2.c3]), filter(nil), is_single, dop=1
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 211(end)  ************** 

***************   Case 212   ***************

SQL: select * from t1 left join t2 on t1.c1=t2.c1 where t2.c1=2; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |EXCHANGE IN REMOTE          |    |1        |93  |
|1 | EXCHANGE OUT REMOTE        |    |1        |93  |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |92  |
|3 |   TABLE GET                |t1  |1        |46  |
|4 |   TABLE GET                |t2  |1        |46  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])

*************** Case 212(end)  ************** 

***************   Case 213   ***************

SQL: select * from t1 right join t2 on t1.c1=t2.c1 and t2.c1=2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |656 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |560 |
|2 |  HASH RIGHT OUTER JOIN      |        |300      |350 |
|3 |   EXCHANGE IN DISTR         |        |1        |46  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|5 |     TABLE GET               |t1      |1        |46  |
|6 |   PX PARTITION ITERATOR     |        |300      |233 |
|7 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), is_single, dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 213(end)  ************** 

***************   Case 214   ***************

SQL: select * from t1 right join t2 on t1.c1=t2.c1 where t2.c1=2; 

===========================================================
|ID|OPERATOR                          |NAME|EST. ROWS|COST|
-----------------------------------------------------------
|0 |EXCHANGE IN REMOTE                |    |1        |93  |
|1 | EXCHANGE OUT REMOTE              |    |1        |93  |
|2 |  NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |92  |
|3 |   TABLE GET                      |t2  |1        |46  |
|4 |   TABLE GET                      |t1  |1        |46  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 214(end)  ************** 

***************   Case 215   ***************

SQL: select * from t1 full join t2 on t1.c1=t2.c1 and t2.c1=2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |1464|
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |1304|
|2 |  HASH FULL OUTER JOIN       |        |500      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t2.c1 = ?])
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 215(end)  ************** 

***************   Case 216   ***************

SQL: select * from t1 full join t2 on t1.c1=t2.c1 where t2.c1=2; 

===========================================================
|ID|OPERATOR                          |NAME|EST. ROWS|COST|
-----------------------------------------------------------
|0 |EXCHANGE IN REMOTE                |    |1        |93  |
|1 | EXCHANGE OUT REMOTE              |    |1        |93  |
|2 |  NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |92  |
|3 |   TABLE GET                      |t2  |1        |46  |
|4 |   TABLE GET                      |t1  |1        |46  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 216(end)  ************** 

***************   Case 217   ***************

SQL: select c2 from t1 where exists (select * from t2 where t1.c1=t2.c1 limit 1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |980 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |941 |
|2 |  HASH JOIN                  |        |300      |859 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t2      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |500      |387 |
|8 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 217(end)  ************** 

***************   Case 218   ***************

SQL: select c1 from (select c1, c2 from t1 limit 1) t; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |LIMIT                    |        |1        |227 |
|1 | PX COORDINATOR          |        |1        |227 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |227 |
|3 |   LIMIT                 |        |1        |227 |
|4 |    PX PARTITION ITERATOR|        |1        |227 |
|5 |     TABLE SCAN          |t1      |1        |227 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 218(end)  ************** 

***************   Case 219   ***************

SQL: select sum(c) from (select c1 as c from t1 union select c1 as c from t1) as a; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SCALAR GROUP BY           |        |1        |848 |
|1 | PX COORDINATOR           |        |1        |848 |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |848 |
|3 |   MERGE GROUP BY         |        |1        |848 |
|4 |    SUBPLAN SCAN          |a       |1000     |813 |
|5 |     PX PARTITION ITERATOR|        |1000     |795 |
|6 |      MERGE UNION DISTINCT|        |1000     |795 |
|7 |       TABLE SCAN         |t1      |500      |387 |
|8 |       TABLE SCAN         |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(a.c))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(a.c))])
  1 - output([T_FUN_SUM(a.c)]), filter(nil)
  2 - output([T_FUN_SUM(a.c)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(a.c)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(a.c)])
  4 - output([a.c]), filter(nil), 
      access([a.c])
  5 - output([UNION([1])]), filter(nil), 
      partition wise, force partition granule.
  6 - output([UNION([1])]), filter(nil)
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 219(end)  ************** 

***************   Case 220   ***************

SQL: select * from t2 where 'cb' <= c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |0        |250 |
|1 | EXCHANGE OUT DISTR    |:EX10000|0        |250 |
|2 |  PX PARTITION ITERATOR|        |0        |250 |
|3 |   TABLE SCAN          |t2      |0        |250 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule.
  3 - output([t2.c1], [t2.c3], [t2.c2]), filter([? <= t2.c3]), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 220(end)  ************** 

***************   Case 221   ***************

SQL: select t7.c1 = t8.c2 from t7, t8 where t7.c1 = t8.c1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |187 |
|1 | TABLE SCAN|t8  |100      |78  |
|2 | TABLE SCAN|t7  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1 = t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 221(end)  ************** 

***************   Case 222   ***************

SQL: select t11.c2 from (select c1,c2 from t4 limit 1) as t11 , t6 where t11.c1>t6.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |100      |131 |
|1 | EXCHANGE OUT DISTR             |:EX10001|100      |118 |
|2 |  NESTED-LOOP JOIN              |        |100      |90  |
|3 |   EXCHANGE IN DISTR            |        |1        |46  |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|1        |46  |
|5 |     SUBPLAN SCAN               |t11     |1        |46  |
|6 |      TABLE SCAN                |t4      |1        |46  |
|7 |   PX PARTITION ITERATOR        |        |100      |19  |
|8 |    TABLE SCAN                  |t6      |100      |19  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t11.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t11.c2)]), filter(nil), dop=1
  2 - output([t11.c2]), filter(nil), 
      conds(nil), nl_params_([t11.c1]), batch_join=false
  3 - output([t11.c1], [t11.c2]), filter(nil)
  4 - output([t11.c1], [t11.c2]), filter(nil), is_single, dop=1
  5 - output([t11.c1], [t11.c2]), filter(nil), 
      access([t11.c1], [t11.c2])
  6 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  7 - output(nil), filter(nil), 
      access all, force partition granule.
  8 - output(nil), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX), 
      range_cond([? > t6.c1])

*************** Case 222(end)  ************** 

***************   Case 223   ***************

SQL: select t11.c2 from (select c1,c2 from t4) t11 left join t6 on t11.c1=1; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN   |             |2700     |1210|
|1 | TABLE SCAN              |t4(idx_t4_c2)|100      |78  |
|2 | MATERIAL                |             |300      |281 |
|3 |  PX COORDINATOR         |             |300      |280 |
|4 |   EXCHANGE OUT DISTR    |:EX10000     |300      |263 |
|5 |    PX PARTITION ITERATOR|             |300      |233 |
|6 |     TABLE SCAN          |t6           |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), 
      conds([t4.c1 = ?]), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), dop=1
  5 - output(nil), filter(nil), 
      force partition granule.
  6 - output(nil), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 223(end)  ************** 

***************   Case 224   ***************

SQL: select * from t2,t4 where t2.c1=t4.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |90       |550 |
|1 | EXCHANGE OUT DISTR          |:EX10001|90       |517 |
|2 |  HASH JOIN                  |        |90       |447 |
|3 |   EXCHANGE IN DISTR         |        |100      |118 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |105 |
|5 |     TABLE SCAN              |t4      |100      |78  |
|6 |   PX PARTITION ITERATOR     |        |300      |233 |
|7 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t4.c1, t4.c2, t4.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t4.c1, t4.c2, t4.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t4.c1], [t4.c2], [t4.c3], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t4.c1]), other_conds(nil)
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - (#keys=1, [t4.c1]), output([t4.c1], [t4.c2], [t4.c3]), filter(nil), is_single, dop=1
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 224(end)  ************** 

***************   Case 225   ***************

SQL: select * from t2,t6 where t2.c1=t6.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1000|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |904 |
|2 |  HASH JOIN                  |        |300      |694 |
|3 |   EXCHANGE IN DISTR         |        |300      |317 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |289 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t6      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2)]), filter(nil), dop=1
  2 - output([t2.c1], [t6.c1], [t6.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t6.c1], [t6.c2]), filter(nil)
  4 - (#keys=1, [t6.c1]), output([t6.c1], [t6.c2]), filter(nil), dop=1
  5 - output([t6.c1], [t6.c2]), filter(nil), 
      force partition granule.
  6 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 225(end)  ************** 

***************   Case 226   ***************

SQL: select * from t2,t6,t7 where t2.c1=t6.c1 and t6.c1=t7.c1; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |100      |942 |
|1 | EXCHANGE OUT DISTR             |:EX10002|100      |903 |
|2 |  HASH JOIN                     |        |100      |816 |
|3 |   EXCHANGE IN DISTR            |        |100      |487 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|100      |470 |
|5 |     HASH JOIN                  |        |100      |434 |
|6 |      EXCHANGE IN DISTR         |        |100      |106 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|8 |        TABLE SCAN              |t7      |100      |78  |
|9 |      PX PARTITION ITERATOR     |        |300      |233 |
|10|       TABLE SCAN               |t6      |300      |233 |
|11|   PX PARTITION ITERATOR        |        |300      |233 |
|12|    TABLE SCAN                  |t2      |300      |233 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2, t7.c1, t7.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2, t7.c1, t7.c2)]), filter(nil), dop=1
  2 - output([t2.c1], [t6.c1], [t7.c1], [t7.c2], [t6.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t6.c1], [t7.c1], [t7.c2], [t6.c2]), filter(nil)
  4 - (#keys=1, [t6.c1]), output([t6.c1], [t7.c1], [t7.c2], [t6.c2]), filter(nil), dop=1
  5 - output([t6.c1], [t7.c1], [t7.c2], [t6.c2]), filter(nil), 
      equal_conds([t6.c1 = t7.c1]), other_conds(nil)
  6 - output([t7.c1], [t7.c2]), filter(nil)
  7 - (#keys=1, [t7.c1]), output([t7.c1], [t7.c2]), filter(nil), is_single, dop=1
  8 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  9 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule.
  10 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 226(end)  ************** 

***************   Case 227   ***************

SQL: select c1 from t2 union select c1 from t6; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |600      |876 |
|1 | EXCHANGE OUT DISTR          |:EX10001|600      |843 |
|2 |  HASH UNION DISTINCT        |        |600      |781 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t2      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t6      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil)
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t6.c1]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 227(end)  ************** 

***************   Case 228   ***************

SQL: select c1 from t2 union all select c1 from t6; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |600      |570 |
|1 | EXCHANGE OUT DISTR    |:EX10000|600      |537 |
|2 |  PX PARTITION ITERATOR|        |600      |475 |
|3 |   UNION ALL           |        |600      |475 |
|4 |    TABLE SCAN         |t2      |300      |233 |
|5 |    TABLE SCAN         |t6      |300      |233 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]))]), filter(nil), dop=1
  2 - output([UNION([1])]), filter(nil), 
      partition wise, force partition granule.
  3 - output([UNION([1])]), filter(nil)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 228(end)  ************** 

***************   Case 229   ***************

SQL: select * from t2 where exists (select * from t6 where t2.c1=t6.c1 limit 1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |925 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |840 |
|2 |  HASH JOIN                  |        |300      |656 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t6      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t6.c1]), filter(nil)
  4 - (#keys=1, [t6.c1]), output([t6.c1]), filter(nil), dop=1
  5 - output([t6.c1]), filter(nil), 
      force partition granule.
  6 - output([t6.c1]), filter(nil), 
      access([t6.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 229(end)  ************** 

***************   Case 230   ***************

SQL: select * from t2 where exists (select * from t4 where t2.c1=t4.c1 limit 1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |10       |160 |
|1 | EXCHANGE OUT DISTR          |:EX10001|10       |157 |
|2 |  NESTED-LOOP JOIN           |        |10       |151 |
|3 |   EXCHANGE IN DISTR         |        |10       |84  |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|10       |83  |
|5 |     SUBPLAN SCAN            |VIEW2   |10       |82  |
|6 |      MERGE DISTINCT         |        |10       |82  |
|7 |       TABLE SCAN            |t4      |100      |78  |
|8 |   PX PARTITION ITERATOR     |        |1        |18  |
|9 |    TABLE GET                |t2      |1        |18  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_([VIEW2.VIEW1.t4.c1]), batch_join=false
  3 - output([PARTITION_ID], [VIEW2.VIEW1.t4.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.VIEW1.t4.c1]), output([PARTITION_ID], [VIEW2.VIEW1.t4.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.VIEW1.t4.c1]), filter(nil), 
      access([VIEW2.VIEW1.t4.c1])
  6 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  7 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 230(end)  ************** 

***************   Case 231   ***************

SQL: select * from t2 where exists (select * from t1 where t2.c1=t1.c1 limit 1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1160|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1075|
|2 |  HASH JOIN                  |        |300      |891 |
|3 |   EXCHANGE IN DISTR         |        |500      |466 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |439 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 231(end)  ************** 

***************   Case 232   ***************

SQL: select sum(c1) as c from t1 union select sum(c1) as c from t1; 

============================================================
|ID|OPERATOR                   |NAME        |EST. ROWS|COST|
------------------------------------------------------------
|0 |TEMP TABLE TRANSFORMATION  |            |2        |406 |
|1 | TEMP TABLE INSERT         |TEMP1       |1        |405 |
|2 |  SCALAR GROUP BY          |            |1        |405 |
|3 |   PX COORDINATOR          |            |1        |405 |
|4 |    EXCHANGE OUT DISTR     |:EX10000    |1        |405 |
|5 |     MERGE GROUP BY        |            |1        |405 |
|6 |      PX PARTITION ITERATOR|            |500      |387 |
|7 |       TABLE SCAN          |t1          |500      |387 |
|8 | MERGE UNION DISTINCT      |            |2        |1   |
|9 |  TEMP TABLE ACCESS        |VIEW1(TEMP1)|1        |1   |
|10|  TEMP TABLE ACCESS        |VIEW2(TEMP1)|1        |1   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output(nil), filter(nil)
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([UNION([1])]), filter(nil)
  9 - output([VIEW1.T_FUN_SUM(t1.c1)]), filter(nil), 
      access([VIEW1.T_FUN_SUM(t1.c1)])
  10 - output([VIEW2.T_FUN_SUM(t1.c1)]), filter(nil), 
      access([VIEW2.T_FUN_SUM(t1.c1)])

*************** Case 232(end)  ************** 

***************   Case 233   ***************

SQL: select sum(c) from (select sum(c1) as c from t1 union select sum(c1) as c from t1) as a; 

============================================================
|ID|OPERATOR                   |NAME        |EST. ROWS|COST|
------------------------------------------------------------
|0 |TEMP TABLE TRANSFORMATION  |            |1        |406 |
|1 | TEMP TABLE INSERT         |TEMP1       |1        |405 |
|2 |  SCALAR GROUP BY          |            |1        |405 |
|3 |   PX COORDINATOR          |            |1        |405 |
|4 |    EXCHANGE OUT DISTR     |:EX10000    |1        |405 |
|5 |     MERGE GROUP BY        |            |1        |405 |
|6 |      PX PARTITION ITERATOR|            |500      |387 |
|7 |       TABLE SCAN          |t1          |500      |387 |
|8 | SCALAR GROUP BY           |            |1        |1   |
|9 |  SUBPLAN SCAN             |a           |2        |1   |
|10|   MERGE UNION DISTINCT    |            |2        |1   |
|11|    TEMP TABLE ACCESS      |VIEW1(TEMP1)|1        |1   |
|12|    TEMP TABLE ACCESS      |VIEW2(TEMP1)|1        |1   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(a.c)]), filter(nil)
  1 - output(nil), filter(nil)
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)]), filter(nil)
  4 - output([T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)])
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([T_FUN_SUM(a.c)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(a.c)])
  9 - output([a.c]), filter(nil), 
      access([a.c])
  10 - output([UNION([1])]), filter(nil)
  11 - output([VIEW1.T_FUN_SUM(t1.c1)]), filter(nil), 
      access([VIEW1.T_FUN_SUM(t1.c1)])
  12 - output([VIEW2.T_FUN_SUM(t1.c1)]), filter(nil), 
      access([VIEW2.T_FUN_SUM(t1.c1)])

*************** Case 233(end)  ************** 

***************   Case 234   ***************

SQL: select * from t4 where c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |50       |80  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 234(end)  ************** 

***************   Case 235   ***************

SQL: select/*+index(t4 primary)*/ * from t4 where c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |50       |80  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 235(end)  ************** 

***************   Case 236   ***************

SQL: select * from t4, t4 t where t4.c1; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |5000     |1449|
|1 | TABLE SCAN               |t   |100      |78  |
|2 | MATERIAL                 |    |50       |81  |
|3 |  TABLE SCAN              |t4  |50       |80  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t.c1], [t.c2], [t.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1], [t.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 236(end)  ************** 

***************   Case 237   ***************

SQL: select/*+index(t4 primary)*/ * from t4, t4 t where t4.c1; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |5000     |1449|
|1 | TABLE SCAN               |t   |100      |78  |
|2 | MATERIAL                 |    |50       |81  |
|3 |  TABLE SCAN              |t4  |50       |80  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t.c1], [t.c2], [t.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t.c1], [t.c2], [t.c3]), filter(nil), 
      access([t.c1], [t.c2], [t.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1], [t.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1]), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 237(end)  ************** 

***************   Case 238   ***************

SQL: select * from t4 left join t4 a on t4.c1; 

===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP OUTER JOIN|    |5000     |1974|
|1 | TABLE SCAN           |t4  |100      |78  |
|2 | MATERIAL             |    |100      |79  |
|3 |  TABLE SCAN          |a   |100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [a.c1], [a.c2], [a.c3]), filter(nil), 
      conds([BOOL(t4.c1)]), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([a.c1], [a.c2], [a.c3]), filter(nil)
  3 - output([a.c1], [a.c2], [a.c3]), filter(nil), 
      access([a.c1], [a.c2], [a.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([a.c1], [a.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 238(end)  ************** 

***************   Case 239   ***************

SQL: select t1.c2  from t1,t2 where t2.c1 in(t1.c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |980 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |941 |
|2 |  HASH JOIN                  |        |300      |859 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t2      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |500      |387 |
|8 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 239(end)  ************** 

***************   Case 240   ***************

SQL: select  * from t3 join t4 on t3.c1>t4.c1 where t4.c1 in (t3.c1, t3.c1); 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |60       |1568|
|1 | EXCHANGE OUT DISTR             |:EX10001|60       |1547|
|2 |  NESTED-LOOP JOIN              |        |60       |1500|
|3 |   EXCHANGE IN DISTR            |        |100      |118 |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|100      |105 |
|5 |     TABLE SCAN                 |t4      |100      |78  |
|6 |   PX PARTITION ITERATOR        |        |1        |12  |
|7 |    TABLE GET                   |t3      |1        |12  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t3.c1, t3.c2, t3.c3, t4.c1, t4.c2, t4.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t3.c1, t3.c2, t3.c3, t4.c1, t4.c2, t4.c3)]), filter(nil), dop=1
  2 - output([t4.c1], [t4.c2], [t4.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_([t4.c1]), batch_join=false
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), is_single, dop=1
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access all, force partition granule.
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([? IN (t3.c1, t3.c1)], [t3.c1 > ?])

*************** Case 240(end)  ************** 

***************   Case 241   ***************

SQL: select * from t1 where c1 in (select t2.c1 from t2 left join t3 on t2.c1=t3.c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |980 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |941 |
|2 |  HASH JOIN                  |        |300      |859 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t2      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |500      |387 |
|8 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 241(end)  ************** 

***************   Case 242   ***************

SQL: select /*+use_merge(t10,t11)*/* from t10, t11 where t10.c2=t11.c2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |325      |910 |
|1 | EXCHANGE OUT DISTR    |:EX10000|325      |831 |
|2 |  PX PARTITION ITERATOR|        |325      |660 |
|3 |   MERGE JOIN          |        |325      |660 |
|4 |    SORT               |        |200      |283 |
|5 |     TABLE SCAN        |t10     |200      |155 |
|6 |    SORT               |        |200      |283 |
|7 |     TABLE SCAN        |t11     |200      |155 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t10.c1, t10.c2, t10.c3, t11.c1, t11.c2, t11.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t10.c1, t10.c2, t10.c3, t11.c1, t11.c2, t11.c3)]), filter(nil), dop=1
  2 - output([t10.c2], [t11.c2], [t10.c1], [t10.c3], [t11.c1], [t11.c3]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t10.c2], [t11.c2], [t10.c1], [t10.c3], [t11.c1], [t11.c3]), filter(nil), 
      equal_conds([t10.c2 = t11.c2]), other_conds(nil)
  4 - output([t10.c2], [t10.c1], [t10.c3]), filter(nil), sort_keys([t10.c2, ASC])
  5 - output([t10.c1], [t10.c2], [t10.c3]), filter(nil), 
      access([t10.c1], [t10.c2], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t11.c2], [t11.c1], [t11.c3]), filter(nil), sort_keys([t11.c2, ASC])
  7 - output([t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      access([t11.c1], [t11.c2], [t11.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 242(end)  ************** 

***************   Case 243   ***************

SQL: select c1 from t1 where c1 not in (select c1 from t2 where c2 not in (select c2 from t2)); 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |476      |1448|
|1 | EXCHANGE OUT DISTR           |:EX10003|476      |1421|
|2 |  HASH RIGHT ANTI JOIN        |        |476      |1373|
|3 |   EXCHANGE IN DISTR          |        |25       |752 |
|4 |    EXCHANGE OUT DISTR (PKEY) |:EX10002|25       |750 |
|5 |     SUBPLAN SCAN             |VIEW2   |25       |748 |
|6 |      HASH RIGHT ANTI JOIN NA |        |25       |747 |
|7 |       EXCHANGE IN DISTR      |        |300      |280 |
|8 |        EXCHANGE OUT DISTR    |:EX10000|300      |263 |
|9 |         PX PARTITION ITERATOR|        |300      |233 |
|10|          TABLE SCAN          |t2      |300      |233 |
|11|       EXCHANGE IN DISTR      |        |300      |317 |
|12|        EXCHANGE OUT DISTR    |:EX10001|300      |289 |
|13|         PX PARTITION ITERATOR|        |300      |233 |
|14|          TABLE SCAN          |t2      |300      |233 |
|15|   PX PARTITION ITERATOR      |        |500      |387 |
|16|    TABLE SCAN                |t1      |500      |387 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = VIEW2.c1]), other_conds(nil)
  3 - output([VIEW2.c1]), filter(nil)
  4 - (#keys=1, [VIEW2.c1]), output([VIEW2.c1]), filter(nil), is_single, dop=1
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c2 = t2.c2]), other_conds(nil)
  7 - output([t2.c2]), filter(nil)
  8 - output([t2.c2]), filter(nil), dop=1
  9 - output([t2.c2]), filter(nil), 
      force partition granule.
  10 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t2.c1], [t2.c2]), filter(nil)
  12 - output([t2.c1], [t2.c2]), filter(nil), dop=1
  13 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  14 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  15 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  16 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 243(end)  ************** 

***************   Case 244   ***************

SQL: select distinct c1 from t1 order by c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |500      |631 |
|1 | EXCHANGE OUT DISTR       |:EX10000     |500      |584 |
|2 |  SORT                    |             |500      |490 |
|3 |   PX PARTITION ITERATOR  |             |500      |387 |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 244(end)  ************** 

***************   Case 245   ***************

SQL: SELECT c1, c2  FROM t1 WHERE c2 IN (ROUND(-1), 0, '5', '1'); 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |18       |233 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |18       |231 |
|2 |  PX PARTITION ITERATOR|             |18       |228 |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|18       |228 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(-1,MIN ; -1,MAX), (0,MIN ; 0,MAX), (5,MIN ; 5,MAX), (1,MIN ; 1,MAX), 
      range_cond([t1.c2 IN (?, ?) OR cast(t1.c2, DECIMAL(11, 0)) IN (?, ?)])

*************** Case 245(end)  ************** 

***************   Case 246   ***************

SQL: select count(*) from (select count(*) as a  from t4) t ; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SCALAR GROUP BY  |    |1        |81  |
|1 | SUBPLAN SCAN    |t   |1        |81  |
|2 |  SCALAR GROUP BY|    |1        |81  |
|3 |   TABLE SCAN    |t4  |100      |78  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  3 - output(nil), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 246(end)  ************** 

***************   Case 247   ***************

SQL: (select * from t1 where c1 = 2) union all (select * from t1 where c1 = 2); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |2        |92  |
|1 | EXCHANGE OUT REMOTE|    |2        |92  |
|2 |  UNION ALL         |    |2        |91  |
|3 |   TABLE GET        |t1  |1        |46  |
|4 |   TABLE GET        |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([UNION([1])], [UNION([2])]), filter(nil)
  3 - output([?], [t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])
  4 - output([?], [t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 247(end)  ************** 

***************   Case 248   ***************

SQL: select * from t1 X, t1 Y where X.c1 = Y.c1 and X.c1 = 1 and Y.c1 = 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |X   |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([X.c1], [X.c2], [X.c1], [X.c2]), filter(nil)
  1 - output([X.c1], [X.c2], [X.c1], [X.c2]), filter(nil)
  2 - output([X.c1], [X.c2]), filter(nil), 
      access([X.c1], [X.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([X.c1]), range[1 ; 1], 
      range_cond([X.c1 = ?], [X.c1 = ?])

*************** Case 248(end)  ************** 

***************   Case 249   ***************

SQL: select distinct c2, c1 from t1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2, t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 249(end)  ************** 

***************   Case 250   ***************

SQL: select (select c1 from t7),c2 from t8; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |157 |
|1 | TABLE SCAN   |t8  |100      |78  |
|2 | TABLE SCAN   |t7  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t8.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 250(end)  ************** 

***************   Case 251   ***************

SQL: select (select c1 from t7 where c2=t8.c2), c2 from t8; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |8085|
|1 | TABLE SCAN   |t8  |100      |78  |
|2 | TABLE SCAN   |t7  |9        |80  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([subquery(1)], [t8.c2]), filter(nil), 
      exec_params_([t8.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 251(end)  ************** 

***************   Case 252   ***************

SQL: select c1 from t7 group by (select c1 from t8), c2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |HASH GROUP BY  |    |10       |183 |
|1 | SUBPLAN FILTER|    |100      |157 |
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  TABLE SCAN   |t8  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 252(end)  ************** 

***************   Case 253   ***************

SQL: select c1 from t7 group by (select c1 from t8 where c2=t7.c2),c2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |HASH GROUP BY  |    |10       |8112|
|1 | SUBPLAN FILTER|    |100      |8085|
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  TABLE SCAN   |t8  |9        |80  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([subquery(1)], [t7.c2]), agg_func(nil)
  1 - output([subquery(1)], [t7.c2], [t7.c1]), filter(nil), 
      exec_params_([t7.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter([t8.c2 = ?]), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 253(end)  ************** 

***************   Case 254   ***************

SQL: select c1, sum(c2) from t4 group by c1 having sum(c2) < (select 1); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |1        |84  |
|1 | TABLE SCAN   |t4  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [T_FUN_SUM(t4.c2)]), filter([T_FUN_SUM(t4.c2) < ?]), 
      group([t4.c1]), agg_func([T_FUN_SUM(t4.c2)])
  1 - output([t4.c1], [t4.c2]), filter(nil), 
      access([t4.c1], [t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 254(end)  ************** 

***************   Case 255   ***************

SQL: select c1 from t7 order by (select c1 from t8), c2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SORT           |    |100      |213 |
|1 | SUBPLAN FILTER|    |100      |157 |
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  TABLE SCAN   |t8  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 255(end)  ************** 

***************   Case 256   ***************

SQL: select c1 from t7 order by (select c1 from t8 where c2=t7.c2),c2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SORT           |    |100      |8142|
|1 | SUBPLAN FILTER|    |100      |8085|
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  TABLE SCAN   |t8  |9        |80  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([subquery(1), ASC], [t7.c2, ASC])
  1 - output([subquery(1)], [t7.c2], [t7.c1]), filter(nil), 
      exec_params_([t7.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter([t8.c2 = ?]), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 256(end)  ************** 

***************   Case 257   ***************

SQL: select (select 1, 2, 3)=row(1, 2, 3); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | EXPRESSION   |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1) = (?, ?, ?)]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([?], [?], [?]), filter(nil)
      values({?, ?, ?})

*************** Case 257(end)  ************** 

***************   Case 258   ***************

SQL: select count(1) from t1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |405 |
|1 | PX COORDINATOR          |        |1        |405 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |405 |
|3 |   MERGE GROUP BY        |        |1        |405 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 258(end)  ************** 

***************   Case 259   ***************

SQL: select (select 1); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 259(end)  ************** 

***************   Case 260   ***************

SQL: (select (select 1)) union (select (select 1)); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 260(end)  ************** 

***************   Case 261   ***************

SQL: SELECT distinct '' , 1 FROM DUAL limit 2 offset 1; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |LIMIT      |    |0        |1   |
|1 | EXPRESSION|    |1        |1   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?]), filter(nil), limit(2), offset(?)
  1 - output([1]), filter(nil)
      values({1})

*************** Case 261(end)  ************** 

***************   Case 262   ***************

SQL: select * from t1,t1 t; 

========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST |
--------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |250000   |13949|
|1 | PX COORDINATOR           |        |500      |528  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|500      |481  |
|3 |   PX PARTITION ITERATOR  |        |500      |387  |
|4 |    TABLE SCAN            |t1      |500      |387  |
|5 | MATERIAL                 |        |500      |531  |
|6 |  PX COORDINATOR          |        |500      |528  |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500      |481  |
|8 |    PX PARTITION ITERATOR |        |500      |387  |
|9 |     TABLE SCAN           |t       |500      |387  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t.c1], [t.c2]), filter(nil)
  6 - output([t.c1], [t.c2]), filter(nil)
  7 - output([t.c1], [t.c2]), filter(nil), dop=1
  8 - output([t.c1], [t.c2]), filter(nil), 
      force partition granule.
  9 - output([t.c1], [t.c2]), filter(nil), 
      access([t.c1], [t.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 262(end)  ************** 

***************   Case 263   ***************

SQL: select * from t1,t1 t where t1.c1<t.c1; 

==============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST |
--------------------------------------------------------------
|0 |PX COORDINATOR                  |        |83334    |80751|
|1 | EXCHANGE OUT DISTR             |:EX10001|83334    |66686|
|2 |  NESTED-LOOP JOIN              |        |83334    |36843|
|3 |   EXCHANGE IN DISTR            |        |500      |949  |
|4 |    EXCHANGE OUT DISTR (BC2HOST)|:EX10000|500      |763  |
|5 |     PX PARTITION ITERATOR      |        |500      |387  |
|6 |      TABLE SCAN                |t1      |500      |387  |
|7 |   PX PARTITION ITERATOR        |        |167      |32   |
|8 |    TABLE SCAN                  |t       |167      |32   |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t.c1, t.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t.c1, t.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t.c1], [t.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t.c1], [t.c2]), filter(nil), 
      access all, force partition granule.
  8 - output([t.c1], [t.c2]), filter(nil), 
      access([t.c1], [t.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX), 
      range_cond([? < t.c1])

*************** Case 263(end)  ************** 

***************   Case 264   ***************

SQL: (select * from t4) union (select * from t4) order by (select c1 from t4 limit 1); 

==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |SUBPLAN FILTER       |    |200      |210 |
|1 | MERGE UNION DISTINCT|    |200      |161 |
|2 |  TABLE SCAN         |t4  |100      |78  |
|3 |  TABLE SCAN         |t4  |100      |78  |
|4 | TABLE SCAN          |t4  |1        |46  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  4 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 264(end)  ************** 

***************   Case 265   ***************

SQL: select 1 from dual where 1 in (select 1 from dual); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 265(end)  ************** 

***************   Case 266   ***************

SQL: select count(c1) + 1 from t1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |405 |
|1 | PX COORDINATOR          |        |1        |405 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |405 |
|3 |   MERGE GROUP BY        |        |1        |405 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) + ?]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  1 - output([T_FUN_COUNT(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 266(end)  ************** 

***************   Case 267   ***************

SQL: select count(c1) + 1 + 1 from t1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |405 |
|1 | PX COORDINATOR          |        |1        |405 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |405 |
|3 |   MERGE GROUP BY        |        |1        |405 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) + ? + ?]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  1 - output([T_FUN_COUNT(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 267(end)  ************** 

***************   Case 268   ***************

SQL: SELECT (select max(t1.c1) from t1) as field from t1 group by field; 

================================================================
|ID|OPERATOR                        |NAME       |EST. ROWS|COST|
----------------------------------------------------------------
|0 |HASH GROUP BY                   |           |1        |576 |
|1 | NESTED-LOOP JOIN CARTESIAN     |           |500      |456 |
|2 |  SUBPLAN SCAN                  |VIEW1      |1        |228 |
|3 |   SCALAR GROUP BY              |           |1        |228 |
|4 |    SUBPLAN SCAN                |VIEW3      |1        |228 |
|5 |     LIMIT                      |           |1        |228 |
|6 |      PX COORDINATOR MERGE SORT |           |1        |228 |
|7 |       EXCHANGE OUT DISTR       |:EX10000   |1        |228 |
|8 |        TOP-N SORT              |           |1        |227 |
|9 |         PX PARTITION ITERATOR  |           |1        |227 |
|10|          TABLE SCAN            |t1(Reverse)|1        |227 |
|11|  PX COORDINATOR                |           |500      |466 |
|12|   EXCHANGE OUT DISTR           |:EX20000   |500      |439 |
|13|    PX PARTITION ITERATOR       |           |500      |387 |
|14|     TABLE SCAN                 |t1         |500      |387 |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.max(t1.c1)]), filter(nil), 
      group([VIEW1.max(t1.c1)]), agg_func(nil)
  1 - output([VIEW1.max(t1.c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.max(t1.c1)]), filter(nil), 
      access([VIEW1.max(t1.c1)])
  3 - output([T_FUN_MAX(VIEW3.t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW3.t1.c1)])
  4 - output([VIEW3.t1.c1]), filter(nil), 
      access([VIEW3.t1.c1])
  5 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  6 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC])
  7 - output([t1.c1]), filter(nil), dop=1
  8 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC]), topn(1), local merge sort
  9 - output([t1.c1]), filter(nil), 
      force partition granule.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output(nil), filter(nil)
  12 - output(nil), filter(nil), dop=1
  13 - output(nil), filter(nil), 
      force partition granule.
  14 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 268(end)  ************** 

***************   Case 269   ***************

SQL: ( SELECT * FROM t12 WHERE 69 > ROUND ( 3075 ) ) UNION ALL ( SELECT * FROM t12  ) UNION ( SELECT * FROM t13) ; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |200      |220 |
|1 | TABLE SCAN         |t13 |100      |78  |
|2 | SORT               |    |100      |136 |
|3 |  TABLE SCAN        |t12 |100      |78  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  1 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), 
      access([t13.a], [t13.b], [t13.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true
  2 - output([t12.a], [t12.b], [t12.c]), filter(nil), sort_keys([t12.c, ASC], [t12.a, ASC])
  3 - output([t12.a], [t12.b], [t12.c]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true

*************** Case 269(end)  ************** 

***************   Case 270   ***************

SQL: select t1.c1, nvl(t2.c2,0) from (select c1,c2 from t1 where c1=0 or c1=1) as t1 left join (select c1,c2 from t1 where c1=0) as t2 on t1.c1=t2.c1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN  |        |2        |100 |
|1 | PX COORDINATOR         |        |2        |92  |
|2 |  EXCHANGE OUT DISTR    |:EX10000|2        |91  |
|3 |   PX PARTITION ITERATOR|        |2        |91  |
|4 |    TABLE GET           |t1      |2        |91  |
|5 | TABLE GET              |t1      |1        |4   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [nvl(cast(t1.c2, BIGINT(1, 0)), ?)]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=true
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t1.c1]), range[0 ; 0], [1 ; 1], 
      range_cond([t1.c1 = ? OR t1.c1 = ?])
  5 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?], [? = t1.c1])

*************** Case 270(end)  ************** 

***************   Case 271   ***************

SQL: (select * from t12 where a != 1 limit 7 ) union (select * from t13) union ( select * from t13); 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH DISTINCT|    |1        |260 |
|1 | UNION ALL   |    |207      |204 |
|2 |  TABLE SCAN |t12 |7        |46  |
|3 |  TABLE SCAN |t13 |100      |78  |
|4 |  TABLE SCAN |t13 |100      |78  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), 
      distinct([UNION([1])], [UNION([2])], [UNION([3])])
  1 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil)
  2 - output([cast(t12.a, CHAR(20))], [t12.b], [t12.c]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      limit(7), offset(nil), 
      is_index_back=false, 
      range_key([t12.a]), range(NULL ; 1), (1 ; MAX), 
      range_cond([t12.a != ?])
  3 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), 
      access([t13.a], [t13.b], [t13.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true
  4 - output([t13.b], [cast(t13.c, CHAR(20))], [t13.a]), filter(nil), 
      access([t13.a], [t13.b], [t13.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 271(end)  ************** 

***************   Case 272   ***************

SQL: select /*+ leading(t3, t2, t1) use_merge(t3,t2) */* from t1,t2,t3; 

===========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST   |
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |30000000 |1553486|
|1 | NESTED-LOOP JOIN CARTESIAN|        |60000    |5934   |
|2 |  PX COORDINATOR           |        |200      |310    |
|3 |   EXCHANGE OUT DISTR      |:EX10000|200      |261    |
|4 |    PX PARTITION ITERATOR  |        |200      |155    |
|5 |     TABLE SCAN            |t3      |200      |155    |
|6 |  MATERIAL                 |        |300      |471    |
|7 |   PX COORDINATOR          |        |300      |464    |
|8 |    EXCHANGE OUT DISTR     |:EX20000|300      |391    |
|9 |     PX PARTITION ITERATOR |        |300      |233    |
|10|      TABLE SCAN           |t2      |300      |233    |
|11| MATERIAL                  |        |500      |531    |
|12|  PX COORDINATOR           |        |500      |528    |
|13|   EXCHANGE OUT DISTR      |:EX30000|500      |481    |
|14|    PX PARTITION ITERATOR  |        |500      |387    |
|15|     TABLE SCAN            |t1      |500      |387    |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t1.c1], [t1.c2]), filter(nil)
  12 - output([t1.c1], [t1.c2]), filter(nil)
  13 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  14 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  15 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 272(end)  ************** 

***************   Case 273   ***************

SQL: select /*+leading(t10, t11) use_nl(t11) */ * from t10 join t11 on t10.c2 = t11.c2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |325      |2197|
|1 | EXCHANGE OUT DISTR    |:EX10000|325      |2118|
|2 |  PX PARTITION ITERATOR|        |325      |1947|
|3 |   NESTED-LOOP JOIN    |        |325      |1947|
|4 |    TABLE SCAN         |t10     |200      |155 |
|5 |    MATERIAL           |        |200      |157 |
|6 |     TABLE SCAN        |t11     |200      |155 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t10.c1, t10.c2, t10.c3, t11.c1, t11.c2, t11.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t10.c1, t10.c2, t10.c3, t11.c1, t11.c2, t11.c3)]), filter(nil), dop=1
  2 - output([t10.c2], [t11.c2], [t10.c1], [t10.c3], [t11.c1], [t11.c3]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t10.c2], [t11.c2], [t10.c1], [t10.c3], [t11.c1], [t11.c3]), filter(nil), 
      conds([t10.c2 = t11.c2]), nl_params_(nil), batch_join=false
  4 - output([t10.c1], [t10.c2], [t10.c3]), filter(nil), 
      access([t10.c1], [t10.c2], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t11.c2], [t11.c1], [t11.c3]), filter(nil)
  6 - output([t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      access([t11.c1], [t11.c2], [t11.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 273(end)  ************** 

***************   Case 274   ***************

SQL: select * from t4 where c1 not in (select c1 from t7 where t4.c1+t7.c1 >(select c1 from t8)); 

=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SUBPLAN FILTER |    |50       |15789|
|1 | TABLE SCAN    |t4  |100      |78   |
|2 | SUBPLAN FILTER|    |34       |157  |
|3 |  TABLE SCAN   |t7  |34       |79   |
|4 |  TABLE SCAN   |t8  |100      |78   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 != ALL(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter([? + t7.c1 > ?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 274(end)  ************** 

***************   Case 275   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where t7.c1>(select c1 from t8)); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |MERGE ANTI JOIN |     |10       |208 |
|1 | TABLE SCAN     |t4   |100      |78  |
|2 | SUBPLAN SCAN   |VIEW1|34       |125 |
|3 |  SUBPLAN FILTER|     |34       |124 |
|4 |   TABLE SCAN   |t7   |34       |46  |
|5 |   TABLE SCAN   |t8   |100      |78  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 > ?])
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 275(end)  ************** 

***************   Case 276   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where t7.c1>(select c1 from t8 where t4.c1=1)); 

==================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST |
--------------------------------------------------
|0 |SUBPLAN FILTER |             |50       |12526|
|1 | TABLE SCAN    |t4(idx_t4_c2)|100      |78   |
|2 | SUBPLAN FILTER|             |34       |124  |
|3 |  TABLE SCAN   |t7           |34       |46   |
|4 |  TABLE SCAN   |t8           |100      |78   |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter([t4.c1 != ALL(subquery(1))]), 
      exec_params_([t4.c1 = ?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 > ?])
  4 - output([t8.c1]), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 276(end)  ************** 

***************   Case 277   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where t4.c1>(select c1 from t8)); 

==================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST |
--------------------------------------------------
|0 |SUBPLAN FILTER |             |50       |15902|
|1 | TABLE SCAN    |t4(idx_t4_c2)|100      |78   |
|2 | SUBPLAN FILTER|             |100      |157  |
|3 |  TABLE SCAN   |t7           |100      |78   |
|4 |  TABLE SCAN   |t8           |100      |78   |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter([t4.c1 != ALL(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), startup_filter([?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 277(end)  ************** 

***************   Case 278   ***************

SQL: select c1 from t4 where c1 not in (select c1 from t7 where 1>(select c1 from t8)); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |MERGE ANTI JOIN |     |10       |243 |
|1 | TABLE SCAN     |t4   |100      |78  |
|2 | SUBPLAN SCAN   |VIEW1|100      |159 |
|3 |  SUBPLAN FILTER|     |100      |157 |
|4 |   TABLE SCAN   |t7   |100      |78  |
|5 |   TABLE SCAN   |t8   |100      |78  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1]), filter(nil), startup_filter([?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 278(end)  ************** 

***************   Case 279   ***************

SQL: select c1 from t7 where c1 <>ALL (select c1 from t8 where 1>(select 2)); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |MERGE ANTI JOIN|     |1        |167 |
|1 | TABLE SCAN    |t7   |100      |78  |
|2 | SUBPLAN SCAN  |VIEW1|100      |80  |
|3 |  TABLE SCAN   |t8   |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      equal_conds([t7.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c1]), filter(nil), startup_filter([0]), 
      access([VIEW1.c1])
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 279(end)  ************** 

***************   Case 280   ***************

SQL: select c1 from t4 where c1 in (select c1 from t7 where t4.c1>(select c1 from t8)); 

==================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST |
--------------------------------------------------
|0 |SUBPLAN FILTER |             |50       |15902|
|1 | TABLE SCAN    |t4(idx_t4_c2)|100      |78   |
|2 | SUBPLAN FILTER|             |100      |157  |
|3 |  TABLE SCAN   |t7           |100      |78   |
|4 |  TABLE SCAN   |t8           |100      |78   |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter([t4.c1 = ANY(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), startup_filter([?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 280(end)  ************** 

***************   Case 281   ***************

SQL: select * from t7 where c1 not in (select 1 from t8 where t8.c1 >1); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |99       |132 |
|1 | TABLE SCAN          |t7   |100      |78  |
|2 | MATERIAL            |     |1        |46  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |46  |
|4 |   TABLE SCAN        |t8   |1        |46  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 = ?]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), 
      access(nil)
  4 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 281(end)  ************** 

***************   Case 282   ***************

SQL: select * from t7 where c1 not in (select t7.c1 from t8 where t8.c1 >1); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |153 |
|1 | TABLE SCAN          |t7   |100      |78  |
|2 | MATERIAL            |     |1        |46  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |46  |
|4 |   TABLE SCAN        |t8   |1        |46  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 = t7.c1 OR (T_OP_IS, t7.c1, NULL, 0)]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), 
      access(nil)
  4 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 282(end)  ************** 

***************   Case 283   ***************

SQL: select * from t7 where c1 not in (select (select c1 from t1) from t8 where t8.c1 >1); 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SUBPLAN FILTER           |        |50       |1172|
|1 | TABLE SCAN              |t7      |100      |78  |
|2 | SUBPLAN FILTER          |        |100      |545 |
|3 |  TABLE SCAN             |t8      |100      |78  |
|4 |  PX COORDINATOR         |        |500      |466 |
|5 |   EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|6 |    PX PARTITION ITERATOR|        |500      |387 |
|7 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([t7.c1 != ALL(subquery(1))]), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 283(end)  ************** 

***************   Case 284   ***************

SQL: select * from t7 where c1 in (select t8.c1 from t8 where t8.c1 >1); 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |187 |
|1 | TABLE SCAN|t7  |100      |78  |
|2 | TABLE SCAN|t8  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(1 ; MAX), 
      range_cond([t7.c1 > ?])
  2 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])

*************** Case 284(end)  ************** 

***************   Case 285   ***************

SQL: select * from t7 where c1 in (select 1 from t8 where t8.c1 >t7.c1); 

====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |1        |92  |
|1 | SUBPLAN SCAN             |VIEW1|1        |46  |
|2 |  TABLE SCAN              |t8   |1        |46  |
|3 | MATERIAL                 |     |1        |46  |
|4 |  TABLE GET               |t7   |1        |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])
  3 - output([t7.c1], [t7.c2]), filter(nil)
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[1 ; 1], 
      range_cond([t7.c1 = ?])

*************** Case 285(end)  ************** 

***************   Case 286   ***************

SQL: select * from t7 where c1 in (select 1 from t8 where t8.c1 >1); 

====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |1        |92  |
|1 | SUBPLAN SCAN             |VIEW1|1        |46  |
|2 |  TABLE SCAN              |t8   |1        |46  |
|3 | MATERIAL                 |     |1        |46  |
|4 |  TABLE GET               |t7   |1        |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(1 ; MAX), 
      range_cond([t8.c1 > ?])
  3 - output([t7.c1], [t7.c2]), filter(nil)
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[1 ; 1], 
      range_cond([t7.c1 = ?])

*************** Case 286(end)  ************** 

***************   Case 287   ***************

SQL: select * from t1 where c1 = 1 and c2 in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 287(end)  ************** 

***************   Case 288   ***************

SQL: select * from t1 partition(p1)  where c2 =1 or c2 = 2; 

======================================================
|ID|OPERATOR            |NAME         |EST. ROWS|COST|
------------------------------------------------------
|0 |EXCHANGE IN REMOTE  |             |18       |51  |
|1 | EXCHANGE OUT REMOTE|             |18       |50  |
|2 |  TABLE SCAN        |t1(idx_t1_c2)|18       |46  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MIN ; 1,MAX), (2,MIN ; 2,MAX), 
      range_cond([t1.c2 = ? OR t1.c2 = ?])

*************** Case 288(end)  ************** 

***************   Case 289   ***************

SQL: select * from t14 partition(p1) where (c1, c2) =(1, 2) or (c1, c2) = (2, 3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |2        |47  |
|1 | EXCHANGE OUT REMOTE|    |2        |46  |
|2 |  TABLE SCAN        |t14 |2        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  2 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      access([t14.c1], [t14.c2], [t14.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(1,2,MIN ; 1,2,MAX), (2,3,MIN ; 2,3,MAX), 
      range_cond([(t14.c1, t14.c2) = (?, ?) OR (t14.c1, t14.c2) = (?, ?)])

*************** Case 289(end)  ************** 

***************   Case 290   ***************

SQL: select/*+index(t14 primary)*/* from t14  partition(p1) where (c1, c2) =(1, 2) or (c1, c2) = (2, 3); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |2        |47  |
|1 | EXCHANGE OUT REMOTE|    |2        |46  |
|2 |  TABLE SCAN        |t14 |2        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  1 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  2 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      access([t14.c1], [t14.c2], [t14.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(1,2,MIN ; 1,2,MAX), (2,3,MIN ; 2,3,MAX), 
      range_cond([(t14.c1, t14.c2) = (?, ?) OR (t14.c1, t14.c2) = (?, ?)])

*************** Case 290(end)  ************** 

***************   Case 291   ***************

SQL: select c1 from t1 where (1, 2) in (select t1.c1, t2.c1 from t2); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |141 |
|1 | PX COORDINATOR           |        |1        |46  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t1      |1        |46  |
|4 | PX COORDINATOR           |        |1        |46  |
|5 |  EXCHANGE OUT DISTR      |:EX20000|1        |46  |
|6 |   TABLE GET              |t2      |1        |46  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), is_single, dop=1
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([? = t1.c1])
  4 - output(nil), filter(nil)
  5 - output(nil), filter(nil), is_single, dop=1
  6 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([t2.c1]), range[2 ; 2], 
      range_cond([t2.c1 = ?])

*************** Case 291(end)  ************** 

***************   Case 292   ***************

SQL: select c1 from t1 where (1, 2) in (select t2.c1, t2.c2 from t2 where t1.c1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |23       |98  |
|1 | PX COORDINATOR           |        |1        |46  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t2      |1        |46  |
|4 | PX COORDINATOR           |        |250      |439 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|250      |426 |
|6 |   PX PARTITION ITERATOR  |        |250      |400 |
|7 |    TABLE SCAN            |t1      |250      |400 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil)
  2 - output(nil), filter(nil), is_single, dop=1
  3 - output(nil), filter([t2.c2 = ?]), 
      access([t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter([t1.c1]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 292(end)  ************** 

***************   Case 293   ***************

SQL: select c1 from t1 where (1, 2) in (select t2.c1, t2.c2 from t2 where (t2.c1 + 1)); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |45       |138 |
|1 | PX COORDINATOR           |        |1        |46  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t2      |1        |46  |
|4 | PX COORDINATOR           |        |500      |466 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|500      |439 |
|6 |   PX PARTITION ITERATOR  |        |500      |387 |
|7 |    TABLE SCAN            |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil)
  2 - output(nil), filter(nil), is_single, dop=1
  3 - output(nil), filter([t2.c2 = ?]), 
      access([t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 293(end)  ************** 

***************   Case 294   ***************

SQL: select c1 from t1 where (1, 2) in (select t2.c1, t2.c2 from t2 where (t1.c1 + 1)); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |23       |98  |
|1 | PX COORDINATOR           |        |1        |46  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t2      |1        |46  |
|4 | PX COORDINATOR           |        |250      |439 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|250      |426 |
|6 |   PX PARTITION ITERATOR  |        |250      |400 |
|7 |    TABLE SCAN            |t1      |250      |400 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil)
  2 - output(nil), filter(nil), is_single, dop=1
  3 - output(nil), filter([t2.c2 = ?]), 
      access([t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter([t1.c1 + ?]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 294(end)  ************** 

***************   Case 295   ***************

SQL: select c1 from t1 where (1, 2) in (select t2.c1, t2.c2 from t2 where (t1.c1 + 1) = 2); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |1        |58  |
|1 | PX COORDINATOR           |        |1        |46  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t2      |1        |46  |
|4 | PX COORDINATOR           |        |1        |400 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|1        |400 |
|6 |   PX PARTITION ITERATOR  |        |1        |400 |
|7 |    TABLE SCAN            |t1      |1        |400 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil)
  2 - output(nil), filter(nil), is_single, dop=1
  3 - output(nil), filter([t2.c2 = ?]), 
      access([t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter([t1.c1 + ? = ?]), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 295(end)  ************** 

***************   Case 296   ***************

SQL: select c1 from t1 where (1, 2) in (select distinct t1.c1, t1.c2 from t2 where t1.c1); 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |1        |63  |
|1 | PX COORDINATOR            |        |1        |46  |
|2 |  EXCHANGE OUT DISTR       |:EX10000|1        |46  |
|3 |   TABLE GET               |t1      |1        |46  |
|4 | SUBPLAN SCAN              |VIEW1   |1        |137 |
|5 |  LIMIT                    |        |1        |137 |
|6 |   PX COORDINATOR          |        |1        |137 |
|7 |    EXCHANGE OUT DISTR     |:EX20000|1        |137 |
|8 |     LIMIT                 |        |1        |137 |
|9 |      PX PARTITION ITERATOR|        |1        |137 |
|10|       TABLE SCAN          |t2      |1        |137 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), is_single, dop=1
  3 - output([t1.c1]), filter([? = t1.c2]), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([? = t1.c1])
  4 - output(nil), filter(nil), 
      access(nil)
  5 - output([1]), filter(nil), limit(1), offset(nil)
  6 - output(nil), filter(nil)
  7 - output(nil), filter(nil), dop=1
  8 - output(nil), filter(nil), limit(1), offset(nil)
  9 - output(nil), filter(nil), 
      force partition granule.
  10 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 296(end)  ************** 

***************   Case 297   ***************

SQL: select c2 from t1 where exists (select * from t2 where t1.c1 and t1.c2 limit 1); 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |        |125      |580 |
|1 | SUBPLAN SCAN              |VIEW1   |1        |137 |
|2 |  LIMIT                    |        |1        |137 |
|3 |   PX COORDINATOR          |        |1        |137 |
|4 |    EXCHANGE OUT DISTR     |:EX10000|1        |137 |
|5 |     LIMIT                 |        |1        |137 |
|6 |      PX PARTITION ITERATOR|        |1        |137 |
|7 |       TABLE SCAN          |t2      |1        |137 |
|8 | MATERIAL                  |        |125      |437 |
|9 |  PX COORDINATOR           |        |125      |436 |
|10|   EXCHANGE OUT DISTR      |:EX20000|125      |425 |
|11|    PX PARTITION ITERATOR  |        |125      |401 |
|12|     TABLE SCAN            |t1      |125      |401 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), dop=1
  5 - output(nil), filter(nil), limit(1), offset(nil)
  6 - output(nil), filter(nil), 
      force partition granule.
  7 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  8 - output([t1.c2]), filter(nil)
  9 - output([t1.c2]), filter(nil)
  10 - output([t1.c2]), filter(nil), dop=1
  11 - output([t1.c2]), filter(nil), 
      force partition granule.
  12 - output([t1.c2]), filter([t1.c1], [t1.c2]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 297(end)  ************** 

***************   Case 298   ***************

SQL: select * from t4 where c1 in (select t7.c1 from t7 left join t8 on t7.c1<=t8.c1 where (t7.c1,t4.c1) in (select c1,c2 from t9)); 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN |    |1        |92  |
|1 | NESTED-LOOP JOIN|    |1        |85  |
|2 |  TABLE SCAN     |t9  |1        |80  |
|3 |  TABLE GET      |t7  |1        |5   |
|4 | TABLE SCAN      |t4  |9        |5   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  1 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_([t9.c2]), batch_join=true
  2 - output([t9.c2]), filter([t9.c2 = t9.c1]), 
      access([t9.c1], [t9.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t9.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([? = t7.c1])
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN ; MAX), 
      range_cond([t4.c1 = ?])

*************** Case 298(end)  ************** 

***************   Case 299   ***************

SQL: select * from t7 where 1 in (select c1 from t8 where t7.c1); 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |50       |138 |
|1 | TABLE GET                |t8  |1        |46  |
|2 | TABLE SCAN               |t7  |50       |80  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[1 ; 1], 
      range_cond([t8.c1 = ?])
  2 - output([t7.c1], [t7.c2]), filter([t7.c1]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 299(end)  ************** 

***************   Case 300   ***************

SQL: select * from t7 where 1 not in (select 2 from t8 where t7.c1=t8.c1); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |MERGE ANTI JOIN|     |1        |167 |
|1 | TABLE SCAN    |t7   |100      |78  |
|2 | SUBPLAN SCAN  |VIEW1|100      |80  |
|3 |  TABLE SCAN   |t8   |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c1 = VIEW1.t8.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.t8.c1]), filter(nil), startup_filter([0]), 
      access([VIEW1.t8.c1])
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 300(end)  ************** 

***************   Case 301   ***************

SQL: select * from t4 where (select c1 from t7)+1 in (select 2 from t8 where t4.c1=t8.c1); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |91       |259 |
|1 | MERGE JOIN   |    |91       |180 |
|2 |  TABLE SCAN  |t4  |100      |78  |
|3 |  TABLE SCAN  |t8  |100      |78  |
|4 | TABLE SCAN   |t7  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1) + ? = ?]), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([?]), 
      equal_conds([t4.c1 = t8.c1]), other_conds(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 301(end)  ************** 

***************   Case 302   ***************

SQL: select * from t4 where (select 2)+(select c1 from t7)+1 in (select 2 from t8 where t4.c1=t8.c1); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |91       |259 |
|1 | MERGE JOIN   |    |91       |180 |
|2 |  TABLE SCAN  |t4  |100      |78  |
|3 |  TABLE SCAN  |t8  |100      |78  |
|4 | TABLE SCAN   |t7  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? + subquery(1) + ? = ?]), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), startup_filter([?]), 
      equal_conds([t4.c1 = t8.c1]), other_conds(nil)
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 302(end)  ************** 

***************   Case 303   ***************

SQL: select sum(c1)+sum(c2), sum(c1) from t1 group by c2 having sum(c1) > 5; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |95       |580 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |95       |553 |
|2 |  MERGE GROUP BY               |             |95       |496 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |486 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |467 |
|5 |     PX PARTITION ITERATOR     |             |100      |427 |
|6 |      MERGE GROUP BY           |             |100      |427 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |387 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)) + T_FUN_SUM(T_FUN_SUM(t1.c2)), T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)) + T_FUN_SUM(T_FUN_SUM(t1.c2)), T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c2))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c2))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_SUM(t1.c2)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 303(end)  ************** 

***************   Case 304   ***************

SQL: select sum(c1), c2, count(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |5        |489 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |5        |488 |
|2 |  MERGE GROUP BY               |             |5        |485 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |476 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |458 |
|5 |     PX PARTITION ITERATOR     |             |100      |420 |
|6 |      MERGE GROUP BY           |             |100      |420 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|428      |386 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 304(end)  ************** 

***************   Case 305   ***************

SQL: select distinct sum(c1) from t1 group by c2 having sum(c1) > 5; 

======================================================================
|ID|OPERATOR                            |NAME         |EST. ROWS|COST|
----------------------------------------------------------------------
|0 |PX COORDINATOR                      |             |95       |635 |
|1 | EXCHANGE OUT DISTR                 |:EX10002     |95       |617 |
|2 |  MERGE DISTINCT                    |             |95       |580 |
|3 |   EXCHANGE IN MERGE SORT DISTR     |             |95       |574 |
|4 |    EXCHANGE OUT DISTR (HASH)       |:EX10001     |95       |557 |
|5 |     MERGE DISTINCT                 |             |95       |519 |
|6 |      SORT                          |             |95       |513 |
|7 |       MERGE GROUP BY               |             |95       |469 |
|8 |        EXCHANGE IN MERGE SORT DISTR|             |100      |462 |
|9 |         EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |448 |
|10|          PX PARTITION ITERATOR     |             |100      |418 |
|11|           MERGE GROUP BY           |             |100      |418 |
|12|            TABLE SCAN              |t1(idx_t1_c2)|500      |387 |
======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      distinct([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), sort_keys([T_FUN_SUM(T_FUN_SUM(t1.c1)), ASC])
  4 - (#keys=1, [T_FUN_SUM(T_FUN_SUM(t1.c1))]), output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), dop=1
  5 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      distinct([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  6 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), sort_keys([T_FUN_SUM(T_FUN_SUM(t1.c1)), ASC])
  7 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter([T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))])
  8 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  9 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), dop=1
  10 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule.
  11 - output([T_FUN_SUM(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)])
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 305(end)  ************** 

***************   Case 306   ***************

SQL: select distinct sum(c1), c2, count(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |5        |489 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |5        |488 |
|2 |  MERGE GROUP BY               |             |5        |485 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |476 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |458 |
|5 |     PX PARTITION ITERATOR     |             |100      |420 |
|6 |      MERGE GROUP BY           |             |100      |420 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|428      |386 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 306(end)  ************** 

***************   Case 307   ***************

SQL: select distinct sum(c1), c2, count(c1), avg(c1) from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |5        |489 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |5        |488 |
|2 |  MERGE GROUP BY               |             |5        |485 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |476 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |458 |
|5 |     PX PARTITION ITERATOR     |             |100      |420 |
|6 |      MERGE GROUP BY           |             |100      |420 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|428      |386 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 307(end)  ************** 

***************   Case 308   ***************

SQL: select distinct sum(c1)+1, sum(c1) + 2 from t1 group by c2 having sum(c1) > 5 and count(c1) + 2 > 2; 

======================================================================
|ID|OPERATOR                            |NAME         |EST. ROWS|COST|
----------------------------------------------------------------------
|0 |PX COORDINATOR                      |             |5        |502 |
|1 | EXCHANGE OUT DISTR                 |:EX10002     |5        |500 |
|2 |  MERGE DISTINCT                    |             |5        |498 |
|3 |   EXCHANGE IN MERGE SORT DISTR     |             |5        |498 |
|4 |    EXCHANGE OUT DISTR (HASH)       |:EX10001     |5        |496 |
|5 |     MERGE DISTINCT                 |             |5        |494 |
|6 |      SORT                          |             |5        |493 |
|7 |       MERGE GROUP BY               |             |5        |492 |
|8 |        EXCHANGE IN MERGE SORT DISTR|             |100      |483 |
|9 |         EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |465 |
|10|          PX PARTITION ITERATOR     |             |100      |427 |
|11|           MERGE GROUP BY           |             |100      |427 |
|12|            TABLE SCAN              |t1(idx_t1_c2)|500      |387 |
======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?, T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?, T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?)]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil), 
      distinct([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?])
  3 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil), sort_keys([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?, ASC], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?, ASC])
  4 - (#keys=2, [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil), dop=1
  5 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil), 
      distinct([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?])
  6 - output([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?]), filter(nil), sort_keys([T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?, ASC], [T_FUN_SUM(T_FUN_SUM(t1.c1)) + ?, ASC])
  7 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) + ? > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  8 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  9 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  10 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  11 - output([T_FUN_SUM(t1.c1)], [t1.c2], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 308(end)  ************** 

***************   Case 309   ***************

SQL: select * from t1, t2 where t1.c1 > any(select t3.c2 from t2,t3 where t2.c1 > any(select t4.c1 from t4,t5 where exists (select c1 from t2 ))); 

======================================================================
|ID|OPERATOR                          |NAME         |EST. ROWS|COST  |
----------------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN        |             |50000    |961484|
|1 | NESTED-LOOP SEMI JOIN            |             |167      |956719|
|2 |  PX COORDINATOR                  |             |500      |528   |
|3 |   EXCHANGE OUT DISTR             |:EX10000     |500      |481   |
|4 |    PX PARTITION ITERATOR         |             |500      |387   |
|5 |     TABLE SCAN                   |t1           |500      |387   |
|6 |  MATERIAL                        |             |20000    |157065|
|7 |   SUBPLAN SCAN                   |VIEW2        |20000    |156994|
|8 |    NESTED-LOOP JOIN CARTESIAN    |             |20000    |156643|
|9 |     NESTED-LOOP SEMI JOIN        |             |100      |153876|
|10|      PX COORDINATOR              |             |300      |280   |
|11|       EXCHANGE OUT DISTR         |:EX20000     |300      |263   |
|12|        PX PARTITION ITERATOR     |             |300      |233   |
|13|         TABLE SCAN               |t2           |300      |233   |
|14|      SUBPLAN SCAN                |VIEW1        |1        |463   |
|15|       SUBPLAN FILTER             |             |1        |463   |
|16|        NESTED-LOOP JOIN CARTESIAN|             |1        |326   |
|17|         TABLE SCAN               |t4           |1        |46    |
|18|         MATERIAL                 |             |300      |281   |
|19|          PX COORDINATOR          |             |300      |280   |
|20|           EXCHANGE OUT DISTR     |:EX30000     |300      |263   |
|21|            PX PARTITION ITERATOR |             |300      |233   |
|22|             TABLE SCAN           |t5(idx_t5_c2)|300      |233   |
|23|        LIMIT                     |             |1        |137   |
|24|         PX COORDINATOR           |             |1        |137   |
|25|          EXCHANGE OUT DISTR      |:EX40000     |1        |137   |
|26|           LIMIT                  |             |1        |137   |
|27|            PX PARTITION ITERATOR |             |1        |137   |
|28|             TABLE SCAN           |t2           |1        |137   |
|29|     MATERIAL                     |             |200      |188   |
|30|      PX COORDINATOR              |             |200      |187   |
|31|       EXCHANGE OUT DISTR         |:EX50000     |200      |176   |
|32|        PX PARTITION ITERATOR     |             |200      |155   |
|33|         TABLE SCAN               |t3           |200      |155   |
|34| MATERIAL                         |             |300      |471   |
|35|  PX COORDINATOR                  |             |300      |464   |
|36|   EXCHANGE OUT DISTR             |:EX60000     |300      |391   |
|37|    PX PARTITION ITERATOR         |             |300      |233   |
|38|     TABLE SCAN                   |t2           |300      |233   |
======================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > VIEW2.c2]), nl_params_(nil), batch_join=false
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([VIEW2.c2]), filter(nil)
  7 - output([VIEW2.c2]), filter(nil), 
      access([VIEW2.c2])
  8 - output([t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  9 - output(nil), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  10 - output([t2.c1]), filter(nil)
  11 - output([t2.c1]), filter(nil), dop=1
  12 - output([t2.c1]), filter(nil), 
      force partition granule.
  13 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  14 - output(nil), filter(nil), 
      access(nil)
  15 - output([t4.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  16 - output([t4.c1]), filter(nil), startup_filter([?]), 
      conds(nil), nl_params_(nil), batch_join=false
  17 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true, 
      range_cond([? > t4.c1])
  18 - output(nil), filter(nil)
  19 - output(nil), filter(nil)
  20 - output(nil), filter(nil), dop=1
  21 - output(nil), filter(nil), 
      force partition granule.
  22 - output(nil), filter(nil), 
      access([t5.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  23 - output([1]), filter(nil), limit(1), offset(nil)
  24 - output(nil), filter(nil)
  25 - output(nil), filter(nil), dop=1
  26 - output(nil), filter(nil), limit(1), offset(nil)
  27 - output(nil), filter(nil), 
      force partition granule.
  28 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  29 - output([t3.c2]), filter(nil)
  30 - output([t3.c2]), filter(nil)
  31 - output([t3.c2]), filter(nil), dop=1
  32 - output([t3.c2]), filter(nil), 
      force partition granule.
  33 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  34 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  35 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  36 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  37 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  38 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 309(end)  ************** 

***************   Case 310   ***************

SQL: select * from t4,t4 t5 where t4.c1+t5.c1 in (select t7.c1 from t7,t8); 

=======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST |
-------------------------------------------------------
|0 |HASH RIGHT SEMI JOIN        |     |100      |10595|
|1 | SUBPLAN SCAN               |VIEW1|10000    |2911 |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |10000    |2736 |
|3 |   TABLE SCAN               |t7   |100      |78   |
|4 |   MATERIAL                 |     |100      |78   |
|5 |    TABLE SCAN              |t8   |100      |78   |
|6 | NESTED-LOOP JOIN CARTESIAN |     |10000    |2736 |
|7 |  TABLE SCAN                |t4   |100      |78   |
|8 |  MATERIAL                  |     |100      |79   |
|9 |   TABLE SCAN               |t5   |100      |78   |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t4.c1 + t5.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output(nil), filter(nil)
  5 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  7 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  8 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  9 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c1], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 310(end)  ************** 

***************   Case 311   ***************

SQL: select * from t4,t4 t5 where t4.c1 in (select t7.c1 from t7,t8); 

========================================================
|ID|OPERATOR                      |NAME |EST. ROWS|COST|
--------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN    |     |9000     |5677|
|1 | TABLE SCAN                   |t5   |100      |78  |
|2 | MATERIAL                     |     |90       |3277|
|3 |  MERGE SEMI JOIN             |     |90       |3276|
|4 |   TABLE SCAN                 |t4   |100      |78  |
|5 |   SUBPLAN SCAN               |VIEW1|10000    |2911|
|6 |    NESTED-LOOP JOIN CARTESIAN|     |10000    |2736|
|7 |     TABLE SCAN               |t7   |100      |78  |
|8 |     MATERIAL                 |     |100      |78  |
|9 |      TABLE SCAN              |t8   |100      |78  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c1], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil)
  3 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      equal_conds([t4.c1 = VIEW1.c1]), other_conds(nil)
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  6 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  7 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  8 - output(nil), filter(nil)
  9 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 311(end)  ************** 

***************   Case 312   ***************

SQL: select * from t4,t4 t5 where t4.c1+t5.c1 in (select t7.c1 from t7,t8 where t7.c1=t8.c1); 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH JOIN                   |    |10000    |7780|
|1 | TABLE SCAN                 |t8  |100      |78  |
|2 | HASH JOIN                  |    |10000    |5289|
|3 |  TABLE SCAN                |t7  |100      |78  |
|4 |  NESTED-LOOP JOIN CARTESIAN|    |10000    |2736|
|5 |   TABLE SCAN               |t4  |100      |78  |
|6 |   MATERIAL                 |    |100      |79  |
|7 |    TABLE SCAN              |t5  |100      |78  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t7.c1 = t8.c1]), other_conds(nil)
  1 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t7.c1]), filter(nil), 
      equal_conds([t4.c1 + t5.c1 = t7.c1]), other_conds(nil)
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  5 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  6 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  7 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t5.c1], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 312(end)  ************** 

***************   Case 313   ***************

SQL: select count(*) v from t1 where c2 = 1; 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SCALAR GROUP BY          |             |1        |228 |
|1 | PX COORDINATOR          |             |1        |228 |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |1        |228 |
|3 |   MERGE GROUP BY        |             |1        |228 |
|4 |    PX PARTITION ITERATOR|             |5        |227 |
|5 |     TABLE SCAN          |t1(idx_t1_c2)|5        |227 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MIN ; 1,MAX), 
      range_cond([t1.c2 = ?])

*************** Case 313(end)  ************** 

***************   Case 314   ***************

SQL: select count(*) v, sum(c1) as v2 from t1 where c1 > 0; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |414 |
|1 | PX COORDINATOR          |        |1        |414 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |414 |
|3 |   MERGE GROUP BY        |        |1        |414 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [T_FUN_SUM(T_FUN_SUM(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [T_FUN_SUM(T_FUN_SUM(t1.c1))])
  1 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)], [T_FUN_SUM(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 314(end)  ************** 

***************   Case 315   ***************

SQL: select distinct sum(c1), c2, count(c1), avg(c1) as alias from t1 group by c2 having sum(c1) > 5 and count(c1) > 0 and c2 > 1 and alias > 100; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |1        |486 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |1        |486 |
|2 |  MERGE GROUP BY               |             |1        |485 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |476 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |458 |
|5 |     PX PARTITION ITERATOR     |             |100      |420 |
|6 |      MERGE GROUP BY           |             |100      |420 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|428      |386 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)), t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil), dop=1
  2 - output([t1.c2], [T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0))]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)) > ?], [T_FUN_SUM(T_FUN_SUM(t1.c1)) > ?]), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(1,MAX ; MAX,MAX), 
      range_cond([t1.c2 > ?])

*************** Case 315(end)  ************** 

***************   Case 316   ***************

SQL: select 1 from t15; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |400      |373 |
|1 | EXCHANGE OUT DISTR    |:EX10000|400      |351 |
|2 |  PX PARTITION ITERATOR|        |400      |310 |
|3 |   TABLE SCAN          |t15     |400      |310 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(?)]), filter(nil), dop=1
  2 - output(nil), filter(nil), 
      force partition granule.
  3 - output(nil), filter(nil), 
      access([t15.__pk_increment]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 316(end)  ************** 

***************   Case 317   ***************

SQL: select c1 from t15 where false; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |400      |373 |
|1 | EXCHANGE OUT DISTR    |:EX10000|400      |351 |
|2 |  PX PARTITION ITERATOR|        |400      |310 |
|3 |   TABLE SCAN          |t15     |400      |310 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t15.c1)]), filter(nil), startup_filter([0])
  1 - output([INTERNAL_FUNCTION(t15.c1)]), filter(nil), dop=1
  2 - output([t15.c1]), filter(nil), 
      force partition granule.
  3 - output([t15.c1]), filter(nil), 
      access([t15.c1]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 317(end)  ************** 

***************   Case 318   ***************

SQL: select count(1) from t15 where false; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |324 |
|1 | PX COORDINATOR          |        |1        |324 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |324 |
|3 |   MERGE GROUP BY        |        |1        |324 |
|4 |    PX PARTITION ITERATOR|        |400      |310 |
|5 |     TABLE SCAN          |t15     |400      |310 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)]), filter(nil), startup_filter([0])
  2 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t15.__pk_increment]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 318(end)  ************** 

***************   Case 319   ***************

SQL: select * from t1 order by c2,c1,c2; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |             |500      |637 |
|1 | EXCHANGE OUT DISTR       |:EX10000     |500      |591 |
|2 |  SORT                    |             |500      |497 |
|3 |   PX PARTITION ITERATOR  |             |500      |387 |
|4 |    TABLE SCAN            |t1(idx_t1_c2)|500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), sort_keys([t1.c2, ASC], [t1.c1, ASC])
  1 - output([t1.c2], [t1.c1], [INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c2, ASC], [t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 319(end)  ************** 

***************   Case 320   ***************

SQL: select * from t1 left outer join t2 using(c1) order by t1.c1 desc, t2.c1; 

==============================================================
|ID|OPERATOR                      |NAME       |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |           |500      |1845|
|1 | EXCHANGE OUT DISTR           |:EX10001   |500      |1685|
|2 |  SORT                        |           |500      |1335|
|3 |   HASH OUTER JOIN            |           |500      |954 |
|4 |    EXCHANGE IN DISTR         |           |500      |528 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000   |500      |481 |
|6 |      PX PARTITION ITERATOR   |           |500      |387 |
|7 |       TABLE SCAN             |t1(Reverse)|500      |387 |
|8 |    PX PARTITION ITERATOR     |           |300      |233 |
|9 |     TABLE SCAN               |t2(Reverse)|300      |233 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c2, t2.c3)]), filter(nil), sort_keys([t1.c1, DESC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), sort_keys([t1.c1, DESC])
  3 - output([t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil)
  5 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 320(end)  ************** 

***************   Case 321   ***************

SQL: select count(*) from t1 left outer join t2 using(c1) group by (t1.c1) having count(*) > 1 order by t1.c1 desc, t2.c1; 

==============================================================
|ID|OPERATOR                      |NAME       |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |           |500      |1370|
|1 | EXCHANGE OUT DISTR           |:EX10001   |500      |1323|
|2 |  SORT                        |           |500      |1229|
|3 |   HASH RIGHT OUTER JOIN      |           |500      |859 |
|4 |    EXCHANGE IN DISTR         |           |300      |280 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000   |300      |263 |
|6 |      PX PARTITION ITERATOR   |           |300      |233 |
|7 |       TABLE SCAN             |t2(Reverse)|300      |233 |
|8 |    PX PARTITION ITERATOR     |           |500      |387 |
|9 |     TABLE SCAN               |t1(Reverse)|500      |387 |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(1)]), filter(nil), startup_filter([0]), sort_keys([t1.c1, DESC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c1, DESC])
  3 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t2.c1]), filter(nil)
  5 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  6 - output([t2.c1]), filter(nil), 
      force partition granule.
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  8 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 321(end)  ************** 

***************   Case 322   ***************

SQL: select now() from t1 left outer join t2 using(c1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(?)]), filter(nil), dop=1
  2 - output(nil), filter(nil), 
      force partition granule.
  3 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 322(end)  ************** 

***************   Case 323   ***************

SQL: select a1.c2 from t1 left join t2 a1 on (a1.c1= t1.c1) where least(t1.c2, a1.c2) > 1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |949 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |933 |
|2 |  HASH JOIN                  |        |100      |897 |
|3 |   EXCHANGE IN DISTR         |        |300      |317 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |289 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |a1      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |500      |387 |
|8 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(a1.c2)]), filter(nil), dop=1
  2 - output([a1.c2]), filter(nil), 
      equal_conds([a1.c1 = t1.c1]), other_conds([least(t1.c2, a1.c2) > ?])
  3 - output([a1.c2], [a1.c1]), filter(nil)
  4 - (#keys=1, [a1.c1]), output([a1.c2], [a1.c1]), filter(nil), dop=1
  5 - output([a1.c1], [a1.c2]), filter(nil), 
      force partition granule.
  6 - output([a1.c1], [a1.c2]), filter(nil), 
      access([a1.c1], [a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 323(end)  ************** 

***************   Case 324   ***************

SQL: select a1.c2 from t1 left join t2 a1 on (a1.c1= t1.c1) where length(t1.c2) > 1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |167      |879 |
|1 | EXCHANGE OUT DISTR          |:EX10001|167      |851 |
|2 |  HASH OUTER JOIN            |        |167      |791 |
|3 |   EXCHANGE IN DISTR         |        |167      |447 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|167      |431 |
|5 |     PX PARTITION ITERATOR   |        |167      |400 |
|6 |      TABLE SCAN             |t1      |167      |400 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |a1      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(a1.c2)]), filter(nil), dop=1
  2 - output([a1.c2]), filter(nil), 
      equal_conds([a1.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule.
  6 - output([t1.c1]), filter([length(cast(t1.c2, VARCHAR(1048576))) > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([a1.c1], [a1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([a1.c1], [a1.c2]), filter(nil), 
      access([a1.c1], [a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX)always true

*************** Case 324(end)  ************** 

***************   Case 325   ***************

SQL: select a2.c2, t1.c2, a1.c2 from t1  left join t2 a1 on (a1.c1 = t1.c1), t2 a2 where least(t1.c2, a1.c2) =a2.c2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |HASH JOIN                     |        |811      |1482|
|1 | PX COORDINATOR               |        |300      |280 |
|2 |  EXCHANGE OUT DISTR          |:EX10000|300      |263 |
|3 |   PX PARTITION ITERATOR      |        |300      |233 |
|4 |    TABLE SCAN                |a2      |300      |233 |
|5 | PX COORDINATOR               |        |300      |1055|
|6 |  EXCHANGE OUT DISTR          |:EX20001|300      |1004|
|7 |   HASH JOIN                  |        |300      |897 |
|8 |    EXCHANGE IN DISTR         |        |300      |317 |
|9 |     EXCHANGE OUT DISTR (PKEY)|:EX20000|300      |289 |
|10|      PX PARTITION ITERATOR   |        |300      |233 |
|11|       TABLE SCAN             |a1      |300      |233 |
|12|    PX PARTITION ITERATOR     |        |500      |387 |
|13|     TABLE SCAN               |t1      |500      |387 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([a2.c2], [t1.c2], [a1.c2]), filter(nil), 
      equal_conds([least(t1.c2, a1.c2) = a2.c2]), other_conds(nil)
  1 - output([a2.c2]), filter(nil)
  2 - output([a2.c2]), filter(nil), dop=1
  3 - output([a2.c2]), filter(nil), 
      force partition granule.
  4 - output([a2.c2]), filter(nil), 
      access([a2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c2], [a1.c2]), filter(nil)
  6 - output([t1.c2], [a1.c2]), filter(nil), dop=1
  7 - output([t1.c2], [a1.c2]), filter(nil), 
      equal_conds([a1.c1 = t1.c1]), other_conds(nil)
  8 - output([a1.c2], [a1.c1]), filter(nil)
  9 - (#keys=1, [a1.c1]), output([a1.c2], [a1.c1]), filter(nil), dop=1
  10 - output([a1.c1], [a1.c2]), filter(nil), 
      force partition granule.
  11 - output([a1.c1], [a1.c2]), filter(nil), 
      access([a1.c1], [a1.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([a1.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 325(end)  ************** 

***************   Case 326   ***************

SQL: select f_acc.c2, a1.c2, a2.c2 from t2 left join t2 f1 on (f1.c1 = 1 and t2.c3 = f1.c3) left join t3 a1 on (a1.c1 = f1.c1) left join t2 f2 on (f2.c1 = 3 and f2.c3=t2.c3) left join t3 a2 on (a2.c1 = f2.c1), t3 f_acc where least(a1.c2, a2.c2) = f_acc.c2; 

=========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST|
---------------------------------------------------------
|0 |HASH JOIN                   |        |1        |712 |
|1 | NESTED-LOOP JOIN CARTESIAN |        |1        |476 |
|2 |  NESTED-LOOP JOIN CARTESIAN|        |1        |431 |
|3 |   MERGE JOIN               |        |1        |385 |
|4 |    NESTED-LOOP JOIN        |        |3        |339 |
|5 |     PX COORDINATOR         |        |1        |47  |
|6 |      EXCHANGE OUT DISTR    |:EX10000|1        |46  |
|7 |       TABLE GET            |f1      |1        |46  |
|8 |     PX COORDINATOR         |        |300      |391 |
|9 |      EXCHANGE OUT DISTR    |:EX20000|300      |340 |
|10|       PX PARTITION ITERATOR|        |300      |233 |
|11|        TABLE SCAN          |t2      |300      |233 |
|12|    TABLE GET               |f2      |1        |46  |
|13|   MATERIAL                 |        |1        |46  |
|14|    PX COORDINATOR          |        |1        |46  |
|15|     EXCHANGE OUT DISTR     |:EX30000|1        |46  |
|16|      TABLE GET             |a1      |1        |46  |
|17|  MATERIAL                  |        |1        |46  |
|18|   PX COORDINATOR           |        |1        |46  |
|19|    EXCHANGE OUT DISTR      |:EX40000|1        |46  |
|20|     TABLE GET              |a2      |1        |46  |
|21| PX COORDINATOR             |        |200      |187 |
|22|  EXCHANGE OUT DISTR        |:EX50000|200      |176 |
|23|   PX PARTITION ITERATOR    |        |200      |155 |
|24|    TABLE SCAN              |f_acc   |200      |155 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([f_acc.c2], [a1.c2], [a2.c2]), filter(nil), 
      equal_conds([least(a1.c2, a2.c2) = f_acc.c2]), other_conds(nil)
  1 - output([a1.c2], [a2.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([a1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output(nil), filter(nil), 
      equal_conds([f2.c3 = t2.c3]), other_conds(nil)
  4 - output([t2.c3]), filter(nil), 
      conds([t2.c3 = f1.c3]), nl_params_(nil), batch_join=false
  5 - output([f1.c3]), filter(nil)
  6 - output([f1.c3]), filter(nil), is_single, dop=1
  7 - output([f1.c3]), filter(nil), 
      access([f1.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([f1.c1]), range[1 ; 1], 
      range_cond([f1.c1 = ?])
  8 - output([t2.c3]), filter(nil)
  9 - output([t2.c3]), filter(nil), dop=1
  10 - output([t2.c3]), filter(nil), 
      force partition granule.
  11 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([f2.c3]), filter(nil), 
      access([f2.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([f2.c1]), range[3 ; 3], 
      range_cond([f2.c1 = ?])
  13 - output([a1.c2]), filter(nil)
  14 - output([a1.c2]), filter(nil)
  15 - output([a1.c2]), filter(nil), is_single, dop=1
  16 - output([a1.c2]), filter(nil), 
      access([a1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a1.c1]), range[1 ; 1], 
      range_cond([a1.c1 = ?])
  17 - output([a2.c2]), filter(nil)
  18 - output([a2.c2]), filter(nil)
  19 - output([a2.c2]), filter(nil), is_single, dop=1
  20 - output([a2.c2]), filter(nil), 
      access([a2.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a2.c1]), range[3 ; 3], 
      range_cond([a2.c1 = ?])
  21 - output([f_acc.c2]), filter(nil)
  22 - output([f_acc.c2]), filter(nil), dop=1
  23 - output([f_acc.c2]), filter(nil), 
      force partition granule.
  24 - output([f_acc.c2]), filter(nil), 
      access([f_acc.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([f_acc.c1]), range(MIN ; MAX)always true

*************** Case 326(end)  ************** 

***************   Case 327   ***************

SQL: select f_acc.c2, a1.c2, a2.c2 from t2 left join t2 f1 on (f1.c1 =1 and f1.c3 = t2.c3) left join t3 a1 on (a1.c1 = f1.c1) left join t3 a2 on (a2.c1 = f1.c1) , t3 f_acc where least(a1.c2, a2.c2) = f_acc.c2; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |HASH JOIN                  |        |5        |622 |
|1 | NESTED-LOOP JOIN CARTESIAN|        |3        |386 |
|2 |  NESTED-LOOP JOIN         |        |3        |339 |
|3 |   PX COORDINATOR          |        |1        |47  |
|4 |    EXCHANGE OUT DISTR     |:EX10000|1        |46  |
|5 |     TABLE GET             |f1      |1        |46  |
|6 |   PX COORDINATOR          |        |300      |391 |
|7 |    EXCHANGE OUT DISTR     |:EX20000|300      |340 |
|8 |     PX PARTITION ITERATOR |        |300      |233 |
|9 |      TABLE SCAN           |t2      |300      |233 |
|10|  MATERIAL                 |        |1        |46  |
|11|   PX COORDINATOR          |        |1        |46  |
|12|    EXCHANGE OUT DISTR     |:EX30000|1        |46  |
|13|     TABLE GET             |a1      |1        |46  |
|14| PX COORDINATOR            |        |200      |187 |
|15|  EXCHANGE OUT DISTR       |:EX40000|200      |176 |
|16|   PX PARTITION ITERATOR   |        |200      |155 |
|17|    TABLE SCAN             |f_acc   |200      |155 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([f_acc.c2], [a1.c2], [a1.c2]), filter(nil), 
      equal_conds([least(a1.c2, a1.c2) = f_acc.c2]), other_conds(nil)
  1 - output([a1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output(nil), filter(nil), 
      conds([f1.c3 = t2.c3]), nl_params_(nil), batch_join=false
  3 - output([f1.c3]), filter(nil)
  4 - output([f1.c3]), filter(nil), is_single, dop=1
  5 - output([f1.c3]), filter(nil), 
      access([f1.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([f1.c1]), range[1 ; 1], 
      range_cond([f1.c1 = ?])
  6 - output([t2.c3]), filter(nil)
  7 - output([t2.c3]), filter(nil), dop=1
  8 - output([t2.c3]), filter(nil), 
      force partition granule.
  9 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  10 - output([a1.c2]), filter(nil)
  11 - output([a1.c2]), filter(nil)
  12 - output([a1.c2]), filter(nil), is_single, dop=1
  13 - output([a1.c2]), filter(nil), 
      access([a1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([a1.c1]), range[1 ; 1], 
      range_cond([a1.c1 = ?])
  14 - output([f_acc.c2]), filter(nil)
  15 - output([f_acc.c2]), filter(nil), dop=1
  16 - output([f_acc.c2]), filter(nil), 
      force partition granule.
  17 - output([f_acc.c2]), filter(nil), 
      access([f_acc.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([f_acc.c1]), range(MIN ; MAX)always true

*************** Case 327(end)  ************** 

***************   Case 328   ***************

SQL: select * from t9,t10,t11 where t9.c2=t10.c2 and t9.c3=t10.c3 and t9.c2=t11.c2 and t9.c3=t11.c3 order by t11.c3,t11.c2; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |        |44       |644 |
|1 | EXCHANGE OUT DISTR            |:EX10001|44       |629 |
|2 |  SORT                         |        |44       |595 |
|3 |   HASH JOIN                   |        |44       |574 |
|4 |    HASH JOIN                  |        |66       |350 |
|5 |     EXCHANGE IN DISTR         |        |100      |118 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |105 |
|7 |       TABLE SCAN              |t9      |100      |78  |
|8 |     PX PARTITION ITERATOR     |        |200      |155 |
|9 |      TABLE SCAN               |t10     |200      |155 |
|10|    PX PARTITION ITERATOR      |        |200      |155 |
|11|     TABLE SCAN                |t11     |200      |155 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t9.c1, t9.c2, t9.c3, t10.c1, t10.c2, t10.c3, t11.c1, t11.c2, t11.c3)]), filter(nil), sort_keys([t11.c3, ASC], [t11.c2, ASC])
  1 - output([t11.c3], [t11.c2], [INTERNAL_FUNCTION(t9.c1, t9.c2, t9.c3, t10.c1, t10.c2, t10.c3, t11.c1, t11.c2, t11.c3)]), filter(nil), dop=1
  2 - output([t11.c3], [t11.c2], [t9.c2], [t9.c3], [t10.c2], [t10.c3], [t9.c1], [t10.c1], [t11.c1]), filter(nil), sort_keys([t11.c3, ASC], [t11.c2, ASC])
  3 - output([t11.c3], [t11.c2], [t9.c2], [t9.c3], [t10.c2], [t10.c3], [t9.c1], [t10.c1], [t11.c1]), filter(nil), 
      equal_conds([t9.c2 = t11.c2], [t9.c3 = t11.c3]), other_conds(nil)
  4 - output([t9.c2], [t9.c3], [t10.c2], [t10.c3], [t9.c1], [t10.c1]), filter(nil), 
      equal_conds([t9.c2 = t10.c2], [t9.c3 = t10.c3]), other_conds(nil)
  5 - output([t9.c2], [t9.c3], [t9.c1]), filter(nil)
  6 - (#keys=1, [t9.c2]), output([t9.c2], [t9.c3], [t9.c1]), filter(nil), is_single, dop=1
  7 - output([t9.c1], [t9.c2], [t9.c3]), filter(nil), 
      access([t9.c1], [t9.c2], [t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  8 - output([t10.c1], [t10.c2], [t10.c3]), filter(nil), 
      affinitize, partition wise, force partition granule.
  9 - output([t10.c1], [t10.c2], [t10.c3]), filter(nil), 
      access([t10.c1], [t10.c2], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true
  10 - output([t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      affinitize, partition wise, force partition granule.
  11 - output([t11.c1], [t11.c2], [t11.c3]), filter(nil), 
      access([t11.c1], [t11.c2], [t11.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t11.c1], [t11.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 328(end)  ************** 

***************   Case 329   ***************

SQL: select t9.c2, t9.c3, t9.c2, t10.c3 from t9, t10 where t9.c2 = t10.c2 and t9.c3 = t10.c3 order by t9.c2, t9.c3 desc; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |66       |407 |
|1 | EXCHANGE OUT DISTR           |:EX10001|66       |396 |
|2 |  SORT                        |        |66       |372 |
|3 |   HASH JOIN                  |        |66       |337 |
|4 |    EXCHANGE IN DISTR         |        |100      |106 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |97  |
|6 |      TABLE SCAN              |t9      |100      |78  |
|7 |    PX PARTITION ITERATOR     |        |200      |155 |
|8 |     TABLE SCAN               |t10     |200      |155 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t9.c2, t9.c3, t9.c2, t10.c3)]), filter(nil), sort_keys([t9.c2, ASC], [t9.c3, DESC])
  1 - output([t9.c2], [t9.c3], [INTERNAL_FUNCTION(t9.c2, t9.c3, t9.c2, t10.c3)]), filter(nil), dop=1
  2 - output([t9.c2], [t9.c3], [t10.c3]), filter(nil), sort_keys([t9.c2, ASC], [t9.c3, DESC])
  3 - output([t9.c2], [t9.c3], [t10.c3]), filter(nil), 
      equal_conds([t9.c2 = t10.c2], [t9.c3 = t10.c3]), other_conds(nil)
  4 - output([t9.c2], [t9.c3]), filter(nil)
  5 - (#keys=1, [t9.c2]), output([t9.c2], [t9.c3]), filter(nil), is_single, dop=1
  6 - output([t9.c2], [t9.c3]), filter(nil), 
      access([t9.c2], [t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  7 - output([t10.c2], [t10.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t10.c2], [t10.c3]), filter(nil), 
      access([t10.c2], [t10.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t10.c1], [t10.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 329(end)  ************** 

***************   Case 330   ***************

SQL: select c1, (select count(c1) from t7 where c1=t4.c1) calc_total, (select count(c1) from t8 where c1=0 and c1=t4.c1) calc_new from t4 where c1 in (select distinct c1 from t1); 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SUBPLAN FILTER                |        |90       |8828|
|1 | PX COORDINATOR               |        |90       |649 |
|2 |  EXCHANGE OUT DISTR          |:EX10001|90       |641 |
|3 |   HASH JOIN                  |        |90       |624 |
|4 |    EXCHANGE IN DISTR         |        |100      |94  |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|6 |      TABLE SCAN              |t4      |100      |78  |
|7 |    PX PARTITION ITERATOR     |        |500      |387 |
|8 |     TABLE SCAN               |t1      |500      |387 |
|9 | SCALAR GROUP BY              |        |1        |46  |
|10|  TABLE GET                   |t7      |1        |46  |
|11| SCALAR GROUP BY              |        |1        |46  |
|12|  TABLE GET                   |t8      |1        |46  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [subquery(1)], [subquery(2)]), filter(nil), 
      exec_params_([t4.c1], [? = t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1]), filter(nil)
  2 - output([t4.c1]), filter(nil), dop=1
  3 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  4 - output([t4.c1]), filter(nil)
  5 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  6 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  10 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 = ?])
  11 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  12 - output(nil), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[0 ; 0], 
      range_cond([t8.c1 = ?])

*************** Case 330(end)  ************** 

***************   Case 331   ***************

SQL: select c1, (select count(c1) from t7 ) calc_total, (select count(c1) from t8 ) calc_new from t4  where c1 in (select distinct c1 from t1); 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN     |        |90       |391 |
|1 | NESTED-LOOP JOIN CARTESIAN    |        |90       |285 |
|2 |  SUBPLAN SCAN                 |VIEW2   |1        |81  |
|3 |   SCALAR GROUP BY             |        |1        |81  |
|4 |    TABLE SCAN                 |t7      |100      |78  |
|5 |  PX COORDINATOR               |        |90       |649 |
|6 |   EXCHANGE OUT DISTR          |:EX10001|90       |641 |
|7 |    HASH JOIN                  |        |90       |624 |
|8 |     EXCHANGE IN DISTR         |        |100      |94  |
|9 |      EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|10|       TABLE SCAN              |t4      |100      |78  |
|11|     PX PARTITION ITERATOR     |        |500      |387 |
|12|      TABLE SCAN               |t1      |500      |387 |
|13| MATERIAL                      |        |1        |81  |
|14|  SUBPLAN SCAN                 |VIEW3   |1        |81  |
|15|   SCALAR GROUP BY             |        |1        |81  |
|16|    TABLE SCAN                 |t8      |100      |78  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [VIEW2.count(c1)], [VIEW3.count(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [VIEW2.count(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW2.count(c1)]), filter(nil), 
      access([VIEW2.count(c1)])
  3 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t4.c1]), filter(nil)
  6 - output([t4.c1]), filter(nil), dop=1
  7 - output([t4.c1]), filter(nil), 
      equal_conds([t4.c1 = t1.c1]), other_conds(nil)
  8 - output([t4.c1]), filter(nil)
  9 - (#keys=1, [t4.c1]), output([t4.c1]), filter(nil), is_single, dop=1
  10 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  11 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  13 - output([VIEW3.count(c1)]), filter(nil)
  14 - output([VIEW3.count(c1)]), filter(nil), 
      access([VIEW3.count(c1)])
  15 - output([T_FUN_COUNT(t8.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t8.c1)])
  16 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 331(end)  ************** 

***************   Case 332   ***************

SQL: select distinct (select c1) from t4 limit 100; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |LIMIT          |    |10       |82  |
|1 | MERGE DISTINCT|    |10       |82  |
|2 |  TABLE SCAN   |t4  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), limit(100), offset(nil)
  1 - output([t4.c1]), filter(nil), 
      distinct([t4.c1])
  2 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 332(end)  ************** 

***************   Case 333   ***************

SQL: select * from t7,t8 where t7.c1=t8.c1 having false; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |2736|
|1 | TABLE SCAN               |t7  |100      |78  |
|2 | MATERIAL                 |    |100      |79  |
|3 |  TABLE SCAN              |t8  |100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil)
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 333(end)  ************** 

***************   Case 334   ***************

SQL: select c1,sum(c2) from t7 where c1>1 group by c1 having c1+1>1 and sum(c2) >1 and 1=2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [cast(t7.c2, DECIMAL(11, 0))]), filter(nil), startup_filter([0]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 334(end)  ************** 

***************   Case 335   ***************

SQL: select * from t7 where c1 in (select c1 from t8 where t7.c1>1 limit 1); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |4619|
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([t7.c1 = ANY(subquery(1))]), 
      exec_params_([t7.c1 > ?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1]), filter(nil), startup_filter([?]), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 335(end)  ************** 

***************   Case 336   ***************

SQL: select * from t1,t14 where t1.c1 = t14.c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |450      |1309|
|1 | EXCHANGE OUT DISTR    |:EX10000|450      |1216|
|2 |  PX PARTITION ITERATOR|        |450      |1016|
|3 |   HASH JOIN           |        |450      |1016|
|4 |    TABLE SCAN         |t1      |500      |387 |
|5 |    TABLE SCAN         |t14     |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t14.c1, t14.c2, t14.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t14.c1, t14.c2, t14.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t14.c3], [t1.c2], [t14.c1], [t14.c2]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t1.c1], [t14.c3], [t1.c2], [t14.c1], [t14.c2]), filter(nil), 
      equal_conds([t1.c1 = t14.c3]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      access([t14.c1], [t14.c2], [t14.c3]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 336(end)  ************** 

***************   Case 337   ***************

SQL: select * from t5,t16 where t5.c2 = t16.c2; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH JOIN               |        |730      |853 |
|1 | PX COORDINATOR         |        |300      |354 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|300      |314 |
|3 |   PX PARTITION ITERATOR|        |300      |233 |
|4 |    TABLE SCAN          |t5      |300      |233 |
|5 | PX COORDINATOR         |        |300      |354 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300      |314 |
|7 |   PX PARTITION ITERATOR|        |300      |233 |
|8 |    TABLE SCAN          |t16     |300      |233 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      equal_conds([t5.c2 = t16.c2]), other_conds(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  2 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), dop=1
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c1], [t16.c2], [t16.c3]), filter(nil)
  6 - output([t16.c1], [t16.c2], [t16.c3]), filter(nil), dop=1
  7 - output([t16.c3], [t16.c2], [t16.c1]), filter(nil), 
      force partition granule.
  8 - output([t16.c3], [t16.c2], [t16.c1]), filter(nil), 
      access([t16.c3], [t16.c2], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 337(end)  ************** 

***************   Case 338   ***************

SQL: select * from t5,t16 where t5.c2 = t16.c2 and t5.c3 = t16.c3; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |197      |749 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |197      |701 |
|2 |  PX PARTITION ITERATOR|             |197      |597 |
|3 |   MERGE JOIN          |             |197      |597 |
|4 |    TABLE SCAN         |t5(idx_t5_c3)|300      |290 |
|5 |    TABLE SCAN         |t16          |300      |233 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t16.c1, t16.c2, t16.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t16.c1, t16.c2, t16.c3)]), filter(nil), dop=1
  2 - output([t5.c3], [t16.c3], [t5.c2], [t16.c2], [t5.c1], [t16.c1]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t5.c3], [t16.c3], [t5.c2], [t16.c2], [t5.c1], [t16.c1]), filter(nil), 
      equal_conds([t5.c3 = t16.c3], [t5.c2 = t16.c2]), other_conds(nil)
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, 
      range_key([t5.c3], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c3], [t16.c2], [t16.c1]), filter(nil), 
      access([t16.c3], [t16.c2], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 338(end)  ************** 

***************   Case 339   ***************

SQL: select * from t5,t16 where t5.c2 = t16.c2 and t5.c3 = t16.c3 and t5.c1 = t16.c1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |160      |712 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |160      |673 |
|2 |  PX PARTITION ITERATOR|             |160      |589 |
|3 |   MERGE JOIN          |             |160      |589 |
|4 |    TABLE SCAN         |t5(idx_t5_c3)|300      |290 |
|5 |    TABLE SCAN         |t16          |300      |233 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t16.c1, t16.c2, t16.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t16.c1, t16.c2, t16.c3)]), filter(nil), dop=1
  2 - output([t5.c3], [t16.c3], [t5.c2], [t16.c2], [t5.c1], [t16.c1]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t5.c3], [t16.c3], [t5.c2], [t16.c2], [t5.c1], [t16.c1]), filter(nil), 
      equal_conds([t5.c3 = t16.c3], [t5.c2 = t16.c2], [t5.c1 = t16.c1]), other_conds(nil)
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, 
      range_key([t5.c3], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c3], [t16.c2], [t16.c1]), filter(nil), 
      access([t16.c3], [t16.c2], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 339(end)  ************** 

***************   Case 340   ***************

SQL: select * from t17,t18 where t17.c2 + t17.c3 = t18.c2 + t18.c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |450      |959 |
|1 | EXCHANGE OUT DISTR    |:EX10000|450      |849 |
|2 |  PX PARTITION ITERATOR|        |450      |611 |
|3 |   HASH JOIN           |        |450      |611 |
|4 |    TABLE SCAN         |t17     |300      |233 |
|5 |    TABLE SCAN         |t18     |300      |233 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t17.c1, t17.c2, t17.c3, t18.c1, t18.c2, t18.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t17.c1, t17.c2, t17.c3, t18.c1, t18.c2, t18.c3)]), filter(nil), dop=1
  2 - output([t17.c2], [t17.c3], [t18.c2], [t18.c3], [t17.c1], [t18.c1]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t17.c2], [t17.c3], [t18.c2], [t18.c3], [t17.c1], [t18.c1]), filter(nil), 
      equal_conds([t17.c2 + t17.c3 = t18.c2 + t18.c3]), other_conds(nil)
  4 - output([t17.c1], [t17.c2], [t17.c3]), filter(nil), 
      access([t17.c1], [t17.c2], [t17.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t18.c1], [t18.c2], [t18.c3]), filter(nil), 
      access([t18.c1], [t18.c2], [t18.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t18.c1], [t18.c2], [t18.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 340(end)  ************** 

***************   Case 341   ***************

SQL: select * from z1,z2 where z1.a = z2.a; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |188 |
|1 | TABLE SCAN|z1  |100      |78  |
|2 | TABLE SCAN|z2  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([z1.a], [z1.b], [z1.c], [z1.d], [z2.a], [z2.b], [z2.c], [z2.d]), filter(nil), 
      equal_conds([z1.a = z2.a]), other_conds(nil)
  1 - output([z1.a], [z1.b], [z1.c], [z1.d]), filter(nil), 
      access([z1.a], [z1.b], [z1.c], [z1.d]), partitions(p0), 
      is_index_back=false, 
      range_key([z1.a]), range(MIN ; MAX)always true
  2 - output([z2.a], [z2.b], [z2.c], [z2.d]), filter(nil), 
      access([z2.a], [z2.b], [z2.c], [z2.d]), partitions(p0), 
      is_index_back=false, 
      range_key([z2.a]), range(MIN ; MAX)always true

*************** Case 341(end)  ************** 

***************   Case 342   ***************

SQL: select * from t2,t6 where t2.c1 = t6.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1000|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |904 |
|2 |  HASH JOIN                  |        |300      |694 |
|3 |   EXCHANGE IN DISTR         |        |300      |317 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |289 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t6      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2)]), filter(nil), dop=1
  2 - output([t2.c1], [t6.c1], [t6.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t6.c1], [t6.c2]), filter(nil)
  4 - (#keys=1, [t6.c1]), output([t6.c1], [t6.c2]), filter(nil), dop=1
  5 - output([t6.c1], [t6.c2]), filter(nil), 
      force partition granule.
  6 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 342(end)  ************** 

***************   Case 343   ***************

SQL: select * from t1,t2 where t1.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1260|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |1164|
|2 |  HASH JOIN                  |        |300      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 343(end)  ************** 

***************   Case 344   ***************

SQL: select * from t5,t6 where t5.c2 = t6.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |270      |907 |
|1 | EXCHANGE OUT DISTR          |:EX10001|270      |851 |
|2 |  HASH JOIN                  |        |270      |731 |
|3 |   PX PARTITION ITERATOR     |        |300      |233 |
|4 |    TABLE SCAN               |t6      |300      |233 |
|5 |   EXCHANGE IN DISTR         |        |300      |354 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |314 |
|7 |     PX PARTITION ITERATOR   |        |300      |233 |
|8 |      TABLE SCAN             |t5      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t6.c1, t6.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t6.c1, t6.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t6.c1], [t6.c2], [t5.c3], [t5.c1]), filter(nil), 
      equal_conds([t5.c2 = t6.c1]), other_conds(nil)
  3 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  5 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil)
  6 - (#keys=1, [t5.c2]), output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  7 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  8 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 344(end)  ************** 

***************   Case 345   ***************

SQL: select * from t1,t14 where t1.c1 = t14.c3 and t1.c2 = t14.c2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |365      |1268|
|1 | EXCHANGE OUT DISTR    |:EX10000|365      |1193|
|2 |  PX PARTITION ITERATOR|        |365      |1031|
|3 |   HASH JOIN           |        |365      |1031|
|4 |    TABLE SCAN         |t1      |500      |387 |
|5 |    TABLE SCAN         |t14     |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t14.c1, t14.c2, t14.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t14.c1, t14.c2, t14.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t14.c3], [t1.c2], [t14.c2], [t14.c1]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t1.c1], [t14.c3], [t1.c2], [t14.c2], [t14.c1]), filter(nil), 
      equal_conds([t1.c1 = t14.c3], [t1.c2 = t14.c2]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      access([t14.c1], [t14.c2], [t14.c3]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 345(end)  ************** 

***************   Case 346   ***************

SQL: select * from t1,t14 where t1.c1 + 1 = t14.c3 + 1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH JOIN               |        |500      |1359|
|1 | PX COORDINATOR         |        |500      |528 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|3 |   PX PARTITION ITERATOR|        |500      |387 |
|4 |    TABLE SCAN          |t1      |500      |387 |
|5 | PX COORDINATOR         |        |500      |589 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|500      |524 |
|7 |   PX PARTITION ITERATOR|        |500      |387 |
|8 |    TABLE SCAN          |t14     |500      |387 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      equal_conds([t1.c1 + ? = t14.c3 + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  6 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), dop=1
  7 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      force partition granule.
  8 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      access([t14.c1], [t14.c2], [t14.c3]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 346(end)  ************** 

***************   Case 347   ***************

SQL: select * from t1 left join t14 on t1.c1 = t14.c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |1341|
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |1238|
|2 |  PX PARTITION ITERATOR|        |500      |1016|
|3 |   HASH OUTER JOIN     |        |500      |1016|
|4 |    TABLE SCAN         |t1      |500      |387 |
|5 |    TABLE SCAN         |t14     |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t14.c1, t14.c2, t14.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t14.c1, t14.c2, t14.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t14.c3], [t1.c2], [t14.c1], [t14.c2]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t1.c1], [t14.c3], [t1.c2], [t14.c1], [t14.c2]), filter(nil), 
      equal_conds([t1.c1 = t14.c3]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      access([t14.c1], [t14.c2], [t14.c3]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 347(end)  ************** 

***************   Case 348   ***************

SQL: select * from t5 left join t16 on t5.c2 = t16.c2; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH OUTER JOIN         |        |730      |853 |
|1 | PX COORDINATOR         |        |300      |354 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|300      |314 |
|3 |   PX PARTITION ITERATOR|        |300      |233 |
|4 |    TABLE SCAN          |t5      |300      |233 |
|5 | PX COORDINATOR         |        |300      |354 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300      |314 |
|7 |   PX PARTITION ITERATOR|        |300      |233 |
|8 |    TABLE SCAN          |t16     |300      |233 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t5.c1], [t5.c2], [t5.c3], [t16.c1], [t16.c2], [t16.c3]), filter(nil), 
      equal_conds([t5.c2 = t16.c2]), other_conds(nil)
  1 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  2 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), dop=1
  3 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c1], [t16.c2], [t16.c3]), filter(nil)
  6 - output([t16.c1], [t16.c2], [t16.c3]), filter(nil), dop=1
  7 - output([t16.c3], [t16.c2], [t16.c1]), filter(nil), 
      force partition granule.
  8 - output([t16.c3], [t16.c2], [t16.c1]), filter(nil), 
      access([t16.c3], [t16.c2], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 348(end)  ************** 

***************   Case 349   ***************

SQL: select * from t5 left join t16 on t5.c2 = t16.c2 and t5.c3 = t16.c3; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |300      |829 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |300      |756 |
|2 |  PX PARTITION ITERATOR|             |300      |597 |
|3 |   MERGE OUTER JOIN    |             |300      |597 |
|4 |    TABLE SCAN         |t5(idx_t5_c3)|300      |290 |
|5 |    TABLE SCAN         |t16          |300      |233 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t16.c1, t16.c2, t16.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t16.c1, t16.c2, t16.c3)]), filter(nil), dop=1
  2 - output([t5.c3], [t16.c3], [t5.c2], [t16.c2], [t5.c1], [t16.c1]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t5.c3], [t16.c3], [t5.c2], [t16.c2], [t5.c1], [t16.c1]), filter(nil), 
      equal_conds([t5.c3 = t16.c3], [t5.c2 = t16.c2]), other_conds(nil)
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, 
      range_key([t5.c3], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c3], [t16.c2], [t16.c1]), filter(nil), 
      access([t16.c3], [t16.c2], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 349(end)  ************** 

***************   Case 350   ***************

SQL: select * from t5 left join t16 on t5.c2 = t16.c2 and t5.c3 = t16.c3 and t5.c1 = t16.c1; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |300      |820 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |300      |747 |
|2 |  PX PARTITION ITERATOR|             |300      |589 |
|3 |   MERGE OUTER JOIN    |             |300      |589 |
|4 |    TABLE SCAN         |t5(idx_t5_c3)|300      |290 |
|5 |    TABLE SCAN         |t16          |300      |233 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t16.c1, t16.c2, t16.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t16.c1, t16.c2, t16.c3)]), filter(nil), dop=1
  2 - output([t5.c3], [t16.c3], [t5.c2], [t16.c2], [t5.c1], [t16.c1]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t5.c3], [t16.c3], [t5.c2], [t16.c2], [t5.c1], [t16.c1]), filter(nil), 
      equal_conds([t5.c3 = t16.c3], [t5.c2 = t16.c2], [t5.c1 = t16.c1]), other_conds(nil)
  4 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, 
      range_key([t5.c3], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true
  5 - output([t16.c3], [t16.c2], [t16.c1]), filter(nil), 
      access([t16.c3], [t16.c2], [t16.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t16.c3], [t16.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 350(end)  ************** 

***************   Case 351   ***************

SQL: select * from t17 left join t18 on t17.c2 + t17.c3 = t18.c2 + t18.c3; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |450      |959 |
|1 | EXCHANGE OUT DISTR    |:EX10000|450      |849 |
|2 |  PX PARTITION ITERATOR|        |450      |611 |
|3 |   HASH OUTER JOIN     |        |450      |611 |
|4 |    TABLE SCAN         |t17     |300      |233 |
|5 |    TABLE SCAN         |t18     |300      |233 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t17.c1, t17.c2, t17.c3, t18.c1, t18.c2, t18.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t17.c1, t17.c2, t17.c3, t18.c1, t18.c2, t18.c3)]), filter(nil), dop=1
  2 - output([t17.c2], [t17.c3], [t18.c2], [t18.c3], [t17.c1], [t18.c1]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t17.c2], [t17.c3], [t18.c2], [t18.c3], [t17.c1], [t18.c1]), filter(nil), 
      equal_conds([t17.c2 + t17.c3 = t18.c2 + t18.c3]), other_conds(nil)
  4 - output([t17.c1], [t17.c2], [t17.c3]), filter(nil), 
      access([t17.c1], [t17.c2], [t17.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  5 - output([t18.c1], [t18.c2], [t18.c3]), filter(nil), 
      access([t18.c1], [t18.c2], [t18.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t18.c1], [t18.c2], [t18.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 351(end)  ************** 

***************   Case 352   ***************

SQL: select * from z1 left join z2 on z1.a = z2.a; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |100      |188 |
|1 | TABLE SCAN     |z1  |100      |78  |
|2 | TABLE SCAN     |z2  |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([z1.a], [z1.b], [z1.c], [z1.d], [z2.a], [z2.b], [z2.c], [z2.d]), filter(nil), 
      equal_conds([z1.a = z2.a]), other_conds(nil)
  1 - output([z1.a], [z1.b], [z1.c], [z1.d]), filter(nil), 
      access([z1.a], [z1.b], [z1.c], [z1.d]), partitions(p0), 
      is_index_back=false, 
      range_key([z1.a]), range(MIN ; MAX)always true
  2 - output([z2.a], [z2.b], [z2.c], [z2.d]), filter(nil), 
      access([z2.a], [z2.b], [z2.c], [z2.d]), partitions(p0), 
      is_index_back=false, 
      range_key([z2.a]), range(MIN ; MAX)always true

*************** Case 352(end)  ************** 

***************   Case 353   ***************

SQL: select * from t2 left join t6 on t2.c1 = t6.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |1000|
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |904 |
|2 |  HASH RIGHT OUTER JOIN      |        |300      |694 |
|3 |   EXCHANGE IN DISTR         |        |300      |317 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |289 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t6      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, t6.c1, t6.c2)]), filter(nil), dop=1
  2 - output([t2.c1], [t6.c1], [t6.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t6.c1]), other_conds(nil)
  3 - output([t6.c1], [t6.c2]), filter(nil)
  4 - (#keys=1, [t6.c1]), output([t6.c1], [t6.c2]), filter(nil), dop=1
  5 - output([t6.c1], [t6.c2]), filter(nil), 
      force partition granule.
  6 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 353(end)  ************** 

***************   Case 354   ***************

SQL: select * from t1 left join t2 on t1.c1 = t2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |1464|
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |1304|
|2 |  HASH OUTER JOIN            |        |500      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 354(end)  ************** 

***************   Case 355   ***************

SQL: select * from t5 left join t6 on t5.c2 = t6.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |926 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |864 |
|2 |  HASH RIGHT OUTER JOIN      |        |300      |731 |
|3 |   PX PARTITION ITERATOR     |        |300      |233 |
|4 |    TABLE SCAN               |t6      |300      |233 |
|5 |   EXCHANGE IN DISTR         |        |300      |354 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |314 |
|7 |     PX PARTITION ITERATOR   |        |300      |233 |
|8 |      TABLE SCAN             |t5      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t6.c1, t6.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t5.c1, t5.c2, t5.c3, t6.c1, t6.c2)]), filter(nil), dop=1
  2 - output([t5.c2], [t6.c1], [t6.c2], [t5.c3], [t5.c1]), filter(nil), 
      equal_conds([t5.c2 = t6.c1]), other_conds(nil)
  3 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true
  5 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil)
  6 - (#keys=1, [t5.c2]), output([t5.c2], [t5.c3], [t5.c1]), filter(nil), dop=1
  7 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  8 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c2], [t5.c3]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 355(end)  ************** 

***************   Case 356   ***************

SQL: select * from t1 left join t14 on t1.c1 = t14.c3 and t1.c2 = t14.c2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |1356|
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |1253|
|2 |  PX PARTITION ITERATOR|        |500      |1031|
|3 |   HASH OUTER JOIN     |        |500      |1031|
|4 |    TABLE SCAN         |t1      |500      |387 |
|5 |    TABLE SCAN         |t14     |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t14.c1, t14.c2, t14.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t14.c1, t14.c2, t14.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t14.c3], [t1.c2], [t14.c2], [t14.c1]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t1.c1], [t14.c3], [t1.c2], [t14.c2], [t14.c1]), filter(nil), 
      equal_conds([t1.c1 = t14.c3], [t1.c2 = t14.c2]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      access([t14.c1], [t14.c2], [t14.c3]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 356(end)  ************** 

***************   Case 357   ***************

SQL: select * from t1 left join t14 on t1.c1 + 1 = t14.c3 + 1; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH OUTER JOIN         |        |500      |1359|
|1 | PX COORDINATOR         |        |500      |528 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|3 |   PX PARTITION ITERATOR|        |500      |387 |
|4 |    TABLE SCAN          |t1      |500      |387 |
|5 | PX COORDINATOR         |        |500      |589 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|500      |524 |
|7 |   PX PARTITION ITERATOR|        |500      |387 |
|8 |    TABLE SCAN          |t14     |500      |387 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      equal_conds([t1.c1 + ? = t14.c3 + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil)
  6 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), dop=1
  7 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      force partition granule.
  8 - output([t14.c1], [t14.c2], [t14.c3]), filter(nil), 
      access([t14.c1], [t14.c2], [t14.c3]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 357(end)  ************** 

***************   Case 358   ***************

SQL: select SQL_CALC_FOUND_ROWS c2,count(*) as c from t1 group by c2 order by c desc ; 

==================================================================
|ID|OPERATOR                        |NAME         |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT       |             |100      |549 |
|1 | EXCHANGE OUT DISTR             |:EX10001     |100      |536 |
|2 |  SORT                          |             |100      |509 |
|3 |   MERGE GROUP BY               |             |100      |453 |
|4 |    EXCHANGE IN MERGE SORT DISTR|             |100      |446 |
|5 |     EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |437 |
|6 |      PX PARTITION ITERATOR     |             |100      |418 |
|7 |       MERGE GROUP BY           |             |100      |418 |
|8 |        TABLE SCAN              |t1(idx_t1_c2)|500      |387 |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(*)))]), filter(nil), sort_keys([T_FUN_COUNT_SUM(T_FUN_COUNT(*)), DESC])
  1 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [INTERNAL_FUNCTION(t1.c2, T_FUN_COUNT_SUM(T_FUN_COUNT(*)))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), sort_keys([T_FUN_COUNT_SUM(T_FUN_COUNT(*)), DESC])
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  4 - output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  5 - (#keys=1, [t1.c2]), output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), dop=1
  6 - output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), 
      force partition granule.
  7 - output([T_FUN_COUNT(*)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_COUNT(*)])
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 358(end)  ************** 

***************   Case 359   ***************

SQL: select count(1)+1 from t1 order by count(1)+1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |414 |
|1 | PX COORDINATOR          |        |1        |414 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |414 |
|3 |   MERGE GROUP BY        |        |1        |414 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*)) + ?]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)], [T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)], [T_FUN_COUNT(*)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)], [T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)], [T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 359(end)  ************** 

***************   Case 360   ***************

SQL: delete from t7 where exists(select 1 from t8); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |100      |636 |
|1 | SUBPLAN FILTER|    |100      |125 |
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  TABLE SCAN   |t8  |1        |46  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t7: ({t7: (t7.c1, t7.c2)})}])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 360(end)  ************** 

***************   Case 361   ***************

SQL: select t3.c1 from t3, t1 where  t3.c2 = t1.c1 and t3.c1 = 1 and exists(select 'X' from t2 where t2.c2 = t1.c2); 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |NESTED-LOOP SEMI JOIN         |        |1        |232 |
|1 | PX COORDINATOR               |        |1        |53  |
|2 |  EXCHANGE OUT DISTR          |:EX10001|1        |53  |
|3 |   NESTED-LOOP JOIN           |        |1        |53  |
|4 |    EXCHANGE IN DISTR         |        |1        |46  |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|6 |      TABLE GET               |t3      |1        |46  |
|7 |    PX PARTITION ITERATOR     |        |1        |29  |
|8 |     TABLE GET                |t1      |1        |29  |
|9 | PX COORDINATOR               |        |300      |280 |
|10|  EXCHANGE OUT DISTR          |:EX20000|300      |263 |
|11|   PX PARTITION ITERATOR      |        |300      |233 |
|12|    TABLE SCAN                |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c1]), filter(nil), 
      conds([t2.c2 = t1.c2]), nl_params_(nil), batch_join=false
  1 - output([t3.c1], [t1.c2]), filter(nil)
  2 - output([t3.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t3.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t3.c2]), batch_join=false
  4 - output([t3.c1], [PARTITION_ID], [t3.c2]), filter(nil)
  5 - (#keys=1, [t3.c2]), output([t3.c1], [PARTITION_ID], [t3.c2]), filter(nil), is_single, dop=1
  6 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t3.c1]), range[1 ; 1], 
      range_cond([t3.c1 = ?])
  7 - output([t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([? = t1.c1])
  9 - output([t2.c2]), filter(nil)
  10 - output([t2.c2]), filter(nil), dop=1
  11 - output([t2.c2]), filter(nil), 
      force partition granule.
  12 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 361(end)  ************** 

***************   Case 362   ***************

SQL: select c1, c2 from t3 where c1 in (select a.c1 from t1 a, t2 b where b.c1=100 and a.c2=b.c2); 

==============================================================
|ID|OPERATOR                     |NAME        |EST. ROWS|COST|
--------------------------------------------------------------
|0 |PX COORDINATOR               |            |2        |137 |
|1 | EXCHANGE OUT DISTR          |:EX10002    |2        |136 |
|2 |  NESTED-LOOP JOIN           |            |2        |136 |
|3 |   EXCHANGE IN DISTR         |            |5        |105 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10001    |5        |105 |
|5 |     NESTED-LOOP JOIN        |            |5        |103 |
|6 |      EXCHANGE IN DISTR      |            |1        |46  |
|7 |       EXCHANGE OUT DISTR    |:EX10000    |1        |46  |
|8 |        TABLE GET            |b           |1        |46  |
|9 |      PX COORDINATOR         |            |5        |31  |
|10|       EXCHANGE OUT DISTR    |:EX20000    |5        |30  |
|11|        PX PARTITION ITERATOR|            |5        |29  |
|12|         TABLE SCAN          |a(idx_t1_c2)|5        |29  |
|13|   PX PARTITION ITERATOR     |            |1        |12  |
|14|    TABLE GET                |t3          |1        |12  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t3.c1, t3.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t3.c1, t3.c2)]), filter(nil), dop=1
  2 - output([t3.c1], [t3.c2]), filter(nil), 
      conds(nil), nl_params_([a.c1]), batch_join=false
  3 - output([PARTITION_ID], [a.c1]), filter(nil)
  4 - (#keys=1, [a.c1]), output([PARTITION_ID], [a.c1]), filter(nil), is_single, dop=1
  5 - output([a.c1]), filter(nil), 
      conds(nil), nl_params_([b.c2]), batch_join=false
  6 - output([b.c2]), filter(nil)
  7 - output([b.c2]), filter(nil), is_single, dop=1
  8 - output([b.c2]), filter(nil), 
      access([b.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([b.c1]), range[100 ; 100], 
      range_cond([b.c1 = ?])
  9 - output([a.c1]), filter(nil)
  10 - output([a.c1]), filter(nil), dop=1
  11 - output([a.c1]), filter(nil), 
      force partition granule.
  12 - output([a.c1]), filter(nil), 
      access([a.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([a.c2], [a.c1]), range(MIN ; MAX), 
      range_cond([a.c2 = ?])
  13 - output([t3.c1], [t3.c2]), filter(nil), 
      affinitize, force partition granule.
  14 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX), 
      range_cond([t3.c1 = ?])

*************** Case 362(end)  ************** 

***************   Case 363   ***************

SQL: select t7.c1, t8.c1 from t7 inner join t8 on t7.c1 > t8.c2 where t7.c1 = t8.c2 or exists ( select 1); 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER   |    |1682     |1169|
|1 | NESTED-LOOP JOIN|    |1682     |1140|
|2 |  TABLE SCAN     |t8  |100      |78  |
|3 |  TABLE SCAN     |t7  |34       |5   |
|4 | LIMIT           |    |1        |1   |
|5 |  EXPRESSION     |    |1        |1   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t8.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t8.c1]), filter(nil), 
      conds([t7.c1 = t8.c2 OR ?]), nl_params_([t8.c2]), batch_join=true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 > ?])
  4 - output([?]), filter(nil), limit(1), offset(nil)
  5 - output([1]), filter(nil)
      values({1})

*************** Case 363(end)  ************** 

***************   Case 364   ***************

SQL: (select substr('a',1,1) ) union (select 1); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 364(end)  ************** 

***************   Case 365   ***************

SQL: select * from t4, t7 where t4.c1 = t7.c1 and t4.c1 = 5; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100      |146 |
|1 | TABLE GET                |t7  |1        |46  |
|2 | TABLE SCAN               |t4  |100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([? = t7.c1])
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 365(end)  ************** 

***************   Case 366   ***************

SQL: select * from t4, t7 where t4.c2 = t7.c2 and t4.c2 = 5; 

===============================================================
|ID|OPERATOR                  |NAME            |EST. ROWS|COST|
---------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|                |900      |390 |
|1 | TABLE SCAN               |t4(idx_t4_c2_c3)|100      |78  |
|2 | MATERIAL                 |                |9        |79  |
|3 |  TABLE SCAN              |t7              |9        |79  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(5,MIN,MIN ; 5,MAX,MAX), 
      range_cond([t4.c2 = ?])
  2 - output([t7.c1], [t7.c2]), filter(nil)
  3 - output([t7.c1], [t7.c2]), filter([? = t7.c2]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 366(end)  ************** 

***************   Case 367   ***************

SQL: select * from t4, t7, t8 where t4.c1 = t7.c1 and t7.c1 = t8.c1 and t4.c1 = 5; 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |100      |193 |
|1 | NESTED-LOOP JOIN CARTESIAN|    |1        |92  |
|2 |  TABLE GET                |t7  |1        |46  |
|3 |  TABLE GET                |t8  |1        |46  |
|4 | TABLE SCAN                |t4  |100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([? = t7.c1])
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[5 ; 5], 
      range_cond([t8.c1 = ?])
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 367(end)  ************** 

***************   Case 368   ***************

SQL: select * from t4, t7, t8 where t4.c1 = t7.c1 and t7.c2 = t8.c2 and t4.c1 = 5; 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |HASH JOIN                  |    |900      |272 |
|1 | TABLE SCAN                |t8  |100      |78  |
|2 | NESTED-LOOP JOIN CARTESIAN|    |100      |146 |
|3 |  TABLE GET                |t7  |1        |46  |
|4 |  TABLE SCAN               |t4  |100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c2 = t8.c2]), other_conds(nil)
  1 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([? = t7.c1])
  4 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 368(end)  ************** 

***************   Case 369   ***************

SQL: select * from t4, t7, t8 where t4.c1 = t7.c1 and t7.c2 = t8.c2 and t4.c1 = 5 and t7.c2 = 9; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN  |    |81       |153 |
|1 | TABLE SCAN                 |t4  |100      |78  |
|2 | MATERIAL                   |    |1        |53  |
|3 |  NESTED-LOOP JOIN CARTESIAN|    |1        |53  |
|4 |   TABLE GET                |t7  |1        |46  |
|5 |   TABLE SCAN               |t8  |9        |79  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])
  2 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil)
  3 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  4 - output([t7.c1], [t7.c2]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([? = t7.c1])
  5 - output([t8.c1], [t8.c2]), filter([? = t8.c2]), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 369(end)  ************** 

***************   Case 370   ***************

SQL: select * from t4 join t7 on t4.c1 = t7.c1 where t4.c1 = 1; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100      |146 |
|1 | TABLE GET                |t7  |1        |46  |
|2 | TABLE SCAN               |t4  |100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[1 ; 1], 
      range_cond([t7.c1 = ?])
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 370(end)  ************** 

***************   Case 371   ***************

SQL: select * from t4 join t7 on t4.c1 = t7.c1 where t4.c2 = 1; 

================================================
|ID|OPERATOR   |NAME            |EST. ROWS|COST|
------------------------------------------------
|0 |HASH JOIN  |                |91       |204 |
|1 | TABLE SCAN|t7              |100      |78  |
|2 | TABLE SCAN|t4(idx_t4_c2_c3)|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t4.c1 = t7.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(1,MIN,MIN ; 1,MAX,MAX), 
      range_cond([t4.c2 = ?])

*************** Case 371(end)  ************** 

***************   Case 372   ***************

SQL: select * from t4 join t7 on t4.c1 = t7.c1 where t7.c1 = 1; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100      |146 |
|1 | TABLE GET                |t7  |1        |46  |
|2 | TABLE SCAN               |t4  |100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[1 ; 1], 
      range_cond([t7.c1 = ?])
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 372(end)  ************** 

***************   Case 373   ***************

SQL: select * from t4 join t7 on t4.c1 = t7.c1 where t7.c2 = 1; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |81       |145 |
|1 | TABLE SCAN     |t7  |9        |79  |
|2 | TABLE SCAN     |t4  |9        |5   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  1 - output([t7.c1], [t7.c2]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN ; MAX), 
      range_cond([t4.c1 = ?])

*************** Case 373(end)  ************** 

***************   Case 374   ***************

SQL: select * from t4 left join t7 on t4.c1 = t7.c1 where t4.c1 = 5; 

=========================================================
|ID|OPERATOR                        |NAME|EST. ROWS|COST|
---------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN|    |100      |151 |
|1 | TABLE SCAN                     |t4  |100      |78  |
|2 | MATERIAL                       |    |1        |46  |
|3 |  TABLE GET                     |t7  |1        |46  |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])
  2 - output([t7.c1], [t7.c2]), filter(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([t7.c1 = ?])

*************** Case 374(end)  ************** 

***************   Case 375   ***************

SQL: select * from t4 left join t7 on t4.c1 = t7.c1 where t4.c2 = 5; 

==========================================================
|ID|OPERATOR             |NAME            |EST. ROWS|COST|
----------------------------------------------------------
|0 |HASH RIGHT OUTER JOIN|                |100      |204 |
|1 | TABLE SCAN          |t7              |100      |78  |
|2 | TABLE SCAN          |t4(idx_t4_c2_c3)|100      |78  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t4.c1 = t7.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(5,MIN,MIN ; 5,MAX,MAX), 
      range_cond([t4.c2 = ?])

*************** Case 375(end)  ************** 

***************   Case 376   ***************

SQL: select * from t4 left join t7 on t4.c1 = t7.c1 where t7.c1 = 5; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100      |146 |
|1 | TABLE GET                |t7  |1        |46  |
|2 | TABLE SCAN               |t4  |100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range[5 ; 5], 
      range_cond([t7.c1 = ?])
  2 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 376(end)  ************** 

***************   Case 377   ***************

SQL: select /*+ FROZEN_VERSION(1) */max(c1) as c from t7; 

===============================================
|ID|OPERATOR       |NAME       |EST. ROWS|COST|
-----------------------------------------------
|0 |SCALAR GROUP BY|           |1        |46  |
|1 | SUBPLAN SCAN  |VIEW1      |1        |46  |
|2 |  TABLE SCAN   |t7(Reverse)|1        |46  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(VIEW1.t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW1.t7.c1)])
  1 - output([VIEW1.t7.c1]), filter(nil), 
      access([VIEW1.t7.c1])
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 377(end)  ************** 

***************   Case 378   ***************

SQL: select * from t4 where c1 in (select t7.c1 from t7,t8 where t4.c1=t7.c1+t8.c1 limit 1); 

============================================
|ID|OPERATOR          |NAME|EST. ROWS|COST |
--------------------------------------------
|0 |SUBPLAN FILTER    |    |50       |13746|
|1 | TABLE SCAN       |t4  |100      |78   |
|2 | LIMIT            |    |1        |137  |
|3 |  NESTED-LOOP JOIN|    |1        |137  |
|4 |   TABLE SCAN     |t7  |2        |46   |
|5 |   MATERIAL       |    |100      |78   |
|6 |    TABLE SCAN    |t8  |100      |78   |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = ANY(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t7.c1]), filter(nil), 
      conds([? = t7.c1 + t8.c1]), nl_params_(nil), batch_join=false
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil)
  6 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 378(end)  ************** 

***************   Case 379   ***************

SQL: select * from t4 where c1 in (select t7.c1 from t7,t8 where t4.c1+t7.c1=t8.c1 limit 1); 

===========================================
|ID|OPERATOR          |NAME|EST. ROWS|COST|
-------------------------------------------
|0 |SUBPLAN FILTER    |    |50       |5597|
|1 | TABLE SCAN       |t4  |100      |78  |
|2 | LIMIT            |    |1        |56  |
|3 |  NESTED-LOOP JOIN|    |1        |56  |
|4 |   TABLE SCAN     |t7  |1        |46  |
|5 |   TABLE GET      |t8  |1        |5   |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = ANY(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_([? + t7.c1]), batch_join=true
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])

*************** Case 379(end)  ************** 

***************   Case 380   ***************

SQL: select * from t4 where c1 in (select t7.c1 from t7,t8 where t4.c1+t7.c1=t4.c1+t8.c1 limit 1); 

========================================
|ID|OPERATOR      |NAME|EST. ROWS|COST |
----------------------------------------
|0 |SUBPLAN FILTER|    |50       |14797|
|1 | TABLE SCAN   |t4  |100      |78   |
|2 | LIMIT        |    |1        |148  |
|3 |  HASH JOIN   |    |1        |148  |
|4 |   TABLE SCAN |t7  |100      |78   |
|5 |   TABLE SCAN |t8  |1        |46   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter([t4.c1 = ANY(subquery(1))]), 
      exec_params_([t4.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true
  2 - output([t7.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t7.c1]), filter(nil), 
      equal_conds([? + t7.c1 = ? + t8.c1]), other_conds(nil)
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 380(end)  ************** 

***************   Case 381   ***************

SQL: select * from (select * from t1 where c1 > 0 group by c2) as v order by v.c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |             |100      |514 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |497 |
|2 |  MERGE GROUP BY               |             |100      |461 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |456 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |443 |
|5 |     PX PARTITION ITERATOR     |             |100      |415 |
|6 |      MERGE GROUP BY           |             |100      |415 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |393 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), sort_keys([t1.c2, ASC])
  1 - output([t1.c2], [INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  3 - output([t1.c2], [t1.c1]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([t1.c2], [t1.c1]), filter(nil), dop=1
  5 - output([t1.c2], [t1.c1]), filter(nil), 
      force partition granule.
  6 - output([t1.c2], [t1.c1]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  7 - output([t1.c1], [t1.c2]), filter([t1.c1 > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 381(end)  ************** 

***************   Case 382   ***************

SQL: select * from (select * from t1 where c1 > 0 limit 1) as v order by v.c2; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |SORT                       |        |1        |228 |
|1 | SUBPLAN SCAN              |v       |1        |228 |
|2 |  LIMIT                    |        |1        |228 |
|3 |   PX COORDINATOR          |        |1        |228 |
|4 |    EXCHANGE OUT DISTR     |:EX10000|1        |227 |
|5 |     LIMIT                 |        |1        |227 |
|6 |      PX PARTITION ITERATOR|        |1        |227 |
|7 |       TABLE SCAN          |t1      |1        |227 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([v.c1], [v.c2]), filter(nil), sort_keys([v.c2, ASC])
  1 - output([v.c1], [v.c2]), filter(nil), 
      access([v.c1], [v.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), limit(1), offset(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), limit(1), offset(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 382(end)  ************** 

***************   Case 383   ***************

SQL: select * from (select t2.c1 from t1,t2 where t1.c1=t2.c1 limit 1) v order by v.c1; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |SORT                             |        |1        |173 |
|1 | SUBPLAN SCAN                    |v       |1        |172 |
|2 |  LIMIT                          |        |1        |172 |
|3 |   PX COORDINATOR                |        |1        |172 |
|4 |    EXCHANGE OUT DISTR           |:EX10001|1        |172 |
|5 |     LIMIT                       |        |1        |172 |
|6 |      NESTED-LOOP JOIN           |        |1        |172 |
|7 |       EXCHANGE IN DISTR         |        |1        |137 |
|8 |        EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|9 |         PX PARTITION ITERATOR   |        |1        |137 |
|10|          TABLE SCAN             |t2      |1        |137 |
|11|       PX PARTITION ITERATOR     |        |1        |29  |
|12|        TABLE GET                |t1      |1        |29  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([v.c1]), filter(nil), sort_keys([v.c1, ASC]), local merge sort
  1 - output([v.c1]), filter(nil), 
      access([v.c1])
  2 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t2.c1]), filter(nil)
  4 - output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  6 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  7 - output([t2.c1], [PARTITION_ID]), filter(nil)
  8 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule.
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output(nil), filter(nil), 
      affinitize, force partition granule.
  12 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 383(end)  ************** 

***************   Case 384   ***************

SQL: select * from (select t1.c1 from t1,t2 where t1.c1=t2.c1 limit 1) v order by v.c1; 

==============================================================
|ID|OPERATOR                         |NAME    |EST. ROWS|COST|
--------------------------------------------------------------
|0 |SORT                             |        |1        |173 |
|1 | SUBPLAN SCAN                    |v       |1        |172 |
|2 |  LIMIT                          |        |1        |172 |
|3 |   PX COORDINATOR                |        |1        |172 |
|4 |    EXCHANGE OUT DISTR           |:EX10001|1        |172 |
|5 |     LIMIT                       |        |1        |172 |
|6 |      NESTED-LOOP JOIN           |        |1        |172 |
|7 |       EXCHANGE IN DISTR         |        |1        |137 |
|8 |        EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |137 |
|9 |         PX PARTITION ITERATOR   |        |1        |137 |
|10|          TABLE SCAN             |t2      |1        |137 |
|11|       PX PARTITION ITERATOR     |        |1        |29  |
|12|        TABLE GET                |t1      |1        |29  |
==============================================================

Outputs & filters: 
-------------------------------------
  0 - output([v.c1]), filter(nil), sort_keys([v.c1, ASC]), local merge sort
  1 - output([v.c1]), filter(nil), 
      access([v.c1])
  2 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t1.c1]), filter(nil)
  4 - output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  6 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  7 - output([PARTITION_ID], [t2.c1]), filter(nil)
  8 - (#keys=1, [t2.c1]), output([PARTITION_ID], [t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule.
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  12 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 384(end)  ************** 

***************   Case 385   ***************

SQL: select c1 from t1 having false; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), startup_filter([0])
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 385(end)  ************** 

***************   Case 386   ***************

SQL: select min(c1) from t1 having false; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |SCALAR GROUP BY              |        |0        |228 |
|1 | SUBPLAN SCAN                |VIEW1   |1        |228 |
|2 |  LIMIT                      |        |1        |228 |
|3 |   PX COORDINATOR MERGE SORT |        |1        |228 |
|4 |    EXCHANGE OUT DISTR       |:EX10000|1        |228 |
|5 |     TOP-N SORT              |        |1        |227 |
|6 |      PX PARTITION ITERATOR  |        |1        |227 |
|7 |       TABLE SCAN            |t1      |1        |227 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(VIEW1.t1.c1)]), filter([0]), 
      group(nil), agg_func([T_FUN_MIN(VIEW1.t1.c1)])
  1 - output([VIEW1.t1.c1]), filter(nil), 
      access([VIEW1.t1.c1])
  2 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  4 - output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), topn(1), local merge sort
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 386(end)  ************** 

***************   Case 387   ***************

SQL: select count(1) from t1 having false; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |0        |405 |
|1 | PX COORDINATOR          |        |1        |405 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |405 |
|3 |   MERGE GROUP BY        |        |1        |405 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter([0]), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 387(end)  ************** 

***************   Case 388   ***************

SQL: select c1 from t1 group by c1 having false; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), startup_filter([0])
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 388(end)  ************** 

***************   Case 389   ***************

SQL: select c1 from t1 group by c1 having c1>0; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 389(end)  ************** 

***************   Case 390   ***************

SQL: select c1 from t1 group by c1 having count(c2)>0; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |167      |447 |
|1 | EXCHANGE OUT DISTR    |:EX10000|167      |431 |
|2 |  PX PARTITION ITERATOR|        |167      |400 |
|3 |   TABLE SCAN          |t1      |167      |400 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter([CASE WHEN (T_OP_IS_NOT, t1.c2, NULL, 0) THEN 1 ELSE 0 END > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 390(end)  ************** 

***************   Case 391   ***************

SQL: select count(c1) from t1 group by c1 having count(c2)>0; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |167      |447 |
|1 | EXCHANGE OUT DISTR    |:EX10000|167      |431 |
|2 |  PX PARTITION ITERATOR|        |167      |400 |
|3 |   TABLE SCAN          |t1      |167      |400 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter([CASE WHEN (T_OP_IS_NOT, t1.c2, NULL, 0) THEN 1 ELSE 0 END > ?]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 391(end)  ************** 

***************   Case 392   ***************

SQL: select c1 from t1 group by c1 having c1 in (select c1 from t1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 392(end)  ************** 

***************   Case 393   ***************

SQL: select count(c1) from t1 group by c1 having c1 in (select c1 from t1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 393(end)  ************** 

***************   Case 394   ***************

SQL: select c1 from t1 group by c1 having 1 in (select c1 from t1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |500      |274 |
|1 | PX COORDINATOR           |        |1        |46  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t1      |1        |46  |
|4 | PX COORDINATOR           |        |500      |466 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|500      |439 |
|6 |   PX PARTITION ITERATOR  |        |500      |387 |
|7 |    TABLE SCAN            |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil)
  2 - output(nil), filter(nil), is_single, dop=1
  3 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 394(end)  ************** 

***************   Case 395   ***************

SQL: select count(c1) from t1 group by c1 having 1 in (select c1 from t1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |500      |274 |
|1 | PX COORDINATOR           |        |1        |46  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t1      |1        |46  |
|4 | PX COORDINATOR           |        |500      |466 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|500      |439 |
|6 |   PX PARTITION ITERATOR  |        |500      |387 |
|7 |    TABLE SCAN            |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil)
  2 - output(nil), filter(nil), is_single, dop=1
  3 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([t1.c1]), filter(nil)
  5 - output([t1.c1]), filter(nil), dop=1
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 395(end)  ************** 

***************   Case 396   ***************

SQL: select c1 from t1 group by c1 having c1 in (select t2.c1 from t2 where t1.c1=t2.c2); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |247 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |247 |
|2 |  NESTED-LOOP JOIN           |        |1        |246 |
|3 |   EXCHANGE IN DISTR         |        |1        |240 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |240 |
|5 |     PX PARTITION ITERATOR   |        |1        |240 |
|6 |      TABLE SCAN             |t2      |1        |240 |
|7 |   PX PARTITION ITERATOR     |        |1        |29  |
|8 |    TABLE GET                |t1      |1        |29  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c2]), batch_join=false
  3 - output([PARTITION_ID], [t2.c2]), filter(nil)
  4 - (#keys=1, [t2.c2]), output([PARTITION_ID], [t2.c2]), filter(nil), dop=1
  5 - output([t2.c2]), filter(nil), 
      force partition granule.
  6 - output([t2.c2]), filter([t2.c2 = t2.c1]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 396(end)  ************** 

***************   Case 397   ***************

SQL: select count(c1) from t1 group by c1 having c1 in (select t2.c1 from t2 where t1.c1=t2.c2); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |247 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |247 |
|2 |  NESTED-LOOP JOIN           |        |1        |246 |
|3 |   EXCHANGE IN DISTR         |        |1        |240 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |240 |
|5 |     PX PARTITION ITERATOR   |        |1        |240 |
|6 |      TABLE SCAN             |t2      |1        |240 |
|7 |   PX PARTITION ITERATOR     |        |1        |29  |
|8 |    TABLE GET                |t1      |1        |29  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(CASE WHEN (T_OP_IS_NOT, t1.c1, NULL, 0) THEN 1 ELSE 0 END)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t2.c2]), batch_join=false
  3 - output([PARTITION_ID], [t2.c2]), filter(nil)
  4 - (#keys=1, [t2.c2]), output([PARTITION_ID], [t2.c2]), filter(nil), dop=1
  5 - output([t2.c2]), filter(nil), 
      force partition granule.
  6 - output([t2.c2]), filter([t2.c2 = t2.c1]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 397(end)  ************** 

***************   Case 398   ***************

SQL: select c1 from t1 where c1 in (select c1 from t2 where c2 >= some(select c1 from t3 where t1.c2=t3.c1)); 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |90       |1388|
|1 | EXCHANGE OUT DISTR             |:EX10002|90       |1369|
|2 |  HASH JOIN                     |        |90       |1330|
|3 |   PX PARTITION ITERATOR        |        |200      |155 |
|4 |    TABLE SCAN                  |t3      |200      |155 |
|5 |   EXCHANGE IN DISTR            |        |300      |1055|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|300      |1004|
|7 |     HASH JOIN                  |        |300      |897 |
|8 |      EXCHANGE IN DISTR         |        |300      |317 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |289 |
|10|        PX PARTITION ITERATOR   |        |300      |233 |
|11|         TABLE SCAN             |t2      |300      |233 |
|12|      PX PARTITION ITERATOR     |        |500      |387 |
|13|       TABLE SCAN               |t1      |500      |387 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t3.c1]), other_conds([t2.c2 >= t3.c1])
  3 - output([t3.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t1.c2], [t1.c1], [t2.c2]), filter(nil)
  6 - (#keys=1, [t1.c2]), output([t1.c2], [t1.c1], [t2.c2]), filter(nil), dop=1
  7 - output([t1.c2], [t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t2.c1], [t2.c2]), filter(nil)
  9 - (#keys=1, [t2.c1]), output([t2.c1], [t2.c2]), filter(nil), dop=1
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 398(end)  ************** 

***************   Case 399   ***************

SQL: select * from (select c1 from t4 group by "adg") as a; 

================================================
|ID|OPERATOR      |NAME         |EST. ROWS|COST|
------------------------------------------------
|0 |MERGE GROUP BY|             |1        |80  |
|1 | TABLE SCAN   |t4(idx_t4_c2)|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 399(end)  ************** 

***************   Case 400   ***************

SQL: select c1 from t1 having count(c2)>0; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |405 |
|1 | PX COORDINATOR          |        |1        |405 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |405 |
|3 |   MERGE GROUP BY        |        |1        |405 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c2)) > ?]), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c2))])
  1 - output([t1.c1], [T_FUN_COUNT(t1.c2)]), filter(nil)
  2 - output([t1.c1], [T_FUN_COUNT(t1.c2)]), filter(nil), dop=1
  3 - output([t1.c1], [T_FUN_COUNT(t1.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c2)])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 400(end)  ************** 

***************   Case 401   ***************

SQL: select c1 from t1 having 3<(select 2); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), startup_filter([0])
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 401(end)  ************** 

***************   Case 402   ***************

SQL: select c1 from t1 having c1>(select 1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |475      |462 |
|1 | EXCHANGE OUT DISTR    |:EX10000|475      |436 |
|2 |  PX PARTITION ITERATOR|        |475      |387 |
|3 |   TABLE SCAN          |t1      |475      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(1 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 402(end)  ************** 

***************   Case 403   ***************

SQL: select c1 from t1 group by -1 having 3<(select 2); 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |MERGE GROUP BY           |        |1        |396 |
|1 | PX COORDINATOR          |        |1        |396 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |396 |
|3 |   MERGE GROUP BY        |        |1        |396 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), startup_filter([0]), 
      group(nil), agg_func(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      group(nil), agg_func(nil)
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 403(end)  ************** 

***************   Case 404   ***************

SQL: select * from t4 where c1 =1 order by c2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 404(end)  ************** 

***************   Case 405   ***************

SQL: select * from t4 where c1 =1 group by c2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t4  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(1,MIN ; 1,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 405(end)  ************** 

***************   Case 406   ***************

SQL: select * from t19 where c1 = 1 order by c2, c3, c4; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t19 |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), filter(nil), 
      access([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t19.c1 = ?])

*************** Case 406(end)  ************** 

***************   Case 407   ***************

SQL: select * from t19 where c1 = 1 group by c2, c3, c4; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t19 |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), filter(nil), 
      access([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t19.c1 = ?])

*************** Case 407(end)  ************** 

***************   Case 408   ***************

SQL: select * from t19 where c1 = 1 and c3 = 1 order by c2, c4; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t19 |9        |79  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), filter([t19.c3 = ?]), 
      access([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t19.c1 = ?])

*************** Case 408(end)  ************** 

***************   Case 409   ***************

SQL: select * from t19 where c1 = 1 and c3 = 1 group by c2, c4; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t19 |9        |79  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), filter([t19.c3 = ?]), 
      access([t19.c1], [t19.c2], [t19.c3], [t19.c4], [t19.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(1,MIN,MIN,MIN ; 1,MAX,MAX,MAX), 
      range_cond([t19.c1 = ?])

*************** Case 409(end)  ************** 

***************   Case 410   ***************

SQL: select c1 from t7 where c2 =1 order by c2, c1 desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t7(Reverse)|9        |79  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 410(end)  ************** 

***************   Case 411   ***************

SQL: select c1 from t7 where c2 in (1) order by c2, c1 desc; 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|t7(Reverse)|9        |79  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 411(end)  ************** 

***************   Case 412   ***************

SQL: select c1 from t7 group by (select c1 from t8), c2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |HASH GROUP BY  |    |10       |183 |
|1 | SUBPLAN FILTER|    |100      |157 |
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  TABLE SCAN   |t8  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 412(end)  ************** 

***************   Case 413   ***************

SQL: select c1 from t7 group by (select c1 from t8) desc, c2 desc; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SORT            |    |10       |186 |
|1 | HASH GROUP BY  |    |10       |183 |
|2 |  SUBPLAN FILTER|    |100      |157 |
|3 |   TABLE SCAN   |t7  |100      |78  |
|4 |   TABLE SCAN   |t8  |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, DESC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  2 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 413(end)  ************** 

***************   Case 414   ***************

SQL: select c1 from t7 group by (select c1 from t8) asc, c2 asc; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SORT            |    |10       |186 |
|1 | HASH GROUP BY  |    |10       |183 |
|2 |  SUBPLAN FILTER|    |100      |157 |
|3 |   TABLE SCAN   |t7  |100      |78  |
|4 |   TABLE SCAN   |t8  |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  2 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 414(end)  ************** 

***************   Case 415   ***************

SQL: select c1 from t7 group by (select c1 from t8) asc, c2 asc order by c1 desc; 

================================================
|ID|OPERATOR        |NAME       |EST. ROWS|COST|
------------------------------------------------
|0 |SORT            |           |10       |186 |
|1 | HASH GROUP BY  |           |10       |183 |
|2 |  SUBPLAN FILTER|           |100      |157 |
|3 |   TABLE SCAN   |t7(Reverse)|100      |78  |
|4 |   TABLE SCAN   |t8         |100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c1, DESC])
  1 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 415(end)  ************** 

***************   Case 416   ***************

SQL: select c1 from t7 group by c2 desc order by c2 asc; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SORT          |    |10       |107 |
|1 | HASH GROUP BY|    |10       |104 |
|2 |  TABLE SCAN  |t7  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 416(end)  ************** 

***************   Case 417   ***************

SQL: select c1 from t7 group by (select c1 from t8) desc, c2 desc order by (select c1 from t8) asc, c2 asc; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SORT             |    |10       |263 |
|1 | SUBPLAN FILTER  |    |10       |261 |
|2 |  HASH GROUP BY  |    |10       |183 |
|3 |   SUBPLAN FILTER|    |100      |157 |
|4 |    TABLE SCAN   |t7  |100      |78  |
|5 |    TABLE SCAN   |t8  |100      |78  |
|6 |  TABLE SCAN     |t8  |100      |78  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c2], [t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  3 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 417(end)  ************** 

***************   Case 418   ***************

SQL: select c1 from t7 group by (select c1 from t8) asc , c2 asc  order by (select c1 from t8) desc, c2 asc; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SORT             |    |10       |263 |
|1 | SUBPLAN FILTER  |    |10       |261 |
|2 |  HASH GROUP BY  |    |10       |183 |
|3 |   SUBPLAN FILTER|    |100      |157 |
|4 |    TABLE SCAN   |t7  |100      |78  |
|5 |    TABLE SCAN   |t8  |100      |78  |
|6 |  TABLE SCAN     |t8  |100      |78  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c2], [t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  3 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 418(end)  ************** 

***************   Case 419   ***************

SQL: select c1 from t7 group by (select c1 from t8)     , c2      order by (select c1 from t8) desc, c2 desc; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |SORT             |    |10       |263 |
|1 | SUBPLAN FILTER  |    |10       |261 |
|2 |  HASH GROUP BY  |    |10       |183 |
|3 |   SUBPLAN FILTER|    |100      |157 |
|4 |    TABLE SCAN   |t7  |100      |78  |
|5 |    TABLE SCAN   |t8  |100      |78  |
|6 |  TABLE SCAN     |t8  |100      |78  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, DESC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c2], [t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  3 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 419(end)  ************** 

***************   Case 420   ***************

SQL: select c1 from t7 group by (select c1 from t8) desc, c2 desc; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SORT            |    |10       |186 |
|1 | HASH GROUP BY  |    |10       |183 |
|2 |  SUBPLAN FILTER|    |100      |157 |
|3 |   TABLE SCAN   |t7  |100      |78  |
|4 |   TABLE SCAN   |t8  |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, DESC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  2 - output([t7.c2], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 420(end)  ************** 

***************   Case 421   ***************

SQL: select c1 from t7 group by c2 desc order by c2 asc, c1 desc; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SORT          |    |10       |107 |
|1 | HASH GROUP BY|    |10       |104 |
|2 |  TABLE SCAN  |t7  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC], [t7.c1, DESC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 421(end)  ************** 

***************   Case 422   ***************

SQL: select c1 from t7 group by c2 order by c2 asc, c1 desc; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SORT          |    |10       |107 |
|1 | HASH GROUP BY|    |10       |104 |
|2 |  TABLE SCAN  |t7  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC], [t7.c1, DESC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 422(end)  ************** 

***************   Case 423   ***************

SQL: select c1 from t7 order by c2 asc, c1 desc; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |SORT       |    |100      |135 |
|1 | TABLE SCAN|t7  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC], [t7.c1, DESC])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 423(end)  ************** 

***************   Case 424   ***************

SQL: select c1 from t7 group by (select c1 from t8) order by (select c1 from t8) asc; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |236 |
|1 | MERGE GROUP BY |    |1        |159 |
|2 |  SUBPLAN FILTER|    |100      |157 |
|3 |   TABLE SCAN   |t7  |100      |78  |
|4 |   TABLE SCAN   |t8  |100      |78  |
|5 | TABLE SCAN     |t8  |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      group(nil), agg_func(nil)
  2 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 424(end)  ************** 

***************   Case 425   ***************

SQL: select c1 from t7 group by (select c1 from t8) asc; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE GROUP BY |    |1        |159 |
|1 | SUBPLAN FILTER|    |100      |157 |
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  TABLE SCAN   |t8  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 425(end)  ************** 

***************   Case 426   ***************

SQL: select c1 from t7 group by c2 order by c2, c1; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SORT          |    |10       |107 |
|1 | HASH GROUP BY|    |10       |104 |
|2 |  TABLE SCAN  |t7  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), sort_keys([t7.c2, ASC], [t7.c1, ASC])
  1 - output([t7.c2], [t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 426(end)  ************** 

***************   Case 427   ***************

SQL: select avg(c2), count(c2) from t2; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |249 |
|1 | PX COORDINATOR          |        |1        |249 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |249 |
|3 |   MERGE GROUP BY        |        |1        |249 |
|4 |    PX PARTITION ITERATOR|        |300      |233 |
|5 |     TABLE SCAN          |t2      |300      |233 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t2.c2)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c2)), DECIMAL(20, 0))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c2))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c2))], [T_FUN_SUM(T_FUN_SUM(t2.c2))])
  1 - output([T_FUN_COUNT(t2.c2)], [T_FUN_SUM(t2.c2)]), filter(nil)
  2 - output([T_FUN_COUNT(t2.c2)], [T_FUN_SUM(t2.c2)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t2.c2)], [T_FUN_SUM(t2.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t2.c2)], [T_FUN_SUM(t2.c2)])
  4 - output([t2.c2]), filter(nil), 
      force partition granule.
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 427(end)  ************** 

***************   Case 428   ***************

SQL: select count(c2) from t7 group by c2; 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |10       |106 |
|1 | TABLE SCAN  |t7  |100      |78  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(t7.c2)]), filter(nil), 
      group([t7.c2]), agg_func([T_FUN_COUNT(t7.c2)])
  1 - output([t7.c2]), filter(nil), 
      access([t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 428(end)  ************** 

***************   Case 429   ***************

SQL: select sum(c2) from t7 group by c2; 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |10       |106 |
|1 | TABLE SCAN  |t7  |100      |78  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t7.c2)]), filter(nil), 
      group([t7.c2]), agg_func([T_FUN_SUM(t7.c2)])
  1 - output([t7.c2]), filter(nil), 
      access([t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 429(end)  ************** 

***************   Case 430   ***************

SQL: select avg(distinct c1), count(c2) from t2; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |255 |
|1 | PX COORDINATOR          |        |1        |255 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |254 |
|3 |   MERGE GROUP BY        |        |1        |254 |
|4 |    PX PARTITION ITERATOR|        |300      |233 |
|5 |     TABLE SCAN          |t2      |300      |233 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(t2.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1)), DECIMAL(20, 0))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c2))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c2))], [T_FUN_SUM(T_FUN_SUM(t2.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))])
  1 - output([T_FUN_COUNT(t2.c2)], [T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(t2.c2)], [T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t2.c2)], [T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t2.c2)], [T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)])
  4 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 430(end)  ************** 

***************   Case 431   ***************

SQL: select avg(distinct c1), count(c2) from t2 group by c1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |300      |317 |
|1 | EXCHANGE OUT DISTR    |:EX10000|300      |289 |
|2 |  PX PARTITION ITERATOR|        |300      |233 |
|3 |   TABLE SCAN          |t2      |300      |233 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(cast(t2.c1, DECIMAL(11, 0)) / cast(CASE WHEN (T_OP_IS_NOT, t2.c1, NULL, 0) THEN 1 ELSE 0 END, DECIMAL(20, 0)), CASE WHEN (T_OP_IS_NOT, t2.c2, NULL, 0) THEN 1 ELSE 0 END)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(cast(t2.c1, DECIMAL(11, 0)) / cast(CASE WHEN (T_OP_IS_NOT, t2.c1, NULL, 0) THEN 1 ELSE 0 END, DECIMAL(20, 0)), CASE WHEN (T_OP_IS_NOT, t2.c2, NULL, 0) THEN 1 ELSE 0 END)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 431(end)  ************** 

***************   Case 432   ***************

SQL: select count(distinct c1) from t2 group by c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |471 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |454 |
|2 |  HASH GROUP BY              |        |100      |419 |
|3 |   EXCHANGE IN DISTR         |        |100      |371 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|100      |358 |
|5 |     HASH GROUP BY           |        |100      |331 |
|6 |      PX PARTITION ITERATOR  |        |300      |233 |
|7 |       TABLE SCAN            |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1)))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))])
  3 - output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil)
  4 - (#keys=1, [t2.c2]), output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil), dop=1
  5 - output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT(t2.c1)])
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 432(end)  ************** 

***************   Case 433   ***************

SQL: select count(distinct c1, c2) from t2 group by c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |471 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |454 |
|2 |  HASH GROUP BY              |        |100      |419 |
|3 |   EXCHANGE IN DISTR         |        |100      |371 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|100      |358 |
|5 |     HASH GROUP BY           |        |100      |331 |
|6 |      PX PARTITION ITERATOR  |        |300      |233 |
|7 |       TABLE SCAN            |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1, t2.c2)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1, t2.c2)))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1, t2.c2))]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1, t2.c2))])
  3 - output([t2.c2], [T_FUN_COUNT(t2.c1, t2.c2)]), filter(nil)
  4 - (#keys=1, [t2.c2]), output([t2.c2], [T_FUN_COUNT(t2.c1, t2.c2)]), filter(nil), dop=1
  5 - output([t2.c2], [T_FUN_COUNT(t2.c1, t2.c2)]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT(t2.c1, t2.c2)])
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 433(end)  ************** 

***************   Case 434   ***************

SQL: select sum(distinct c1) from t7 group by c2; 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |10       |106 |
|1 | TABLE SCAN  |t7  |100      |78  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(t7.c1)]), filter(nil), 
      group([t7.c2]), agg_func([T_FUN_SUM(t7.c1)])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 434(end)  ************** 

***************   Case 435   ***************

SQL: select count(distinct c2) from t2; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |357 |
|1 | PX COORDINATOR          |        |100      |353 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|100      |344 |
|3 |   HASH GROUP BY         |        |100      |325 |
|4 |    PX PARTITION ITERATOR|        |300      |233 |
|5 |     TABLE SCAN          |t2      |300      |233 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(distinct t2.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(distinct t2.c2)])
  1 - output([t2.c2]), filter(nil)
  2 - output([t2.c2]), filter(nil), dop=1
  3 - output([t2.c2]), filter(nil), 
      group([t2.c2]), agg_func(nil)
  4 - output([t2.c2]), filter(nil), 
      force partition granule.
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 435(end)  ************** 

***************   Case 436   ***************

SQL: select sum(distinct c2) from t17; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |357 |
|1 | PX COORDINATOR          |        |100      |353 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|100      |344 |
|3 |   HASH GROUP BY         |        |100      |325 |
|4 |    PX PARTITION ITERATOR|        |300      |233 |
|5 |     TABLE SCAN          |t17     |300      |233 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(distinct t17.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(distinct t17.c2)])
  1 - output([t17.c2]), filter(nil)
  2 - output([t17.c2]), filter(nil), dop=1
  3 - output([t17.c2]), filter(nil), 
      group([t17.c2]), agg_func(nil)
  4 - output([t17.c2]), filter(nil), 
      force partition granule.
  5 - output([t17.c2]), filter(nil), 
      access([t17.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 436(end)  ************** 

***************   Case 437   ***************

SQL: select avg(distinct c1) from t1 group by c2; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |PX COORDINATOR                 |             |100      |576 |
|1 | EXCHANGE OUT DISTR            |:EX10001     |100      |550 |
|2 |  MERGE GROUP BY               |             |100      |492 |
|3 |   EXCHANGE IN MERGE SORT DISTR|             |100      |483 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |465 |
|5 |     PX PARTITION ITERATOR     |             |100      |427 |
|6 |      MERGE GROUP BY           |             |100      |427 |
|7 |       TABLE SCAN              |t1(idx_t1_c2)|500      |387 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(t1.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1)), DECIMAL(20, 0)))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  4 - (#keys=1, [t1.c2]), output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 437(end)  ************** 

***************   Case 438   ***************

SQL: select count(distinct c2) from t2 group by c2; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |532 |
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |519 |
|2 |  MERGE GROUP BY               |        |100      |491 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |100      |484 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|100      |475 |
|5 |     MERGE GROUP BY            |        |100      |456 |
|6 |      SORT                     |        |300      |442 |
|7 |       PX PARTITION ITERATOR   |        |300      |233 |
|8 |        TABLE SCAN             |t2      |300      |233 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT(distinct t2.c2))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT(distinct t2.c2))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT(distinct t2.c2)]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT(distinct t2.c2)])
  3 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  4 - (#keys=1, [t2.c2]), output([t2.c2]), filter(nil), dop=1
  5 - output([t2.c2]), filter(nil), 
      group([t2.c2], [t2.c2]), agg_func(nil)
  6 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC], [t2.c2, ASC])
  7 - output([t2.c2]), filter(nil), 
      force partition granule.
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 438(end)  ************** 

***************   Case 439   ***************

SQL: select count(distinct c1) from t2 group by c2; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |471 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |454 |
|2 |  HASH GROUP BY              |        |100      |419 |
|3 |   EXCHANGE IN DISTR         |        |100      |371 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|100      |358 |
|5 |     HASH GROUP BY           |        |100      |331 |
|6 |      PX PARTITION ITERATOR  |        |300      |233 |
|7 |       TABLE SCAN            |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1)))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))])
  3 - output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil)
  4 - (#keys=1, [t2.c2]), output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil), dop=1
  5 - output([T_FUN_COUNT(t2.c1)], [t2.c2]), filter(nil), 
      group([t2.c2]), agg_func([T_FUN_COUNT(t2.c1)])
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  7 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 439(end)  ************** 

***************   Case 440   ***************

SQL: select sum(distinct c2) from t15 group by c3; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |1178|
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |1149|
|2 |  MERGE GROUP BY               |        |100      |1085|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |400      |1059|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|400      |961 |
|5 |     MERGE GROUP BY            |        |400      |750 |
|6 |      SORT                     |        |400      |724 |
|7 |       PX PARTITION ITERATOR   |        |400      |310 |
|8 |        TABLE SCAN             |t15     |400      |310 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(distinct t15.c2))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(distinct t15.c2))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(distinct t15.c2)]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_SUM(distinct t15.c2)])
  3 - output([t15.c2], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC])
  4 - (#keys=1, [t15.c3, VARCHAR, 32]), output([t15.c2], [t15.c3]), filter(nil), dop=1
  5 - output([t15.c2], [t15.c3]), filter(nil), 
      group([t15.c3], [t15.c2]), agg_func(nil)
  6 - output([t15.c2], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC], [t15.c2, ASC])
  7 - output([t15.c2], [t15.c3]), filter(nil), 
      force partition granule.
  8 - output([t15.c2], [t15.c3]), filter(nil), 
      access([t15.c2], [t15.c3]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 440(end)  ************** 

***************   Case 441   ***************

SQL: select sum(distinct c1) from t15 group by c3; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |926 |
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |896 |
|2 |  MERGE GROUP BY               |        |100      |830 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |100      |822 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|100      |797 |
|5 |     PX PARTITION ITERATOR     |        |100      |742 |
|6 |      MERGE GROUP BY           |        |100      |742 |
|7 |       SORT                    |        |400      |716 |
|8 |        TABLE SCAN             |t15     |400      |310 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(distinct t15.c1)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(distinct t15.c1)))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(distinct t15.c1))]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_SUM(T_FUN_SUM(distinct t15.c1))])
  3 - output([T_FUN_SUM(distinct t15.c1)], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC]), Local Order
  4 - (#keys=1, [t15.c3, VARCHAR, 32]), output([T_FUN_SUM(distinct t15.c1)], [t15.c3]), filter(nil), dop=1
  5 - output([T_FUN_SUM(distinct t15.c1)], [t15.c3]), filter(nil), 
      partition wise, force partition granule.
  6 - output([T_FUN_SUM(distinct t15.c1)], [t15.c3]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_SUM(distinct t15.c1)])
  7 - output([t15.c1], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC])
  8 - output([t15.c1], [t15.c3]), filter(nil), 
      access([t15.c1], [t15.c3]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 441(end)  ************** 

***************   Case 442   ***************

SQL: select avg(distinct c2) from t15 group by c3; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |1197|
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |1164|
|2 |  MERGE GROUP BY               |        |100      |1092|
|3 |   EXCHANGE IN MERGE SORT DISTR|        |400      |1059|
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|400      |961 |
|5 |     MERGE GROUP BY            |        |400      |750 |
|6 |      SORT                     |        |400      |724 |
|7 |       PX PARTITION ITERATOR   |        |400      |310 |
|8 |        TABLE SCAN             |t15     |400      |310 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(distinct t15.c2) / cast(T_FUN_COUNT(distinct t15.c2), DECIMAL(20, 0)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(distinct t15.c2) / cast(T_FUN_COUNT(distinct t15.c2), DECIMAL(20, 0)))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(distinct t15.c2)], [T_FUN_COUNT(distinct t15.c2)]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_SUM(distinct t15.c2)], [T_FUN_COUNT(distinct t15.c2)])
  3 - output([t15.c2], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC])
  4 - (#keys=1, [t15.c3, VARCHAR, 32]), output([t15.c2], [t15.c3]), filter(nil), dop=1
  5 - output([t15.c2], [t15.c3]), filter(nil), 
      group([t15.c3], [t15.c2]), agg_func(nil)
  6 - output([t15.c2], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC], [t15.c2, ASC])
  7 - output([t15.c2], [t15.c3]), filter(nil), 
      force partition granule.
  8 - output([t15.c2], [t15.c3]), filter(nil), 
      access([t15.c2], [t15.c3]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 442(end)  ************** 

***************   Case 443   ***************

SQL: select avg(distinct c1) from t15 group by c3; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |972 |
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |935 |
|2 |  MERGE GROUP BY               |        |100      |852 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |100      |841 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|100      |812 |
|5 |     PX PARTITION ITERATOR     |        |100      |749 |
|6 |      MERGE GROUP BY           |        |100      |749 |
|7 |       SORT                    |        |400      |716 |
|8 |        TABLE SCAN             |t15     |400      |310 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(distinct t15.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(distinct t15.c1)), DECIMAL(20, 0)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(T_FUN_SUM(distinct t15.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(distinct t15.c1)), DECIMAL(20, 0)))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(T_FUN_SUM(distinct t15.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(distinct t15.c1))]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_SUM(T_FUN_SUM(distinct t15.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(distinct t15.c1))])
  3 - output([T_FUN_SUM(distinct t15.c1)], [T_FUN_COUNT(distinct t15.c1)], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC]), Local Order
  4 - (#keys=1, [t15.c3, VARCHAR, 32]), output([T_FUN_SUM(distinct t15.c1)], [T_FUN_COUNT(distinct t15.c1)], [t15.c3]), filter(nil), dop=1
  5 - output([T_FUN_SUM(distinct t15.c1)], [T_FUN_COUNT(distinct t15.c1)], [t15.c3]), filter(nil), 
      partition wise, force partition granule.
  6 - output([T_FUN_SUM(distinct t15.c1)], [T_FUN_COUNT(distinct t15.c1)], [t15.c3]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_SUM(distinct t15.c1)], [T_FUN_COUNT(distinct t15.c1)])
  7 - output([t15.c1], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC])
  8 - output([t15.c1], [t15.c3]), filter(nil), 
      access([t15.c1], [t15.c3]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 443(end)  ************** 

***************   Case 444   ***************

SQL: select count(distinct c1, c2) from t15 group by c3; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |944 |
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |911 |
|2 |  MERGE GROUP BY               |        |100      |842 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |100      |833 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|100      |805 |
|5 |     PX PARTITION ITERATOR     |        |100      |743 |
|6 |      MERGE GROUP BY           |        |100      |743 |
|7 |       SORT                    |        |400      |717 |
|8 |        TABLE SCAN             |t15     |400      |310 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(distinct t15.c1, t15.c2)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(distinct t15.c1, t15.c2)))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(distinct t15.c1, t15.c2))]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(distinct t15.c1, t15.c2))])
  3 - output([T_FUN_COUNT(distinct t15.c1, t15.c2)], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC]), Local Order
  4 - (#keys=1, [t15.c3, VARCHAR, 32]), output([T_FUN_COUNT(distinct t15.c1, t15.c2)], [t15.c3]), filter(nil), dop=1
  5 - output([T_FUN_COUNT(distinct t15.c1, t15.c2)], [t15.c3]), filter(nil), 
      partition wise, force partition granule.
  6 - output([T_FUN_COUNT(distinct t15.c1, t15.c2)], [t15.c3]), filter(nil), 
      group([t15.c3]), agg_func([T_FUN_COUNT(distinct t15.c1, t15.c2)])
  7 - output([t15.c1], [t15.c2], [t15.c3]), filter(nil), sort_keys([t15.c3, ASC])
  8 - output([t15.c1], [t15.c2], [t15.c3]), filter(nil), 
      access([t15.c1], [t15.c2], [t15.c3]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 444(end)  ************** 

***************   Case 445   ***************

SQL: select count(distinct c1, c2) from t17 group by c2; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |653 |
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |636 |
|2 |  MERGE GROUP BY               |        |100      |600 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |300      |581 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|300      |542 |
|5 |     MERGE GROUP BY            |        |300      |460 |
|6 |      SORT                     |        |300      |444 |
|7 |       PX PARTITION ITERATOR   |        |300      |233 |
|8 |        TABLE SCAN             |t17     |300      |233 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT(distinct t17.c1, t17.c2))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT(distinct t17.c1, t17.c2))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT(distinct t17.c1, t17.c2)]), filter(nil), 
      group([t17.c2]), agg_func([T_FUN_COUNT(distinct t17.c1, t17.c2)])
  3 - output([t17.c2], [t17.c1]), filter(nil), sort_keys([t17.c2, ASC])
  4 - (#keys=1, [t17.c2]), output([t17.c2], [t17.c1]), filter(nil), dop=1
  5 - output([t17.c2], [t17.c1]), filter(nil), 
      group([t17.c2], [t17.c1], [t17.c2]), agg_func(nil)
  6 - output([t17.c2], [t17.c1]), filter(nil), sort_keys([t17.c2, ASC], [t17.c1, ASC], [t17.c2, ASC])
  7 - output([t17.c1], [t17.c2]), filter(nil), 
      force partition granule.
  8 - output([t17.c1], [t17.c2]), filter(nil), 
      access([t17.c1], [t17.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 445(end)  ************** 

***************   Case 446   ***************

SQL: select sum(distinct c1) from t17 group by c2; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |655 |
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |638 |
|2 |  MERGE GROUP BY               |        |100      |600 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |300      |580 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|300      |541 |
|5 |     MERGE GROUP BY            |        |300      |459 |
|6 |      SORT                     |        |300      |443 |
|7 |       PX PARTITION ITERATOR   |        |300      |233 |
|8 |        TABLE SCAN             |t17     |300      |233 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_SUM(distinct t17.c1))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_SUM(distinct t17.c1))]), filter(nil), dop=1
  2 - output([T_FUN_SUM(distinct t17.c1)]), filter(nil), 
      group([t17.c2]), agg_func([T_FUN_SUM(distinct t17.c1)])
  3 - output([t17.c1], [t17.c2]), filter(nil), sort_keys([t17.c2, ASC])
  4 - (#keys=1, [t17.c2]), output([t17.c1], [t17.c2]), filter(nil), dop=1
  5 - output([t17.c1], [t17.c2]), filter(nil), 
      group([t17.c2], [t17.c1]), agg_func(nil)
  6 - output([t17.c1], [t17.c2]), filter(nil), sort_keys([t17.c2, ASC], [t17.c1, ASC])
  7 - output([t17.c1], [t17.c2]), filter(nil), 
      force partition granule.
  8 - output([t17.c1], [t17.c2]), filter(nil), 
      access([t17.c1], [t17.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 446(end)  ************** 

***************   Case 447   ***************

SQL: select/*+index(t5 idx_t5_c3)*/ t3.c2 from t5, t3; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|             |60000    |5625|
|1 | PX COORDINATOR           |             |200      |187 |
|2 |  EXCHANGE OUT DISTR      |:EX10000     |200      |176 |
|3 |   PX PARTITION ITERATOR  |             |200      |155 |
|4 |    TABLE SCAN            |t3           |200      |155 |
|5 | MATERIAL                 |             |300      |281 |
|6 |  PX COORDINATOR          |             |300      |280 |
|7 |   EXCHANGE OUT DISTR     |:EX20000     |300      |263 |
|8 |    PX PARTITION ITERATOR |             |300      |233 |
|9 |     TABLE SCAN           |t5(idx_t5_c3)|300      |233 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t3.c2]), filter(nil)
  2 - output([t3.c2]), filter(nil), dop=1
  3 - output([t3.c2]), filter(nil), 
      force partition granule.
  4 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output(nil), filter(nil)
  6 - output(nil), filter(nil)
  7 - output(nil), filter(nil), dop=1
  8 - output(nil), filter(nil), 
      force partition granule.
  9 - output(nil), filter(nil), 
      access([t5.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t5.c3], [t5.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 447(end)  ************** 

***************   Case 448   ***************

SQL: SELECT * FROM (SELECT c1, c2 FROM t1 GROUP BY c1) v1 JOIN (SELECT c1, c2 FROM t2 WHERE c2 IN (2,3)) v2 ON v1.c1=v2.c1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |6        |280 |
|1 | EXCHANGE OUT DISTR          |:EX10001|6        |279 |
|2 |  NESTED-LOOP JOIN           |        |6        |278 |
|3 |   EXCHANGE IN DISTR         |        |6        |242 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|6        |241 |
|5 |     PX PARTITION ITERATOR   |        |6        |240 |
|6 |      TABLE SCAN             |t2      |6        |240 |
|7 |   PX PARTITION ITERATOR     |        |1        |29  |
|8 |    TABLE GET                |t1      |1        |29  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2)]), filter(nil), dop=1
  2 - output([t2.c1], [t2.c2], [t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1]), batch_join=false
  3 - output([t2.c1], [PARTITION_ID], [t2.c2]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1], [PARTITION_ID], [t2.c2]), filter(nil), dop=1
  5 - output([t2.c1], [t2.c2]), filter(nil), 
      force partition granule.
  6 - output([t2.c1], [t2.c2]), filter([t2.c2 IN (?, ?)]), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([t1.c1 = ?])

*************** Case 448(end)  ************** 

***************   Case 449   ***************

SQL: SELECT  GRANDPARENT1 . col_varchar_10 AS G1 FROM CC AS GRANDPARENT1 LEFT JOIN CC AS GRANDPARENT2 USING ( col_varchar_10 ) WHERE GRANDPARENT1 . `col_varchar_10` IN ( SELECT  PARENT1 . `col_varchar_20` AS P1 FROM CC AS PARENT1 WHERE ( ( PARENT1 . `col_varchar_10` > PARENT1 . `col_varchar_20` ) OR NOT ( GRANDPARENT1 . `col_int_key` = 4 OR NOT GRANDPARENT1 . `col_int_key` > 2 ) ) ORDER BY PARENT1 . col_varchar_10 ) AND ( GRANDPARENT1 . col_varchar_10 IS NULL OR GRANDPARENT1 . `col_int_key` >= 3 ); 

======================================================
|ID|OPERATOR             |NAME        |EST. ROWS|COST|
------------------------------------------------------
|0 |HASH RIGHT OUTER JOIN|            |62       |403 |
|1 | TABLE SCAN          |GRANDPARENT2|100      |78  |
|2 | HASH SEMI JOIN      |            |61       |257 |
|3 |  TABLE SCAN         |GRANDPARENT1|87       |80  |
|4 |  TABLE SCAN         |PARENT1     |100      |78  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([GRANDPARENT1.col_varchar_10]), filter(nil), 
      equal_conds([GRANDPARENT1.col_varchar_10 = GRANDPARENT2.col_varchar_10]), other_conds(nil)
  1 - output([GRANDPARENT2.col_varchar_10]), filter(nil), 
      access([GRANDPARENT2.col_varchar_10]), partitions(p0), 
      is_index_back=false, 
      range_key([GRANDPARENT2.__pk_increment], [GRANDPARENT2.__pk_cluster_id], [GRANDPARENT2.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([GRANDPARENT1.col_varchar_10]), filter(nil), 
      equal_conds([GRANDPARENT1.col_varchar_10 = PARENT1.col_varchar_20]), other_conds([PARENT1.col_varchar_10 > PARENT1.col_varchar_20 OR GRANDPARENT1.col_int_key != ? AND GRANDPARENT1.col_int_key > ?])
  3 - output([GRANDPARENT1.col_varchar_10], [GRANDPARENT1.col_int_key]), filter([(T_OP_IS, GRANDPARENT1.col_varchar_10, NULL, 0) OR GRANDPARENT1.col_int_key >= ?]), 
      access([GRANDPARENT1.col_varchar_10], [GRANDPARENT1.col_int_key]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([GRANDPARENT1.__pk_increment], [GRANDPARENT1.__pk_cluster_id], [GRANDPARENT1.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  4 - output([PARENT1.col_varchar_10], [PARENT1.col_varchar_20]), filter(nil), 
      access([PARENT1.col_varchar_10], [PARENT1.col_varchar_20]), partitions(p0), 
      is_index_back=false, 
      range_key([PARENT1.__pk_increment], [PARENT1.__pk_cluster_id], [PARENT1.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 449(end)  ************** 

***************   Case 450   ***************

SQL: SELECT * FROM sbtest WHERE c1=1; 

====================================
|ID|OPERATOR |NAME  |EST. ROWS|COST|
------------------------------------
|0 |TABLE GET|sbtest|1        |46  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([sbtest.c1], [sbtest.c2]), filter(nil), 
      access([sbtest.c1], [sbtest.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([sbtest.c1]), range[1 ; 1], 
      range_cond([sbtest.c1 = ?])

*************** Case 450(end)  ************** 

***************   Case 451   ***************

SQL: select * from (select t1.c1 from t1 left join t2 as b on b.c1 = effective_tenant_id() where t1.c1 = effective_tenant_id()) as yyy; 

===========================================================
|ID|OPERATOR                          |NAME|EST. ROWS|COST|
-----------------------------------------------------------
|0 |EXCHANGE IN REMOTE                |    |1        |93  |
|1 | EXCHANGE OUT REMOTE              |    |1        |93  |
|2 |  NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |92  |
|3 |   TABLE GET                      |t1  |1        |46  |
|4 |   TABLE GET                      |b   |1        |46  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(?, INT(11, 0))]), filter(nil)
  1 - output([cast(?, INT(11, 0))]), filter(nil)
  2 - output([cast(?, INT(11, 0))]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output(nil), filter(nil), 
      access([b.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([b.c1]), range[1 ; 1], 
      range_cond([b.c1 = ?])

*************** Case 451(end)  ************** 

***************   Case 452   ***************

SQL: select * from (select t1.c1 from t1 left join t2 as b on b.c1 = 5 where t1.c1 = 5) as yyy; 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN|        |1        |141 |
|1 | TABLE GET                      |t1      |1        |46  |
|2 | PX COORDINATOR                 |        |1        |46  |
|3 |  EXCHANGE OUT DISTR            |:EX10000|1        |46  |
|4 |   TABLE GET                    |b       |1        |46  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([cast(?, INT(11, 0))]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), is_single, dop=1
  4 - output(nil), filter(nil), 
      access([b.c1]), partitions(p2), 
      is_index_back=false, 
      range_key([b.c1]), range[5 ; 5], 
      range_cond([b.c1 = ?])

*************** Case 452(end)  ************** 

***************   Case 453   ***************

SQL: select * from t1, t2 order by t1.c1 limit 10; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |LIMIT                         |        |10       |377 |
|1 | NESTED-LOOP JOIN CARTESIAN   |        |10       |377 |
|2 |  SUBPLAN SCAN                |VIEW1   |1        |230 |
|3 |   LIMIT                      |        |1        |230 |
|4 |    PX COORDINATOR MERGE SORT |        |1        |230 |
|5 |     EXCHANGE OUT DISTR       |:EX10000|1        |230 |
|6 |      TOP-N SORT              |        |1        |230 |
|7 |       PX PARTITION ITERATOR  |        |10       |227 |
|8 |        TABLE SCAN            |t1      |10       |227 |
|9 |  MATERIAL                    |        |10       |145 |
|10|   SUBPLAN SCAN               |VIEW2   |10       |145 |
|11|    LIMIT                     |        |10       |145 |
|12|     PX COORDINATOR           |        |10       |145 |
|13|      EXCHANGE OUT DISTR      |:EX20000|10       |142 |
|14|       LIMIT                  |        |10       |137 |
|15|        PX PARTITION ITERATOR |        |10       |137 |
|16|         TABLE SCAN           |t2      |10       |137 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW2.t2.c1], [VIEW2.t2.c2], [VIEW2.t2.c3]), filter(nil), limit(10), offset(nil)
  1 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW2.t2.c1], [VIEW2.t2.c2], [VIEW2.t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.t1.c1], [VIEW1.t1.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2])
  3 - output([t1.c1], [t1.c2]), filter(nil), limit(10), offset(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), topn(10), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([VIEW2.t2.c1], [VIEW2.t2.c2], [VIEW2.t2.c3]), filter(nil)
  10 - output([VIEW2.t2.c1], [VIEW2.t2.c2], [VIEW2.t2.c3]), filter(nil), 
      access([VIEW2.t2.c1], [VIEW2.t2.c2], [VIEW2.t2.c3])
  11 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), limit(10), offset(nil)
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  14 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), limit(10), offset(nil)
  15 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  16 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 453(end)  ************** 

***************   Case 454   ***************

SQL: select * from t1, t7 order by t1.c1 limit 10; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |LIMIT                         |        |10       |278 |
|1 | NESTED-LOOP JOIN CARTESIAN   |        |10       |278 |
|2 |  SUBPLAN SCAN                |VIEW1   |1        |230 |
|3 |   LIMIT                      |        |1        |230 |
|4 |    PX COORDINATOR MERGE SORT |        |1        |230 |
|5 |     EXCHANGE OUT DISTR       |:EX10000|1        |230 |
|6 |      TOP-N SORT              |        |1        |230 |
|7 |       PX PARTITION ITERATOR  |        |10       |227 |
|8 |        TABLE SCAN            |t1      |10       |227 |
|9 |  MATERIAL                    |        |10       |46  |
|10|   SUBPLAN SCAN               |VIEW2   |10       |46  |
|11|    TABLE SCAN                |t7      |10       |46  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW2.t7.c1], [VIEW2.t7.c2]), filter(nil), limit(10), offset(nil)
  1 - output([VIEW1.t1.c1], [VIEW1.t1.c2], [VIEW2.t7.c1], [VIEW2.t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.t1.c1], [VIEW1.t1.c2]), filter(nil), 
      access([VIEW1.t1.c1], [VIEW1.t1.c2])
  3 - output([t1.c1], [t1.c2]), filter(nil), limit(10), offset(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  5 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), topn(10), local merge sort
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  9 - output([VIEW2.t7.c1], [VIEW2.t7.c2]), filter(nil)
  10 - output([VIEW2.t7.c1], [VIEW2.t7.c2]), filter(nil), 
      access([VIEW2.t7.c1], [VIEW2.t7.c2])
  11 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 454(end)  ************** 

***************   Case 455   ***************

SQL: select * from (select * from t1 group by c1) as a join (select * from t1 group by c1) as b on a.c1 = b.c1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 455(end)  ************** 

***************   Case 456   ***************

SQL: select * from (select c1 as a1 from t1 group by c1) as a join (select c1 as b1 from t1 group by c1) as b on a.a1 = b.b1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 456(end)  ************** 

***************   Case 457   ***************

SQL: select a2, b1 from (select c1 as a1, c1 as a2 from t1 group by c1) as a join (select c1 as b1 from t1 group by c1) as b on a.a2 = b.b1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), 
      force partition granule.
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 457(end)  ************** 

***************   Case 458   ***************

SQL: select a2, b1 from (select c1 as a1, c2 as a2 from t1 group by c1) as a join (select c1 as b1 from t1 group by c1) as b on a.a2 = b.b1; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |PX COORDINATOR               |             |450      |1220|
|1 | EXCHANGE OUT DISTR          |:EX10001     |450      |1178|
|2 |  HASH JOIN                  |             |450      |1093|
|3 |   EXCHANGE IN DISTR         |             |500      |466 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000     |500      |439 |
|5 |     PX PARTITION ITERATOR   |             |500      |387 |
|6 |      TABLE SCAN             |t1(idx_t1_c2)|500      |387 |
|7 |   PX PARTITION ITERATOR     |             |500      |387 |
|8 |    TABLE SCAN               |t1           |500      |387 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2, t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2, t1.c1)]), filter(nil), dop=1
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      equal_conds([t1.c2 = t1.c1]), other_conds(nil)
  3 - output([t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  7 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 458(end)  ************** 

***************   Case 459   ***************

SQL: select * from (select c2 from t1 group by c2) as a join (select c1 as b1 from t1 group by c1) as b on a.c2 = b.b1; 

=====================================================================
|ID|OPERATOR                           |NAME         |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |PX COORDINATOR                     |             |100      |1018|
|1 | EXCHANGE OUT DISTR                |:EX10002     |100      |1009|
|2 |  HASH JOIN                        |             |100      |990 |
|3 |   EXCHANGE IN DISTR               |             |100      |460 |
|4 |    EXCHANGE OUT DISTR (PKEY)      |:EX10001     |100      |454 |
|5 |     SUBPLAN SCAN                  |a            |100      |444 |
|6 |      MERGE GROUP BY               |             |100      |442 |
|7 |       EXCHANGE IN MERGE SORT DISTR|             |100      |437 |
|8 |        EXCHANGE OUT DISTR (HASH)  |:EX10000     |100      |428 |
|9 |         PX PARTITION ITERATOR     |             |100      |409 |
|10|          MERGE GROUP BY           |             |100      |409 |
|11|           TABLE SCAN              |t1(idx_t1_c2)|500      |387 |
|12|   PX PARTITION ITERATOR           |             |500      |387 |
|13|    TABLE SCAN                     |t1           |500      |387 |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(a.c2, t1.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(a.c2, t1.c1)]), filter(nil), dop=1
  2 - output([a.c2], [t1.c1]), filter(nil), 
      equal_conds([a.c2 = t1.c1]), other_conds(nil)
  3 - output([a.c2]), filter(nil)
  4 - (#keys=1, [a.c2]), output([a.c2]), filter(nil), dop=1
  5 - output([a.c2]), filter(nil), 
      access([a.c2])
  6 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  7 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), Local Order
  8 - (#keys=1, [t1.c2]), output([t1.c2]), filter(nil), dop=1
  9 - output([t1.c2]), filter(nil), 
      force partition granule.
  10 - output([t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  11 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  12 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 459(end)  ************** 

***************   Case 460   ***************

SQL: SELECT * FROM sbtest1 WHERE (c1, c2)=(1, NULL); 

======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|sbtest1|100      |78  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([sbtest1.c1], [sbtest1.c2]), filter(nil), startup_filter([0]), 
      access([sbtest1.c1], [sbtest1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([sbtest1.c1]), range(MIN ; MAX)always true

*************** Case 460(end)  ************** 

***************   Case 461   ***************

SQL: select * from t1 where c1 = 65535; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t1  |1        |46  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[65535 ; 65535], 
      range_cond([t1.c1 = ?])

*************** Case 461(end)  ************** 

***************   Case 462   ***************

SQL: select t6.c1, t6.c2, t6_1.c1, t6_1.c2 from t6 left join t6_1 using (c1) order by t6.c2 desc; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |300      |929 |
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |878 |
|2 |  SORT                        |        |300      |771 |
|3 |   HASH RIGHT OUTER JOIN      |        |300      |564 |
|4 |    EXCHANGE IN DISTR         |        |200      |211 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |193 |
|6 |      PX PARTITION ITERATOR   |        |200      |155 |
|7 |       TABLE SCAN             |t6_1    |200      |155 |
|8 |    PX PARTITION ITERATOR     |        |300      |233 |
|9 |     TABLE SCAN               |t6      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t6.c1, t6.c2, t6_1.c1, t6_1.c2)]), filter(nil), sort_keys([t6.c2, DESC])
  1 - output([t6.c2], [INTERNAL_FUNCTION(t6.c1, t6.c2, t6_1.c1, t6_1.c2)]), filter(nil), dop=1
  2 - output([t6.c2], [t6.c1], [t6_1.c1], [t6_1.c2]), filter(nil), sort_keys([t6.c2, DESC])
  3 - output([t6.c2], [t6.c1], [t6_1.c1], [t6_1.c2]), filter(nil), 
      equal_conds([t6.c1 = t6_1.c1]), other_conds(nil)
  4 - output([t6_1.c1], [t6_1.c2]), filter(nil)
  5 - (#keys=1, [t6_1.c1]), output([t6_1.c1], [t6_1.c2]), filter(nil), dop=1
  6 - output([t6_1.c1], [t6_1.c2]), filter(nil), 
      force partition granule.
  7 - output([t6_1.c1], [t6_1.c2]), filter(nil), 
      access([t6_1.c1], [t6_1.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t6_1.c1]), range(MIN ; MAX)always true
  8 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 462(end)  ************** 

***************   Case 463   ***************

SQL: select t6.c1, t6.c2, t6_1.c1, t6_1.c2 from t6 left join t6_1 using (c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |722 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |672 |
|2 |  HASH RIGHT OUTER JOIN      |        |300      |564 |
|3 |   EXCHANGE IN DISTR         |        |200      |211 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |193 |
|5 |     PX PARTITION ITERATOR   |        |200      |155 |
|6 |      TABLE SCAN             |t6_1    |200      |155 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t6      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t6.c1, t6.c2, t6_1.c1, t6_1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t6.c1, t6.c2, t6_1.c1, t6_1.c2)]), filter(nil), dop=1
  2 - output([t6.c1], [t6_1.c1], [t6_1.c2], [t6.c2]), filter(nil), 
      equal_conds([t6.c1 = t6_1.c1]), other_conds(nil)
  3 - output([t6_1.c1], [t6_1.c2]), filter(nil)
  4 - (#keys=1, [t6_1.c1]), output([t6_1.c1], [t6_1.c2]), filter(nil), dop=1
  5 - output([t6_1.c1], [t6_1.c2]), filter(nil), 
      force partition granule.
  6 - output([t6_1.c1], [t6_1.c2]), filter(nil), 
      access([t6_1.c1], [t6_1.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t6_1.c1]), range(MIN ; MAX)always true
  7 - output([t6.c1], [t6.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t6.c1], [t6.c2]), filter(nil), 
      access([t6.c1], [t6.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t6.c1]), range(MIN ; MAX)always true

*************** Case 463(end)  ************** 

***************   Case 464   ***************

SQL: select * from t1 where (0 = 1) or c1 = 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 464(end)  ************** 

***************   Case 465   ***************

SQL: select * from t1 where (1 = 1) or c1 = 1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 465(end)  ************** 

***************   Case 466   ***************

SQL: select * from t1 where 0 or c1 = 1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 466(end)  ************** 

***************   Case 467   ***************

SQL: select * from t1 where 1 or c1 = 1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 467(end)  ************** 

***************   Case 468   ***************

SQL: select * from t1 join t2 on (1 =1 or t1.c1 = t2.c1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |150000   |8729|
|1 | PX COORDINATOR           |        |300      |464 |
|2 |  EXCHANGE OUT DISTR      |:EX10000|300      |391 |
|3 |   PX PARTITION ITERATOR  |        |300      |233 |
|4 |    TABLE SCAN            |t2      |300      |233 |
|5 | MATERIAL                 |        |500      |531 |
|6 |  PX COORDINATOR          |        |500      |528 |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500      |481 |
|8 |    PX PARTITION ITERATOR |        |500      |387 |
|9 |     TABLE SCAN           |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 468(end)  ************** 

***************   Case 469   ***************

SQL: select * from t1 left join t2 on (1 = 0 or t1.c1 = t2.c1) left join t3 on (1=2 and t2.c1 = t3.c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |500      |1464|
|1 | EXCHANGE OUT DISTR          |:EX10001|500      |1304|
|2 |  HASH OUTER JOIN            |        |500      |954 |
|3 |   EXCHANGE IN DISTR         |        |500      |528 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|500      |481 |
|5 |     PX PARTITION ITERATOR   |        |500      |387 |
|6 |      TABLE SCAN             |t1      |500      |387 |
|7 |   PX PARTITION ITERATOR     |        |300      |233 |
|8 |    TABLE SCAN               |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, ?, ?, ?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, ?, ?, ?)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 469(end)  ************** 

***************   Case 470   ***************

SQL: select * from t1 left join t2 on (1 = 0 or t1.c1 = t2.c1) left join t3 on (1=2 or t2.c1 = t3.c1); 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |500      |2578|
|1 | EXCHANGE OUT DISTR             |:EX10002|500      |2305|
|2 |  HASH OUTER JOIN               |        |500      |1700|
|3 |   PX PARTITION ITERATOR        |        |500      |387 |
|4 |    TABLE SCAN                  |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR            |        |300      |1119|
|6 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|300      |977 |
|7 |     HASH RIGHT OUTER JOIN      |        |300      |665 |
|8 |      EXCHANGE IN DISTR         |        |200      |310 |
|9 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |261 |
|10|        PX PARTITION ITERATOR   |        |200      |155 |
|11|         TABLE SCAN             |t3      |200      |155 |
|12|      PX PARTITION ITERATOR     |        |300      |233 |
|13|       TABLE SCAN               |t2      |300      |233 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3, t3.c1, t3.c2, t3.c3)]), filter(nil), dop=1
  2 - output([t1.c1], [t2.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1], [t3.c1], [t3.c2], [t3.c3], [t2.c2], [t2.c3]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1], [t3.c1], [t3.c2], [t3.c3], [t2.c2], [t2.c3]), filter(nil), dop=1
  7 - output([t2.c1], [t3.c1], [t3.c2], [t3.c3], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  9 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  10 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  11 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 470(end)  ************** 

***************   Case 471   ***************

SQL: select c1, c2 from t1 group by c1 having (1 = 0 or c1 > 5); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |375      |339 |
|1 | EXCHANGE OUT DISTR    |:EX10000|375      |304 |
|2 |  PX PARTITION ITERATOR|        |375      |234 |
|3 |   TABLE SCAN          |t1      |375      |234 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(5 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 471(end)  ************** 

***************   Case 472   ***************

SQL: select * from t1 where c1 in (select c1 from t2 where (1 = 0 or c1 > 5)); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |225      |644 |
|1 | EXCHANGE OUT DISTR          |:EX10001|225      |615 |
|2 |  HASH JOIN                  |        |225      |553 |
|3 |   EXCHANGE IN DISTR         |        |225      |176 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|225      |164 |
|5 |     PX PARTITION ITERATOR   |        |225      |141 |
|6 |      TABLE SCAN             |t2      |225      |141 |
|7 |   PX PARTITION ITERATOR     |        |375      |234 |
|8 |    TABLE SCAN               |t1      |375      |234 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(5 ; MAX), 
      range_cond([t2.c1 > ?])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(5 ; MAX), 
      range_cond([t1.c1 > ?])

*************** Case 472(end)  ************** 

***************   Case 473   ***************

SQL: select * from t7,t8 where  concat(t7.c2, t8.c2) > 1; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |3334     |1503|
|1 | TABLE SCAN     |t7  |100      |78  |
|2 | MATERIAL       |    |100      |79  |
|3 |  TABLE SCAN    |t8  |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds([cast(concat(cast(t7.c2, VARCHAR(1048576)), cast(t8.c2, VARCHAR(1048576))), DECIMAL(-1, -1)) > ?]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil)
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 473(end)  ************** 

***************   Case 474   ***************

SQL: select exists(select 1) + 1; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |1   |
|1 | EXPRESSION   |    |1        |1   |
|2 | LIMIT        |    |1        |1   |
|3 |  EXPRESSION  |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1)) + ?]), init_plan_idxs_(nil)
  1 - output([1]), filter(nil)
      values({1})
  2 - output([?]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil)
      values({1})

*************** Case 474(end)  ************** 

***************   Case 475   ***************

SQL: select exists(select 1) + c1 from t7; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |80  |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | LIMIT        |    |1        |1   |
|3 |  EXPRESSION  |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([? + t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil)
      values({1})

*************** Case 475(end)  ************** 

***************   Case 476   ***************

SQL: select ( select max(c1) from t7 ) = (select min(c1) from t8) from t9; 

===========================================================
|ID|OPERATOR                   |NAME       |EST. ROWS|COST|
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |           |100      |193 |
|1 | NESTED-LOOP JOIN CARTESIAN|           |1        |92  |
|2 |  SUBPLAN SCAN             |VIEW1      |1        |46  |
|3 |   SCALAR GROUP BY         |           |1        |46  |
|4 |    SUBPLAN SCAN           |VIEW3      |1        |46  |
|5 |     TABLE SCAN            |t7(Reverse)|1        |46  |
|6 |  SUBPLAN SCAN             |VIEW2      |1        |46  |
|7 |   SCALAR GROUP BY         |           |1        |46  |
|8 |    SUBPLAN SCAN           |VIEW4      |1        |46  |
|9 |     TABLE SCAN            |t8         |1        |46  |
|10| TABLE SCAN                |t9         |100      |78  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([VIEW1.max(c1) = VIEW2.min(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([VIEW1.max(c1)], [VIEW2.min(c1)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.max(c1)]), filter(nil), 
      access([VIEW1.max(c1)])
  3 - output([T_FUN_MAX(VIEW3.t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW3.t7.c1)])
  4 - output([VIEW3.t7.c1]), filter(nil), 
      access([VIEW3.t7.c1])
  5 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  6 - output([VIEW2.min(c1)]), filter(nil), 
      access([VIEW2.min(c1)])
  7 - output([T_FUN_MIN(VIEW4.t8.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW4.t8.c1)])
  8 - output([VIEW4.t8.c1]), filter(nil), 
      access([VIEW4.t8.c1])
  9 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  10 - output(nil), filter(nil), 
      access([t9.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 476(end)  ************** 

***************   Case 477   ***************

SQL: select 1 in (select c1 from t7) from t8; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |157 |
|1 | TABLE SCAN   |t8  |100      |78  |
|2 | TABLE SCAN   |t7  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? = ANY(subquery(1))]), init_plan_idxs_(nil)
  1 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 477(end)  ************** 

***************   Case 478   ***************

SQL: select c1 in (select c1 from t7) from t8; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |704 |
|1 | TABLE SCAN   |t8  |100      |78  |
|2 | TABLE SCAN   |t7  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t8.c1 = ANY(subquery(1))]), filter(nil), 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 478(end)  ************** 

***************   Case 479   ***************

SQL: select abs((select sum(c1) from t7)) > round((select sum(c1) from t7)) from t8; 

==========================================================
|ID|OPERATOR                 |NAME        |EST. ROWS|COST|
----------------------------------------------------------
|0 |TEMP TABLE TRANSFORMATION|            |100      |162 |
|1 | TEMP TABLE INSERT       |TEMP1       |1        |81  |
|2 |  SCALAR GROUP BY        |            |1        |81  |
|3 |   TABLE SCAN            |t7          |100      |78  |
|4 | SUBPLAN FILTER          |            |100      |80  |
|5 |  TABLE SCAN             |t8          |100      |78  |
|6 |  TEMP TABLE ACCESS      |VIEW1(TEMP1)|1        |1   |
|7 |  TEMP TABLE ACCESS      |VIEW2(TEMP1)|1        |1   |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output(nil), filter(nil)
  2 - output([T_FUN_SUM(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t7.c1)])
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([abs(subquery(1)) > round(subquery(2))]), init_plan_idxs_(nil)
  5 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([VIEW1.T_FUN_SUM(t7.c1)]), filter(nil), 
      access([VIEW1.T_FUN_SUM(t7.c1)])
  7 - output([VIEW2.T_FUN_SUM(t7.c1)]), filter(nil), 
      access([VIEW2.T_FUN_SUM(t7.c1)])

*************** Case 479(end)  ************** 

***************   Case 480   ***************

SQL: select abs((select sum(c1) from t7)) > round((select sum(c1) from t7)) from t8 left outer join t9 using(c1); 

==========================================================
|ID|OPERATOR                 |NAME        |EST. ROWS|COST|
----------------------------------------------------------
|0 |TEMP TABLE TRANSFORMATION|            |100      |162 |
|1 | TEMP TABLE INSERT       |TEMP1       |1        |81  |
|2 |  SCALAR GROUP BY        |            |1        |81  |
|3 |   TABLE SCAN            |t7          |100      |78  |
|4 | SUBPLAN FILTER          |            |100      |80  |
|5 |  TABLE SCAN             |t8          |100      |78  |
|6 |  TEMP TABLE ACCESS      |VIEW1(TEMP1)|1        |1   |
|7 |  TEMP TABLE ACCESS      |VIEW2(TEMP1)|1        |1   |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
  1 - output(nil), filter(nil)
  2 - output([T_FUN_SUM(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t7.c1)])
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([abs(subquery(1)) > round(subquery(2))]), init_plan_idxs_(nil)
  5 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([VIEW1.T_FUN_SUM(t7.c1)]), filter(nil), 
      access([VIEW1.T_FUN_SUM(t7.c1)])
  7 - output([VIEW2.T_FUN_SUM(t7.c1)]), filter(nil), 
      access([VIEW2.T_FUN_SUM(t7.c1)])

*************** Case 480(end)  ************** 

***************   Case 481   ***************

SQL: select ((select 1) < c1) + ((select 5) > c1) from t7; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([? < t7.c1 + ? > t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 481(end)  ************** 

***************   Case 482   ***************

SQL: select * from t7 where ((select 1) < c1) + ((select 5) > c1); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |50       |80  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([? < t7.c1 + ? > t7.c1]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 482(end)  ************** 

***************   Case 483   ***************

SQL: select * from t7 having ((select 1) < c1) + ((select 5) > c1); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |50       |80  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([? < t7.c1 + ? > t7.c1]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 483(end)  ************** 

***************   Case 484   ***************

SQL: select * from t7 having ((select 1) < sum(c1)) + ((select 5) > sum(c1)); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |81  |
|1 | TABLE SCAN    |t7  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([? < T_FUN_SUM(t7.c1) + ? > T_FUN_SUM(t7.c1)]), 
      group(nil), agg_func([T_FUN_SUM(t7.c1)])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 484(end)  ************** 

***************   Case 485   ***************

SQL: select * from t7 where 1 in (select c1 from t9 having (select count(1) from t7) > 0) having (select max(c1) from t8) > 1; 

============================================================
|ID|OPERATOR                    |NAME       |EST. ROWS|COST|
------------------------------------------------------------
|0 |SUBPLAN FILTER              |           |5        |99  |
|1 | NESTED-LOOP JOIN CARTESIAN |           |5        |53  |
|2 |  NESTED-LOOP JOIN CARTESIAN|           |1        |48  |
|3 |   SUBPLAN SCAN             |VIEW2      |1        |46  |
|4 |    SCALAR GROUP BY         |           |1        |46  |
|5 |     SUBPLAN SCAN           |VIEW3      |1        |46  |
|6 |      TABLE SCAN            |t8(Reverse)|1        |46  |
|7 |   TABLE GET                |t9         |1        |46  |
|8 |  TABLE SCAN                |t7         |100      |78  |
|9 | TABLE SCAN                 |t7         |1        |46  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output(nil), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output(nil), filter(nil), 
      access(nil)
  4 - output([T_FUN_MAX(VIEW3.t8.c1)]), filter([T_FUN_MAX(VIEW3.t8.c1) > ?]), 
      group(nil), agg_func([T_FUN_MAX(VIEW3.t8.c1)])
  5 - output([VIEW3.t8.c1]), filter(nil), 
      access([VIEW3.t8.c1])
  6 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  7 - output(nil), filter(nil), 
      access([t9.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range[1 ; 1], 
      range_cond([t9.c1 = ?])
  8 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  9 - output([1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 485(end)  ************** 

***************   Case 486   ***************

SQL: select * from t7 having count(*) > (select 1); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |81  |
|1 | TABLE SCAN    |t7  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([T_FUN_COUNT(*) > ?]), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 486(end)  ************** 

***************   Case 487   ***************

SQL: select * from t7 having count(*) > (select c1 from t8 limit 1); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |127 |
|1 | SCALAR GROUP BY|    |1        |81  |
|2 |  TABLE SCAN    |t7  |100      |78  |
|3 | TABLE SCAN     |t8  |1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([T_FUN_COUNT(*) > ?]), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 487(end)  ************** 

***************   Case 488   ***************

SQL: select * from t7 having count(*) > (select c1 from t8 where t7.c1=t8.c1); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |127 |
|1 | SCALAR GROUP BY|    |1        |81  |
|2 |  TABLE SCAN    |t7  |100      |78  |
|3 | TABLE GET      |t8  |1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([T_FUN_COUNT(*) > subquery(1)]), 
      exec_params_([t7.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true, 
      range_cond([? = t8.c1])

*************** Case 488(end)  ************** 

***************   Case 489   ***************

SQL: select *, (select 9) > count(*) FROM t7; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |81  |
|1 | TABLE SCAN    |t7  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [? > T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 489(end)  ************** 

***************   Case 490   ***************

SQL: select *, (select 9) > count(*) FROM t7  HAVING count(*) > (SELECT 5); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |81  |
|1 | TABLE SCAN    |t7  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [? > T_FUN_COUNT(*)]), filter([T_FUN_COUNT(*) > ?]), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 490(end)  ************** 

***************   Case 491   ***************

SQL: select count(*) FROM t7  HAVING count(*) > (SELECT 5) ; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |81  |
|1 | TABLE SCAN    |t7  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter([T_FUN_COUNT(*) > ?]), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output(nil), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 491(end)  ************** 

***************   Case 492   ***************

SQL: select count(*) FROM t7 GROUP BY c1  HAVING count(*) > (SELECT 5) ; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([1]), filter(nil), startup_filter([0]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 492(end)  ************** 

***************   Case 493   ***************

SQL: select * from t7 order by exists(select 1); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |80  |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | LIMIT        |    |1        |1   |
|3 |  EXPRESSION  |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil)
      values({1})

*************** Case 493(end)  ************** 

***************   Case 494   ***************

SQL: select * from t7 order by (select count(*) from t8) > 1; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |100      |161 |
|1 | TABLE SCAN     |t7  |100      |78  |
|2 | SCALAR GROUP BY|    |1        |81  |
|3 |  TABLE SCAN    |t8  |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1) > 1]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  3 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 494(end)  ************** 

***************   Case 495   ***************

SQL: select * from t7 group by exists(select 1); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE GROUP BY |    |1        |81  |
|1 | SUBPLAN FILTER|    |100      |80  |
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  LIMIT        |    |1        |1   |
|4 |   EXPRESSION  |    |1        |1   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), limit(1), offset(nil)
  4 - output([1]), filter(nil)
      values({1})

*************** Case 495(end)  ************** 

***************   Case 496   ***************

SQL: select * from t7 group by (select count(*) from t8) > 1; 

=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH GROUP BY              |     |1        |206 |
|1 | NESTED-LOOP JOIN CARTESIAN|     |100      |182 |
|2 |  SUBPLAN SCAN             |VIEW1|1        |81  |
|3 |   SCALAR GROUP BY         |     |1        |81  |
|4 |    TABLE SCAN             |t8   |100      |78  |
|5 |  TABLE SCAN               |t7   |100      |78  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      group([VIEW1.count(*) > 1]), agg_func(nil)
  1 - output([t7.c1], [t7.c2], [VIEW1.count(*)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.count(*)]), filter(nil), 
      access([VIEW1.count(*)])
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 496(end)  ************** 

***************   Case 497   ***************

SQL: select * from t7 where exists( select c1, c2 from t8 ); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 497(end)  ************** 

***************   Case 498   ***************

SQL: select * from t7 where exists( select sum(c2), c2 from t8 group by c2 order by c2 desc limit 10 ); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |10       |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 498(end)  ************** 

***************   Case 499   ***************

SQL: select 100 + exists( select c1, c2 from t8 ) from t7; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? + (T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output(nil), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 499(end)  ************** 

***************   Case 500   ***************

SQL: select * from t7 where exists( select c1, count(*) from t8 ); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 500(end)  ************** 

***************   Case 501   ***************

SQL: select * from t7 where exists( select distinct c1 from t8 ); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 501(end)  ************** 

***************   Case 502   ***************

SQL: select * from t7 where exists( select * from t8 limit 10); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |10       |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 502(end)  ************** 

***************   Case 503   ***************

SQL: select * from t7 where exists( select distinct c1 from t8 limit 10); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |10       |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 503(end)  ************** 

***************   Case 504   ***************

SQL: select * from t7 where exists( select c1 from t8 group by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 504(end)  ************** 

***************   Case 505   ***************

SQL: select * from t7 where exists( select c1 from t8 group by c2 limit 10); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |10       |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 505(end)  ************** 

***************   Case 506   ***************

SQL: select * from t7 where t7.c1 in ( select c1 from t8 group by c2 order by c2); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN|     |10       |158 |
|1 | SUBPLAN SCAN   |VIEW1|10       |104 |
|2 |  HASH GROUP BY |     |10       |104 |
|3 |   TABLE SCAN   |t8   |100      |78  |
|4 | TABLE GET      |t7   |1        |5   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW1.c1]), batch_join=true
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t8.c1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 = ?])

*************** Case 506(end)  ************** 

***************   Case 507   ***************

SQL: select * from t7 where t7.c1 >= ( select max(c1) from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |152 |
|1 | TABLE SCAN   |t7  |34       |46  |
|2 | HASH GROUP BY|    |10       |106 |
|3 |  TABLE SCAN  |t8  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 >= ?])
  2 - output([T_FUN_MAX(t8.c1)]), filter(nil), 
      group([t8.c2]), agg_func([T_FUN_MAX(t8.c1)])
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 507(end)  ************** 

***************   Case 508   ***************

SQL: select * from t7 where t7.c1 <=> ( select c1 from t8 group by c2 order by c2 limit 1); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |1        |150 |
|1 | TABLE GET     |t7  |1        |46  |
|2 | TOP-N SORT    |    |1        |104 |
|3 |  HASH GROUP BY|    |10       |104 |
|4 |   TABLE SCAN  |t8  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 <=> ?])
  2 - output([t8.c1]), filter(nil), sort_keys([t8.c2, ASC]), topn(1)
  3 - output([t8.c2], [t8.c1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 508(end)  ************** 

***************   Case 509   ***************

SQL: select * from t7 where t7.c1 = ( select sum(c1) from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |151 |
|1 | TABLE GET    |t7  |1        |46  |
|2 | HASH GROUP BY|    |10       |106 |
|3 |  TABLE SCAN  |t8  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([cast(t7.c1, DECIMAL(11, 0)) = ?])
  2 - output([T_FUN_SUM(t8.c1)]), filter(nil), 
      group([t8.c2]), agg_func([T_FUN_SUM(t8.c1)])
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 509(end)  ************** 

***************   Case 510   ***************

SQL: select * from t7 where t7.c1 <= any( select c1 from t8 group by c2 order by c2); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|     |34       |270 |
|1 | TABLE SCAN          |t7   |100      |78  |
|2 | MATERIAL            |     |10       |104 |
|3 |  SUBPLAN SCAN       |VIEW1|10       |104 |
|4 |   HASH GROUP BY     |     |10       |104 |
|5 |    TABLE SCAN       |t8   |100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 <= VIEW1.c1]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t8.c1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  5 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 510(end)  ************** 

***************   Case 511   ***************

SQL: select * from t7 where t7.c1 <= all( select c1 from t8 group by c2 order by c2); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |67       |270 |
|1 | TABLE SCAN          |t7   |100      |78  |
|2 | MATERIAL            |     |10       |104 |
|3 |  SUBPLAN SCAN       |VIEW1|10       |104 |
|4 |   HASH GROUP BY     |     |10       |104 |
|5 |    TABLE SCAN       |t8   |100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 > VIEW1.c1]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t8.c1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  5 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 511(end)  ************** 

***************   Case 512   ***************

SQL: select * from t7 where t7.c1 in ( select c2 from t8 group by c2 order by c2); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN|     |10       |158 |
|1 | SUBPLAN SCAN   |VIEW1|10       |104 |
|2 |  HASH GROUP BY |     |10       |104 |
|3 |   TABLE SCAN   |t8   |100      |78  |
|4 | TABLE GET      |t7   |1        |5   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW1.c2]), batch_join=true
  1 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  2 - output([t8.c2]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 = ?])

*************** Case 512(end)  ************** 

***************   Case 513   ***************

SQL: select * from t7 where t7.c1 >= ( select c2 from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |150 |
|1 | TABLE SCAN   |t7  |34       |46  |
|2 | HASH GROUP BY|    |10       |104 |
|3 |  TABLE SCAN  |t8  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 >= ?])
  2 - output([t8.c2]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 513(end)  ************** 

***************   Case 514   ***************

SQL: select * from t7 where t7.c1 <=> ( select c2 from t8 group by c2 order by c2 limit 1); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |1        |149 |
|1 | TABLE GET     |t7  |1        |46  |
|2 | TOP-N SORT    |    |1        |104 |
|3 |  HASH GROUP BY|    |10       |104 |
|4 |   TABLE SCAN  |t8  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 <=> ?])
  2 - output([t8.c2]), filter(nil), sort_keys([t8.c2, ASC]), topn(1)
  3 - output([t8.c2]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  4 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 514(end)  ************** 

***************   Case 515   ***************

SQL: select * from t7 where t7.c1 = ( select c2 from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |149 |
|1 | TABLE GET    |t7  |1        |46  |
|2 | HASH GROUP BY|    |10       |104 |
|3 |  TABLE SCAN  |t8  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 = ?])
  2 - output([t8.c2]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 515(end)  ************** 

***************   Case 516   ***************

SQL: select * from t7 where t7.c1 <= any( select c2 from t8 group by c2 order by c2); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|     |34       |270 |
|1 | TABLE SCAN          |t7   |100      |78  |
|2 | MATERIAL            |     |10       |104 |
|3 |  SUBPLAN SCAN       |VIEW1|10       |104 |
|4 |   HASH GROUP BY     |     |10       |104 |
|5 |    TABLE SCAN       |t8   |100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 <= VIEW1.c2]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c2]), filter(nil)
  3 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  4 - output([t8.c2]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  5 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 516(end)  ************** 

***************   Case 517   ***************

SQL: select * from t7 where t7.c1 <= all( select c2 from t8 group by c2 order by c2); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |67       |270 |
|1 | TABLE SCAN          |t7   |100      |78  |
|2 | MATERIAL            |     |10       |104 |
|3 |  SUBPLAN SCAN       |VIEW1|10       |104 |
|4 |   HASH GROUP BY     |     |10       |104 |
|5 |    TABLE SCAN       |t8   |100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 > VIEW1.c2 OR (T_OP_IS, VIEW1.c2, NULL, 0)]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c2]), filter(nil)
  3 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  4 - output([t8.c2]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  5 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 517(end)  ************** 

***************   Case 518   ***************

SQL: select * from t7 where t7.c1 >= ( select c2 from t8 group by c2, c1 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |124 |
|1 | TABLE SCAN   |t7  |34       |46  |
|2 | TABLE SCAN   |t8  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 >= ?])
  2 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 518(end)  ************** 

***************   Case 519   ***************

SQL: select * from t7 where t7.c1 = ( select c2 + 1 from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |149 |
|1 | TABLE GET    |t7  |1        |46  |
|2 | HASH GROUP BY|    |10       |104 |
|3 |  TABLE SCAN  |t8  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 = ?])
  2 - output([t8.c2 + ?]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 519(end)  ************** 

***************   Case 520   ***************

SQL: select * from t7 where t7.c1 <= any( select c2 + 1 from t8 group by c2 + 1, c2 order by c2); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|     |34       |258 |
|1 | TABLE SCAN          |t7   |100      |78  |
|2 | MATERIAL            |     |10       |106 |
|3 |  SUBPLAN SCAN       |VIEW1|10       |106 |
|4 |   HASH GROUP BY     |     |10       |105 |
|5 |    TABLE SCAN       |t8   |100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 <= VIEW1.c2 + 1]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([VIEW1.c2 + 1]), filter(nil)
  3 - output([VIEW1.c2 + 1]), filter(nil), 
      access([VIEW1.c2 + 1])
  4 - output([t8.c2 + 1]), filter(nil), 
      group([t8.c2 + 1], [t8.c2]), agg_func(nil)
  5 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 520(end)  ************** 

***************   Case 521   ***************

SQL: select * from t7 where t7.c1 in ( select c1 from t8 group by c2 desc order by c1 asc); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN|     |10       |158 |
|1 | SUBPLAN SCAN   |VIEW1|10       |104 |
|2 |  HASH GROUP BY |     |10       |104 |
|3 |   TABLE SCAN   |t8   |100      |78  |
|4 | TABLE GET      |t7   |1        |5   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW1.c1]), batch_join=true
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([t8.c1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 = ?])

*************** Case 521(end)  ************** 

***************   Case 522   ***************

SQL: select * from t7 where t7.c1 = ( select 100 from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |149 |
|1 | TABLE GET    |t7  |1        |46  |
|2 | HASH GROUP BY|    |10       |104 |
|3 |  TABLE SCAN  |t8  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 = ?])
  2 - output([?]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 522(end)  ************** 

***************   Case 523   ***************

SQL: select * from t7 where t7.c1 <= any( select 'abc' from t8 group by c2 order by c2); 

====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |100      |207 |
|1 | TABLE SCAN               |t7   |100      |78  |
|2 | MATERIAL                 |     |1        |102 |
|3 |  SUBPLAN SCAN            |VIEW1|1        |102 |
|4 |   LIMIT                  |     |1        |102 |
|5 |    HASH GROUP BY         |     |1        |102 |
|6 |     TABLE SCAN           |t8   |100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(NULL ; 0], 
      range_cond([? >= cast(t7.c1, DECIMAL(11, 0))])
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), 
      access(nil)
  4 - output([?]), filter(nil), limit(1), offset(nil)
  5 - output(nil), filter(nil), 
      group([t8.c2]), agg_func(nil)
  6 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 523(end)  ************** 

***************   Case 524   ***************

SQL: select * from t7 where t7.c1 <= all( select (select 1+1) from t8 group by c2 order by c2); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |10       |150 |
|1 | TABLE SCAN          |t7   |100      |78  |
|2 | MATERIAL            |     |1        |46  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |46  |
|4 |   TABLE SCAN        |t8   |1        |46  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds([t7.c1 > ?]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), 
      access(nil)
  4 - output([?]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 524(end)  ************** 

***************   Case 525   ***************

SQL: select * from t7 where t7.c1 in ( select c2 from t8 group by now()); 

==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |NESTED-LOOP JOIN|     |1        |85  |
|1 | SUBPLAN SCAN   |VIEW1|1        |80  |
|2 |  MERGE GROUP BY|     |1        |80  |
|3 |   TABLE SCAN   |t8   |100      |78  |
|4 | TABLE GET      |t7   |1        |5   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW1.c2]), batch_join=true
  1 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  2 - output([t8.c2]), filter(nil), 
      group(nil), agg_func(nil)
  3 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 = ?])

*************** Case 525(end)  ************** 

***************   Case 526   ***************

SQL: select * from t7 where t7.c1 in ( select now() from t8 group by c2); 

====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |1        |182 |
|1 | TABLE SCAN               |t7   |1        |80  |
|2 | MATERIAL                 |     |1        |102 |
|3 |  SUBPLAN SCAN            |VIEW1|1        |102 |
|4 |   LIMIT                  |     |1        |102 |
|5 |    HASH GROUP BY         |     |1        |102 |
|6 |     TABLE SCAN           |t8   |100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter([cast(t7.c1, DATETIME(-1, -1)) = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), 
      access(nil)
  4 - output([?]), filter(nil), limit(1), offset(nil)
  5 - output(nil), filter(nil), 
      group([t8.c2]), agg_func(nil)
  6 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 526(end)  ************** 

***************   Case 527   ***************

SQL: select * from t7 where t7.c1 in ( select t7.c2 from t8 group by c2); 

====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |1        |182 |
|1 | TABLE SCAN               |t7   |1        |80  |
|2 | MATERIAL                 |     |1        |102 |
|3 |  SUBPLAN SCAN            |VIEW2|1        |102 |
|4 |   LIMIT                  |     |1        |102 |
|5 |    HASH GROUP BY         |     |1        |102 |
|6 |     TABLE SCAN           |t8   |100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter([t7.c1 = t7.c2]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), 
      access(nil)
  4 - output([1]), filter(nil), limit(1), offset(nil)
  5 - output(nil), filter(nil), 
      group([t8.c2]), agg_func(nil)
  6 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 527(end)  ************** 

***************   Case 528   ***************

SQL: select * from t7 where exists(select c1 + c2 from t8) and exists(select c3 * 3 from t9); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |170 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
|3 | TABLE SCAN   |t9  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?], [?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 528(end)  ************** 

***************   Case 529   ***************

SQL: select * from t7 where exists(select c1 + c2 from t8) and exists(select c3 * 3 from t9); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |170 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
|3 | TABLE SCAN   |t9  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?], [?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 529(end)  ************** 

***************   Case 530   ***************

SQL: select * from t7 where exists(select c1 + c2 from t8) having exists(select c3 * 3 from t9); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |170 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
|3 | TABLE SCAN   |t9  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))], [(T_OP_EXISTS, subquery(2))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?], [?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 530(end)  ************** 

***************   Case 531   ***************

SQL: select * from t7 where exists(select c1 + c2 from t8) group by exists(select c3 * 3 from t9); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |174 |
|1 | SUBPLAN FILTER |    |100      |172 |
|2 |  SUBPLAN FILTER|    |100      |125 |
|3 |   TABLE SCAN   |t7  |100      |78  |
|4 |   TABLE SCAN   |t8  |1        |46  |
|5 |  TABLE SCAN    |t9  |1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t9.c3 * 3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 531(end)  ************** 

***************   Case 532   ***************

SQL: select * from t7 where exists(select c1 + c2 from t8) order by exists(select c3 * 3 from t9); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |100      |172 |
|1 | SUBPLAN FILTER|    |100      |125 |
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  TABLE SCAN   |t8  |1        |46  |
|4 | TABLE SCAN    |t9  |1        |46  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t9.c3 * 3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 532(end)  ************** 

***************   Case 533   ***************

SQL: select * from t7 where not exists(select c1 + c2 from t8) and not exists(select c3 * 3 from t9); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |170 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
|3 | TABLE SCAN   |t9  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?], [?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 533(end)  ************** 

***************   Case 534   ***************

SQL: select * from t7 where not exists(select c1 + c2 from t8) having not exists(select c3 * 3 from t9); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |170 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
|3 | TABLE SCAN   |t9  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))], [(T_OP_NOT_EXISTS, subquery(2))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?], [?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 534(end)  ************** 

***************   Case 535   ***************

SQL: select * from t7 where not exists(select c1 + c2 from t8) group by not exists(select c3 * 3 from t9); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE GROUP BY  |    |1        |174 |
|1 | SUBPLAN FILTER |    |100      |172 |
|2 |  SUBPLAN FILTER|    |100      |125 |
|3 |   TABLE SCAN   |t7  |100      |78  |
|4 |   TABLE SCAN   |t8  |1        |46  |
|5 |  TABLE SCAN    |t9  |1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t9.c3 * 3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 535(end)  ************** 

***************   Case 536   ***************

SQL: select * from t7 where not exists(select c1 + c2 from t8) order by not exists(select c3 * 3 from t9); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |100      |172 |
|1 | SUBPLAN FILTER|    |100      |125 |
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  TABLE SCAN   |t8  |1        |46  |
|4 | TABLE SCAN    |t9  |1        |46  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t9.c3 * 3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 536(end)  ************** 

***************   Case 537   ***************

SQL: select c3 + 3 from t9 where exists(select exists(select c1+1 from t7) from t8); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t9  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t9.c3 + ?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t9.c3]), filter(nil), startup_filter([?]), 
      access([t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 537(end)  ************** 

***************   Case 538   ***************

SQL: select c3 + 3 from t9 where exists(select exists(select c1+1 from t7), c2 from t8); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t9  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t9.c3 + ?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t9.c3]), filter(nil), startup_filter([?]), 
      access([t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 538(end)  ************** 

***************   Case 539   ***************

SQL: select c3 from t9 where ( select count(1) from (select c2 from t8 group by c2) t999 ) > 10; 

====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |5        |109 |
|1 | SUBPLAN SCAN             |VIEW1|1        |104 |
|2 |  SCALAR GROUP BY         |     |1        |104 |
|3 |   SUBPLAN SCAN           |t999 |10       |104 |
|4 |    HASH GROUP BY         |     |10       |104 |
|5 |     TABLE SCAN           |t8   |100      |78  |
|6 | TABLE SCAN               |t9   |100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t9.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([T_FUN_COUNT(*)]), filter([T_FUN_COUNT(*) > ?]), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  3 - output(nil), filter(nil), 
      access(nil)
  4 - output([1]), filter(nil), 
      group([t8.c2]), agg_func(nil)
  5 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  6 - output([t9.c3]), filter(nil), 
      access([t9.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 539(end)  ************** 

***************   Case 540   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 group by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 540(end)  ************** 

***************   Case 541   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 541(end)  ************** 

***************   Case 542   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 542(end)  ************** 

***************   Case 543   ***************

SQL: select * from t7 where not exists(select c1, round(c2) from t8 group by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 543(end)  ************** 

***************   Case 544   ***************

SQL: select * from t7 where not exists(select c1, round(c2) from t8 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 544(end)  ************** 

***************   Case 545   ***************

SQL: select * from t7 where not exists(select c1, round(c2) from t8 group by c2 order by c2); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 545(end)  ************** 

***************   Case 546   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 group by c2 having round(c2) > 0); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |125 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter([round(cast(t8.c2, BIGINT(-1, 0))) > ?]), 
      access([t8.c2]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 546(end)  ************** 

***************   Case 547   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 order by c2 limit 0); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |80  |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t8  |0        |0   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(0), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 547(end)  ************** 

***************   Case 548   ***************

SQL: select * from t7 where exists(select c1, round(c2) from t8 group by c2 having round(c2) > 0 and c1 != 1 order by c2 limit 10); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SUBPLAN FILTER |    |100      |170 |
|1 | TABLE SCAN    |t7  |100      |78  |
|2 | LIMIT         |    |10       |91  |
|3 |  HASH GROUP BY|    |10       |90  |
|4 |   TABLE SCAN  |t8  |34       |80  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [round(cast(t8.c2, BIGINT(-1, 0)))]), filter(nil), limit(10), offset(nil)
  3 - output([t8.c1], [t8.c2]), filter([t8.c1 != ?]), 
      group([t8.c2]), agg_func(nil)
  4 - output([t8.c1], [t8.c2]), filter([round(cast(t8.c2, BIGINT(-1, 0))) > ?]), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 548(end)  ************** 

***************   Case 549   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 ); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |10000    |2957|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |2736|
|2 |  TABLE SCAN               |t7  |100      |78  |
|3 |  MATERIAL                 |    |100      |79  |
|4 |   TABLE SCAN              |t8  |100      |78  |
|5 | TABLE SCAN                |t9  |1        |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), startup_filter([?]), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 549(end)  ************** 

***************   Case 550   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 group by c2); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |10000    |2957|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |2736|
|2 |  TABLE SCAN               |t7  |100      |78  |
|3 |  MATERIAL                 |    |100      |79  |
|4 |   TABLE SCAN              |t8  |100      |78  |
|5 | TABLE SCAN                |t9  |1        |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), startup_filter([?]), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 550(end)  ************** 

***************   Case 551   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 order by c2); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |10000    |2957|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |2736|
|2 |  TABLE SCAN               |t7  |100      |78  |
|3 |  MATERIAL                 |    |100      |79  |
|4 |   TABLE SCAN              |t8  |100      |78  |
|5 | TABLE SCAN                |t9  |1        |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), startup_filter([?]), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 551(end)  ************** 

***************   Case 552   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 group by c2 order by c2); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |10000    |2957|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |2736|
|2 |  TABLE SCAN               |t7  |100      |78  |
|3 |  MATERIAL                 |    |100      |79  |
|4 |   TABLE SCAN              |t8  |100      |78  |
|5 | TABLE SCAN                |t9  |1        |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), startup_filter([?]), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 552(end)  ************** 

***************   Case 553   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 order by c2 limit 10); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |10000    |2957|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |2736|
|2 |  TABLE SCAN               |t7  |100      |78  |
|3 |  MATERIAL                 |    |100      |79  |
|4 |   TABLE SCAN              |t8  |100      |78  |
|5 | TABLE SCAN                |t9  |10       |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), startup_filter([?]), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 553(end)  ************** 

***************   Case 554   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 group by c2 order by c2 limit 10); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |10000    |2957|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |2736|
|2 |  TABLE SCAN               |t7  |100      |78  |
|3 |  MATERIAL                 |    |100      |79  |
|4 |   TABLE SCAN              |t8  |100      |78  |
|5 | TABLE SCAN                |t9  |10       |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), startup_filter([?]), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter(nil), 
      access([t9.c1]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 554(end)  ************** 

***************   Case 555   ***************

SQL: select * from t7,t8 where exists( select *, round(c2) from t9 group by c2 having round(c2) > 0 order by c2); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |10000    |2957|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |2736|
|2 |  TABLE SCAN               |t7  |100      |78  |
|3 |  MATERIAL                 |    |100      |79  |
|4 |   TABLE SCAN              |t8  |100      |78  |
|5 | TABLE SCAN                |t9  |1        |46  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), startup_filter([?]), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil)
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([1]), filter([round(cast(t9.c2, BIGINT(-1, 0))) > ?]), 
      access([t9.c2]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t9.c1]), range(MIN ; MAX)always true

*************** Case 555(end)  ************** 

***************   Case 556   ***************

SQL: (select * from t7 where exists(select c1, round(c2) from t8 group by c2 order by c2)) union (select * from t8); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |200      |207 |
|1 | SUBPLAN FILTER     |    |100      |125 |
|2 |  TABLE SCAN        |t7  |100      |78  |
|3 |  TABLE SCAN        |t8  |1        |46  |
|4 | TABLE SCAN         |t8  |100      |78  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), startup_filter([?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  4 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 556(end)  ************** 

***************   Case 557   ***************

SQL: select c1, c2 from t7 where exists (select 1 from t8 where t8.c1 = t7.c1); 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |187 |
|1 | TABLE SCAN|t7  |100      |78  |
|2 | TABLE SCAN|t8  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t8.c1 = t7.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 557(end)  ************** 

***************   Case 558   ***************

SQL: select c1, c2 from t7 where not exists (select 1 from t8 where t8.c1 = t7.c1); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE ANTI JOIN|    |1        |165 |
|1 | TABLE SCAN    |t7  |100      |78  |
|2 | TABLE SCAN    |t8  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t8.c1 = t7.c1]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 558(end)  ************** 

***************   Case 559   ***************

SQL: SELECT 1 FROM t7 WHERE NOT EXISTS(SELECT 1 FROM t8 WHERE c2 = (SELECT c2 FROM t8 WHERE c1 >= 1) ORDER BY c2); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |100      |203 |
|1 | TABLE SCAN     |t7  |100      |78  |
|2 | LIMIT          |    |1        |124 |
|3 |  SUBPLAN FILTER|    |1        |124 |
|4 |   TABLE SCAN   |t8  |1        |46  |
|5 |   TABLE SCAN   |t8  |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output(nil), filter(nil), startup_filter([?]), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), limit(1), offset(nil)
  3 - output(nil), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output(nil), filter([t8.c2 = ?]), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[1 ; MAX), 
      range_cond([t8.c1 >= ?])

*************** Case 559(end)  ************** 

***************   Case 560   ***************

SQL: select distinct 1, 1+2, ABS(-1) from t7; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?], [?]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 560(end)  ************** 

***************   Case 561   ***************

SQL: select distinct 1, c2 from t7; 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH DISTINCT|    |10       |104 |
|1 | TABLE SCAN  |t7  |100      |78  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t7.c2]), filter(nil), 
      distinct([t7.c2])
  1 - output([t7.c2]), filter(nil), 
      access([t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 561(end)  ************** 

***************   Case 562   ***************

SQL: select count(distinct 1) from t7; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |SCALAR GROUP BY|    |1        |81  |
|1 | TABLE SCAN    |t7  |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(distinct ?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(distinct ?)])
  1 - output(nil), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 562(end)  ************** 

***************   Case 563   ***************

SQL: select distinct (select c1 from t7 limit 1) from t8; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |LIMIT          |    |1        |91  |
|1 | SUBPLAN FILTER|    |1        |91  |
|2 |  TABLE SCAN   |t8  |1        |46  |
|3 |  TABLE SCAN   |t7  |1        |46  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), limit(1), offset(nil)
  1 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 563(end)  ************** 

***************   Case 564   ***************

SQL: select distinct 1, 1 + @var from t7; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |1        |46  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [?]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 564(end)  ************** 

***************   Case 565   ***************

SQL: Select distinct 1, 1 + (@var:=1) from t7; 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH DISTINCT|    |1        |102 |
|1 | TABLE SCAN  |t7  |100      |78  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [? + (T_OP_ASSIGN, 'var', ?)]), filter(nil), 
      distinct([? + (T_OP_ASSIGN, 'var', ?)])
  1 - output(nil), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 565(end)  ************** 

***************   Case 566   ***************

SQL: select t1.c2 + t2.c1 from t1, t2 where t1.c1 = t2.c2 and t1.c1 and t1.c1 = 1 and t2.c1 = 1; 

=====================================================
|ID|OPERATOR                    |NAME|EST. ROWS|COST|
-----------------------------------------------------
|0 |EXCHANGE IN REMOTE          |    |1        |50  |
|1 | EXCHANGE OUT REMOTE        |    |1        |50  |
|2 |  NESTED-LOOP JOIN CARTESIAN|    |1        |50  |
|3 |   TABLE GET                |t2  |1        |46  |
|4 |   TABLE GET                |t1  |1        |46  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2 + ?]), filter(nil)
  1 - output([t1.c2 + ?]), filter(nil)
  2 - output([t1.c2 + ?]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output(nil), filter([? = t2.c2]), 
      access([t2.c2]), partitions(p1), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])
  4 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])

*************** Case 566(end)  ************** 

***************   Case 567   ***************

SQL: (select 'b') union select cast((select 'a') as char(20)); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 567(end)  ************** 

***************   Case 568   ***************

SQL: select cast((select 'a' from dual order by 1 limit 100) as char(20)) union (select 'b') union select cast((select 'a' from dual order by 1 limit 100) as char(20)); 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |MERGE DISTINCT   |    |1        |1   |
|1 | SORT            |    |3        |1   |
|2 |  UNION ALL      |    |3        |1   |
|3 |   SUBPLAN FILTER|    |1        |1   |
|4 |    EXPRESSION   |    |1        |1   |
|5 |    LIMIT        |    |1        |1   |
|6 |     EXPRESSION  |    |1        |1   |
|7 |   EXPRESSION    |    |1        |1   |
|8 |   SUBPLAN FILTER|    |1        |1   |
|9 |    EXPRESSION   |    |1        |1   |
|10|    LIMIT        |    |1        |1   |
|11|     EXPRESSION  |    |1        |1   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), 
      distinct([UNION([1])])
  1 - output([UNION([1])]), filter(nil), sort_keys([UNION([1]), ASC])
  2 - output([UNION([1])]), filter(nil)
  3 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), CHAR(20))]), init_plan_idxs_(nil)
  4 - output([1]), filter(nil)
      values({1})
  5 - output([?]), filter(nil), limit(100), offset(nil)
  6 - output([1]), filter(nil)
      values({1})
  7 - output([?]), filter(nil)
      values({?})
  8 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), CHAR(20))]), init_plan_idxs_(nil)
  9 - output([1]), filter(nil)
      values({1})
  10 - output([?]), filter(nil), limit(100), offset(nil)
  11 - output([1]), filter(nil)
      values({1})

*************** Case 568(end)  ************** 

***************   Case 569   ***************

SQL: (select (select b from t12) from t3) union (select c3 from t3); 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |HASH UNION DISTINCT      |        |400      |709 |
|1 | SUBPLAN FILTER          |        |200      |268 |
|2 |  PX COORDINATOR         |        |200      |187 |
|3 |   EXCHANGE OUT DISTR    |:EX10000|200      |176 |
|4 |    PX PARTITION ITERATOR|        |200      |155 |
|5 |     TABLE SCAN          |t3      |200      |155 |
|6 |  TABLE SCAN             |t12     |100      |78  |
|7 | PX COORDINATOR          |        |200      |261 |
|8 |  EXCHANGE OUT DISTR     |:EX20000|200      |227 |
|9 |   PX PARTITION ITERATOR |        |200      |155 |
|10|    TABLE SCAN           |t3      |200      |155 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), VARCHAR(32))]), init_plan_idxs_(nil)
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), dop=1
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  6 - output([t12.b]), filter(nil), 
      access([t12.b]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  7 - output([t3.c3]), filter(nil)
  8 - output([t3.c3]), filter(nil), dop=1
  9 - output([t3.c3]), filter(nil), 
      force partition granule.
  10 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 569(end)  ************** 

***************   Case 570   ***************

SQL: select distinct c2 from t1 partition(p1); 

======================================================
|ID|OPERATOR            |NAME         |EST. ROWS|COST|
------------------------------------------------------
|0 |EXCHANGE IN REMOTE  |             |10       |84  |
|1 | EXCHANGE OUT REMOTE|             |10       |83  |
|2 |  MERGE DISTINCT    |             |10       |82  |
|3 |   TABLE SCAN       |t1(idx_t1_c2)|100      |78  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2]), filter(nil)
  1 - output([t1.c2]), filter(nil)
  2 - output([t1.c2]), filter(nil), 
      distinct([t1.c2])
  3 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 570(end)  ************** 

***************   Case 571   ***************

SQL: select cast((select 'a') as char(20)) as c1 union (select 'b') order by c1; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 571(end)  ************** 

***************   Case 572   ***************

SQL: select (select 'a') as c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |EXPRESSION|    |1        |1   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil)
      values({?})

*************** Case 572(end)  ************** 

***************   Case 573   ***************

SQL: select avg(c1) as a from t1 union select sum(c1) as b from t1; 

============================================================
|ID|OPERATOR                   |NAME        |EST. ROWS|COST|
------------------------------------------------------------
|0 |TEMP TABLE TRANSFORMATION  |            |2        |415 |
|1 | TEMP TABLE INSERT         |TEMP1       |1        |414 |
|2 |  SCALAR GROUP BY          |            |1        |414 |
|3 |   PX COORDINATOR          |            |1        |414 |
|4 |    EXCHANGE OUT DISTR     |:EX10000    |1        |414 |
|5 |     MERGE GROUP BY        |            |1        |414 |
|6 |      PX PARTITION ITERATOR|            |500      |387 |
|7 |       TABLE SCAN          |t1          |500      |387 |
|8 | MERGE UNION DISTINCT      |            |2        |1   |
|9 |  TEMP TABLE ACCESS        |VIEW1(TEMP1)|1        |1   |
|10|  TEMP TABLE ACCESS        |VIEW2(TEMP1)|1        |1   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output(nil), filter(nil)
  2 - output([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t1.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  3 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil)
  4 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  5 - output([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t1.c1)], [T_FUN_COUNT(t1.c1)])
  6 - output([t1.c1]), filter(nil), 
      force partition granule.
  7 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([UNION([1])]), filter(nil)
  9 - output([VIEW1.T_FUN_SUM(t1.c1) / cast(VIEW1.T_FUN_COUNT(t1.c1), DECIMAL(20, 0))]), filter(nil), 
      access([VIEW1.T_FUN_SUM(t1.c1)], [VIEW1.T_FUN_COUNT(t1.c1)])
  10 - output([VIEW2.T_FUN_SUM(t1.c1)]), filter(nil), 
      access([VIEW2.T_FUN_SUM(t1.c1)])

*************** Case 573(end)  ************** 

***************   Case 574   ***************

SQL: select * from t1 group by 1>(select count(*) from t2); 

=========================================================
|ID|OPERATOR                    |NAME    |EST. ROWS|COST|
---------------------------------------------------------
|0 |HASH GROUP BY               |        |1        |653 |
|1 | NESTED-LOOP JOIN CARTESIAN |        |500      |533 |
|2 |  SUBPLAN SCAN              |VIEW1   |1        |244 |
|3 |   SCALAR GROUP BY          |        |1        |244 |
|4 |    PX COORDINATOR          |        |1        |243 |
|5 |     EXCHANGE OUT DISTR     |:EX10000|1        |243 |
|6 |      MERGE GROUP BY        |        |1        |243 |
|7 |       PX PARTITION ITERATOR|        |300      |233 |
|8 |        TABLE SCAN          |t2      |300      |233 |
|9 |  PX COORDINATOR            |        |500      |528 |
|10|   EXCHANGE OUT DISTR       |:EX20000|500      |481 |
|11|    PX PARTITION ITERATOR   |        |500      |387 |
|12|     TABLE SCAN             |t1      |500      |387 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      group([1 > VIEW1.count(*)]), agg_func(nil)
  1 - output([t1.c1], [t1.c2], [VIEW1.count(*)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([VIEW1.count(*)]), filter(nil), 
      access([VIEW1.count(*)])
  3 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  4 - output([T_FUN_COUNT(*)]), filter(nil)
  5 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  6 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  7 - output(nil), filter(nil), 
      force partition granule.
  8 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  9 - output([t1.c1], [t1.c2]), filter(nil)
  10 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 574(end)  ************** 

***************   Case 575   ***************

SQL: (select count(*) from t1) UNION (select count(*) from t1); 

============================================================
|ID|OPERATOR                   |NAME        |EST. ROWS|COST|
------------------------------------------------------------
|0 |TEMP TABLE TRANSFORMATION  |            |2        |405 |
|1 | TEMP TABLE INSERT         |TEMP1       |1        |405 |
|2 |  SCALAR GROUP BY          |            |1        |405 |
|3 |   PX COORDINATOR          |            |1        |405 |
|4 |    EXCHANGE OUT DISTR     |:EX10000    |1        |405 |
|5 |     MERGE GROUP BY        |            |1        |405 |
|6 |      PX PARTITION ITERATOR|            |500      |387 |
|7 |       TABLE SCAN          |t1          |500      |387 |
|8 | MERGE UNION DISTINCT      |            |2        |1   |
|9 |  TEMP TABLE ACCESS        |VIEW1(TEMP1)|1        |1   |
|10|  TEMP TABLE ACCESS        |VIEW2(TEMP1)|1        |1   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output(nil), filter(nil)
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  3 - output([T_FUN_COUNT(*)]), filter(nil)
  4 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  5 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  6 - output(nil), filter(nil), 
      force partition granule.
  7 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([UNION([1])]), filter(nil)
  9 - output([VIEW1.T_FUN_COUNT(*)]), filter(nil), 
      access([VIEW1.T_FUN_COUNT(*)])
  10 - output([VIEW2.T_FUN_COUNT(*)]), filter(nil), 
      access([VIEW2.T_FUN_COUNT(*)])

*************** Case 575(end)  ************** 

***************   Case 576   ***************

SQL: select min(1) from t1; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |SCALAR GROUP BY            |        |1        |228 |
|1 | SUBPLAN SCAN              |VIEW1   |1        |228 |
|2 |  LIMIT                    |        |1        |227 |
|3 |   PX COORDINATOR          |        |1        |227 |
|4 |    EXCHANGE OUT DISTR     |:EX10000|1        |227 |
|5 |     LIMIT                 |        |1        |227 |
|6 |      PX PARTITION ITERATOR|        |1        |227 |
|7 |       TABLE SCAN          |t1      |1        |227 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MIN(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(?)])
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), dop=1
  5 - output(nil), filter(nil), limit(1), offset(nil)
  6 - output(nil), filter(nil), 
      force partition granule.
  7 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 576(end)  ************** 

***************   Case 577   ***************

SQL: select max(1) from t1; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |SCALAR GROUP BY            |        |1        |228 |
|1 | SUBPLAN SCAN              |VIEW1   |1        |228 |
|2 |  LIMIT                    |        |1        |227 |
|3 |   PX COORDINATOR          |        |1        |227 |
|4 |    EXCHANGE OUT DISTR     |:EX10000|1        |227 |
|5 |     LIMIT                 |        |1        |227 |
|6 |      PX PARTITION ITERATOR|        |1        |227 |
|7 |       TABLE SCAN          |t1      |1        |227 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(?)])
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), dop=1
  5 - output(nil), filter(nil), limit(1), offset(nil)
  6 - output(nil), filter(nil), 
      force partition granule.
  7 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 577(end)  ************** 

***************   Case 578   ***************

SQL: select sum(1) from t1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |405 |
|1 | PX COORDINATOR          |        |1        |405 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |405 |
|3 |   MERGE GROUP BY        |        |1        |405 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_SUM(T_FUN_SUM(?))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(?))])
  1 - output([T_FUN_SUM(?)]), filter(nil)
  2 - output([T_FUN_SUM(?)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(?)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(?)])
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 578(end)  ************** 

***************   Case 579   ***************

SQL: select avg(1) from t1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |414 |
|1 | PX COORDINATOR          |        |1        |414 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |414 |
|3 |   MERGE GROUP BY        |        |1        |414 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
<<<<<<< HEAD
  0 - output([T_FUN_SUM(T_FUN_SUM(?)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(*)), DECIMAL(20, 0))]), filter(nil), 
=======
  0 - output([cast(T_FUN_SUM(T_FUN_SUM(?)) / T_FUN_COUNT_SUM(T_FUN_COUNT(*)), DECIMAL(5, 4))]), filter(nil), 
>>>>>>> 4ace446e738... fix aggr convert lost origin type
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(?))], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_SUM(?)], [T_FUN_COUNT(*)]), filter(nil)
  2 - output([T_FUN_SUM(?)], [T_FUN_COUNT(*)]), filter(nil), dop=1
  3 - output([T_FUN_SUM(?)], [T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(?)], [T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), 
      force partition granule.
  5 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 579(end)  ************** 

***************   Case 580   ***************

SQL: select t1.c3, t2.c3 from (select c3, c2 from t3 order by c3) as t1, t2 where t1.c2 = t2.c2; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH JOIN               |        |487      |835 |
|1 | PX COORDINATOR         |        |200      |285 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|200      |244 |
|3 |   PX PARTITION ITERATOR|        |200      |155 |
|4 |    TABLE SCAN          |t3      |200      |155 |
|5 | PX COORDINATOR         |        |300      |428 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300      |366 |
|7 |   PX PARTITION ITERATOR|        |300      |233 |
|8 |    TABLE SCAN          |t2      |300      |233 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c3], [t2.c3]), filter(nil), 
      equal_conds([t3.c2 = t2.c2]), other_conds(nil)
  1 - output([t3.c3], [t3.c2]), filter(nil)
  2 - output([t3.c3], [t3.c2]), filter(nil), dop=1
  3 - output([t3.c3], [t3.c2]), filter(nil), 
      force partition granule.
  4 - output([t3.c3], [t3.c2]), filter(nil), 
      access([t3.c3], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t2.c3], [t2.c2]), filter(nil)
  6 - output([t2.c3], [t2.c2]), filter(nil), dop=1
  7 - output([t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  8 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 580(end)  ************** 

***************   Case 581   ***************

SQL: (select c2, c1 from t19 order by c2) union (select c2, c1 from t19 order by c2); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |200      |160 |
|1 | TABLE SCAN         |t19 |100      |78  |
|2 | TABLE SCAN         |t19 |100      |78  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t19.c2], [t19.c1]), filter(nil), 
      access([t19.c1], [t19.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true
  2 - output([t19.c2], [t19.c1]), filter(nil), 
      access([t19.c1], [t19.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t19.c1], [t19.c2], [t19.c3], [t19.c4]), range(MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX)always true

*************** Case 581(end)  ************** 

***************   Case 582   ***************

SQL: select a1, a2 from set_t1 group by a1 asc, a2 desc union select b1, b2 from set_t2 group by b1 asc, b2 desc; 

===============================================
|ID|OPERATOR            |NAME  |EST. ROWS|COST|
-----------------------------------------------
|0 |MERGE UNION DISTINCT|      |142      |284 |
|1 | MERGE GROUP BY     |      |71       |140 |
|2 |  SORT              |      |100      |135 |
|3 |   TABLE SCAN       |set_t1|100      |78  |
|4 | MERGE GROUP BY     |      |71       |140 |
|5 |  SORT              |      |100      |135 |
|6 |   TABLE SCAN       |set_t2|100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      group([set_t1.a1], [set_t1.a2]), agg_func(nil)
  2 - output([set_t1.a1], [set_t1.a2]), filter(nil), sort_keys([set_t1.a1, ASC], [set_t1.a2, ASC])
  3 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      access([set_t1.a1], [set_t1.a2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  4 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      group([set_t2.b1], [set_t2.b2]), agg_func(nil)
  5 - output([set_t2.b1], [set_t2.b2]), filter(nil), sort_keys([set_t2.b1, ASC], [set_t2.b2, ASC])
  6 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      access([set_t2.b1], [set_t2.b2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 582(end)  ************** 

***************   Case 583   ***************

SQL: select a1, a2 from set_t1 group by a1 asc, a2 desc intersect select b1, b2 from set_t2 group by b1 asc, b2 desc; 

===================================================
|ID|OPERATOR                |NAME  |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE INTERSECT DISTINCT|      |71       |284 |
|1 | MERGE GROUP BY         |      |71       |140 |
|2 |  SORT                  |      |100      |135 |
|3 |   TABLE SCAN           |set_t1|100      |78  |
|4 | MERGE GROUP BY         |      |71       |140 |
|5 |  SORT                  |      |100      |135 |
|6 |   TABLE SCAN           |set_t2|100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])], [INTERSECT([2])]), filter(nil)
  1 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      group([set_t1.a1], [set_t1.a2]), agg_func(nil)
  2 - output([set_t1.a1], [set_t1.a2]), filter(nil), sort_keys([set_t1.a1, ASC], [set_t1.a2, ASC])
  3 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      access([set_t1.a1], [set_t1.a2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  4 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      group([set_t2.b1], [set_t2.b2]), agg_func(nil)
  5 - output([set_t2.b1], [set_t2.b2]), filter(nil), sort_keys([set_t2.b1, ASC], [set_t2.b2, ASC])
  6 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      access([set_t2.b1], [set_t2.b2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 583(end)  ************** 

***************   Case 584   ***************

SQL: select a1, a2 from set_t1 group by a1 asc, a2 desc except select b1, b2 from set_t2 group by b1 asc, b2 desc; 

================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST|
------------------------------------------------
|0 |MERGE EXCEPT DISTINCT|      |71       |284 |
|1 | MERGE GROUP BY      |      |71       |140 |
|2 |  SORT               |      |100      |135 |
|3 |   TABLE SCAN        |set_t1|100      |78  |
|4 | MERGE GROUP BY      |      |71       |140 |
|5 |  SORT               |      |100      |135 |
|6 |   TABLE SCAN        |set_t2|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([EXCEPT([1])], [EXCEPT([2])]), filter(nil)
  1 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      group([set_t1.a1], [set_t1.a2]), agg_func(nil)
  2 - output([set_t1.a1], [set_t1.a2]), filter(nil), sort_keys([set_t1.a1, ASC], [set_t1.a2, ASC])
  3 - output([set_t1.a1], [set_t1.a2]), filter(nil), 
      access([set_t1.a1], [set_t1.a2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  4 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      group([set_t2.b1], [set_t2.b2]), agg_func(nil)
  5 - output([set_t2.b1], [set_t2.b2]), filter(nil), sort_keys([set_t2.b1, ASC], [set_t2.b2, ASC])
  6 - output([set_t2.b1], [set_t2.b2]), filter(nil), 
      access([set_t2.b1], [set_t2.b2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 584(end)  ************** 

***************   Case 585   ***************

SQL: (select * from t1 where c1 = 2) union all (select * from t1 where c1 = 2); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |2        |92  |
|1 | EXCHANGE OUT REMOTE|    |2        |92  |
|2 |  UNION ALL         |    |2        |91  |
|3 |   TABLE GET        |t1  |1        |46  |
|4 |   TABLE GET        |t1  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([UNION([1])], [UNION([2])]), filter(nil)
  3 - output([?], [t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])
  4 - output([?], [t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p2), 
      is_index_back=false, 
      range_key([t1.c1]), range[2 ; 2], 
      range_cond([t1.c1 = ?])

*************** Case 585(end)  ************** 

***************   Case 586   ***************

SQL: (select 1) union (select 1); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 586(end)  ************** 

***************   Case 587   ***************

SQL: (select (select 1)) union (select (select 1)); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |2        |1   |
|1 | EXPRESSION         |    |1        |1   |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([?]), filter(nil)
      values({?})

*************** Case 587(end)  ************** 

***************   Case 588   ***************

SQL: (select (select c1 from t1) from  t2 order by ((select c1 from t1))) union (select 1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |MERGE UNION DISTINCT      |        |301      |1227|
|1 | SUBPLAN FILTER           |        |300      |1222|
|2 |  SUBPLAN FILTER          |        |300      |751 |
|3 |   PX COORDINATOR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR    |:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR|        |300      |233 |
|6 |      TABLE SCAN          |t2      |300      |233 |
|7 |   PX COORDINATOR         |        |500      |466 |
|8 |    EXCHANGE OUT DISTR    |:EX20000|500      |439 |
|9 |     PX PARTITION ITERATOR|        |500      |387 |
|10|      TABLE SCAN          |t1      |500      |387 |
|11|  PX COORDINATOR          |        |500      |466 |
|12|   EXCHANGE OUT DISTR     |:EX30000|500      |439 |
|13|    PX PARTITION ITERATOR |        |500      |387 |
|14|     TABLE SCAN           |t1      |500      |387 |
|15| EXPRESSION               |        |1        |1   |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), BIGINT(20, 0))]), init_plan_idxs_(nil)
  2 - output(nil), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), dop=1
  5 - output(nil), filter(nil), 
      force partition granule.
  6 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil)
  8 - output([t1.c1]), filter(nil), dop=1
  9 - output([t1.c1]), filter(nil), 
      force partition granule.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([t1.c1]), filter(nil)
  12 - output([t1.c1]), filter(nil), dop=1
  13 - output([t1.c1]), filter(nil), 
      force partition granule.
  14 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  15 - output([?]), filter(nil)
      values({?})

*************** Case 588(end)  ************** 

***************   Case 589   ***************

SQL: (select (select c1 from t1) from  t2) union (select 1)  order by (select c1 from t1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SUBPLAN FILTER            |        |301      |1227|
|1 | MERGE UNION DISTINCT     |        |301      |756 |
|2 |  SUBPLAN FILTER          |        |300      |751 |
|3 |   PX COORDINATOR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR    |:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR|        |300      |233 |
|6 |      TABLE SCAN          |t2      |300      |233 |
|7 |   PX COORDINATOR         |        |500      |466 |
|8 |    EXCHANGE OUT DISTR    |:EX20000|500      |439 |
|9 |     PX PARTITION ITERATOR|        |500      |387 |
|10|      TABLE SCAN          |t1      |500      |387 |
|11|  EXPRESSION              |        |1        |1   |
|12| PX COORDINATOR           |        |500      |466 |
|13|  EXCHANGE OUT DISTR      |:EX30000|500      |439 |
|14|   PX PARTITION ITERATOR  |        |500      |387 |
|15|    TABLE SCAN            |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([UNION([1])]), filter(nil)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([cast(subquery(1), BIGINT(20, 0))]), init_plan_idxs_(nil)
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), dop=1
  5 - output(nil), filter(nil), 
      force partition granule.
  6 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1]), filter(nil)
  8 - output([t1.c1]), filter(nil), dop=1
  9 - output([t1.c1]), filter(nil), 
      force partition granule.
  10 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([?]), filter(nil)
      values({?})
  12 - output([t1.c1]), filter(nil)
  13 - output([t1.c1]), filter(nil), dop=1
  14 - output([t1.c1]), filter(nil), 
      force partition granule.
  15 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 589(end)  ************** 

***************   Case 590   ***************

SQL: (select c1 from t1) union (select c2 from t1) union (select c2 from t2); 

===========================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST|
-----------------------------------------------------------
|0 |HASH DISTINCT            |             |1        |1545|
|1 | UNION ALL               |             |1300     |1234|
|2 |  PX COORDINATOR         |             |500      |466 |
|3 |   EXCHANGE OUT DISTR    |:EX10000     |500      |439 |
|4 |    PX PARTITION ITERATOR|             |500      |387 |
|5 |     TABLE SCAN          |t1           |500      |387 |
|6 |  PX COORDINATOR         |             |500      |466 |
|7 |   EXCHANGE OUT DISTR    |:EX20000     |500      |439 |
|8 |    PX PARTITION ITERATOR|             |500      |387 |
|9 |     TABLE SCAN          |t1(idx_t1_c2)|500      |387 |
|10|  PX COORDINATOR         |             |300      |280 |
|11|   EXCHANGE OUT DISTR    |:EX30000     |300      |263 |
|12|    PX PARTITION ITERATOR|             |300      |233 |
|13|     TABLE SCAN          |t2           |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil), 
      distinct([UNION([1])])
  1 - output([UNION([1])]), filter(nil)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t1.c2]), filter(nil)
  7 - output([t1.c2]), filter(nil), dop=1
  8 - output([t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true
  10 - output([t2.c2]), filter(nil)
  11 - output([t2.c2]), filter(nil), dop=1
  12 - output([t2.c2]), filter(nil), 
      force partition granule.
  13 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 590(end)  ************** 

***************   Case 591   ***************

SQL: (select c1 from t1) union (select 1); 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH UNION DISTINCT     |        |501      |691 |
|1 | PX COORDINATOR         |        |500      |466 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|3 |   PX PARTITION ITERATOR|        |500      |387 |
|4 |    TABLE SCAN          |t1      |500      |387 |
|5 | EXPRESSION             |        |1        |1   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([cast(t1.c1, BIGINT(20, 0))]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([?]), filter(nil)
      values({?})

*************** Case 591(end)  ************** 

***************   Case 592   ***************

SQL: (select a from t12) union (select 1); 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |MERGE UNION DISTINCT|    |101      |80  |
|1 | TABLE SCAN         |t12 |100      |78  |
|2 | EXPRESSION         |    |1        |1   |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t12.a]), filter(nil), 
      access([t12.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil)
      values({?})

*************** Case 592(end)  ************** 

***************   Case 593   ***************

SQL: (select pk1 from set_t1) union distinct (select pk2 from set_t2); 

===============================================
|ID|OPERATOR            |NAME  |EST. ROWS|COST|
-----------------------------------------------
|0 |MERGE UNION DISTINCT|      |200      |159 |
|1 | TABLE SCAN         |set_t1|100      |78  |
|2 | TABLE SCAN         |set_t2|100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([set_t1.pk1]), filter(nil), 
      access([set_t1.pk1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.pk2]), filter(nil), 
      access([set_t2.pk2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 593(end)  ************** 

***************   Case 594   ***************

SQL: (select pk1 from set_t1) union all (select pk2 from set_t2); 

======================================
|ID|OPERATOR   |NAME  |EST. ROWS|COST|
--------------------------------------
|0 |UNION ALL  |      |200      |159 |
|1 | TABLE SCAN|set_t1|100      |78  |
|2 | TABLE SCAN|set_t2|100      |78  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([set_t1.pk1]), filter(nil), 
      access([set_t1.pk1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.pk2]), filter(nil), 
      access([set_t2.pk2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 594(end)  ************** 

***************   Case 595   ***************

SQL: (select pk1 from set_t1) except (select pk2 from set_t2); 

================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST|
------------------------------------------------
|0 |MERGE EXCEPT DISTINCT|      |100      |159 |
|1 | TABLE SCAN          |set_t1|100      |78  |
|2 | TABLE SCAN          |set_t2|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([EXCEPT([1])]), filter(nil)
  1 - output([set_t1.pk1]), filter(nil), 
      access([set_t1.pk1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.pk2]), filter(nil), 
      access([set_t2.pk2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 595(end)  ************** 

***************   Case 596   ***************

SQL: (select pk1 from set_t1) intersect (select pk2 from set_t2); 

===================================================
|ID|OPERATOR                |NAME  |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE INTERSECT DISTINCT|      |100      |159 |
|1 | TABLE SCAN             |set_t1|100      |78  |
|2 | TABLE SCAN             |set_t2|100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil)
  1 - output([set_t1.pk1]), filter(nil), 
      access([set_t1.pk1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.pk2]), filter(nil), 
      access([set_t2.pk2]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 596(end)  ************** 

***************   Case 597   ***************

SQL: (select a2, a1 from set_t1) union distinct (select b2, b1 from set_t2); 

==============================================
|ID|OPERATOR           |NAME  |EST. ROWS|COST|
----------------------------------------------
|0 |HASH UNION DISTINCT|      |200      |249 |
|1 | TABLE SCAN        |set_t1|100      |78  |
|2 | TABLE SCAN        |set_t2|100      |78  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 597(end)  ************** 

***************   Case 598   ***************

SQL: (select a2, a1 from set_t1) union all (select b2, b1 from set_t2); 

======================================
|ID|OPERATOR   |NAME  |EST. ROWS|COST|
--------------------------------------
|0 |UNION ALL  |      |200      |159 |
|1 | TABLE SCAN|set_t1|100      |78  |
|2 | TABLE SCAN|set_t2|100      |78  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 598(end)  ************** 

***************   Case 599   ***************

SQL: (select a2, a1 from set_t1) except (select b2, b1 from set_t2); 

===============================================
|ID|OPERATOR            |NAME  |EST. ROWS|COST|
-----------------------------------------------
|0 |HASH EXCEPT DISTINCT|      |100      |249 |
|1 | TABLE SCAN         |set_t1|100      |78  |
|2 | TABLE SCAN         |set_t2|100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([EXCEPT([1])], [EXCEPT([2])]), filter(nil)
  1 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 599(end)  ************** 

***************   Case 600   ***************

SQL: (select a2, a1 from set_t1) intersect (select b2, b1 from set_t2); 

==================================================
|ID|OPERATOR               |NAME  |EST. ROWS|COST|
--------------------------------------------------
|0 |HASH INTERSECT DISTINCT|      |100      |228 |
|1 | TABLE SCAN            |set_t1|100      |78  |
|2 | TABLE SCAN            |set_t2|100      |78  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])], [INTERSECT([2])]), filter(nil)
  1 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  2 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 600(end)  ************** 

***************   Case 601   ***************

SQL: (select a2, a1 from set_t1) union distinct (select b2, b1 from set_t2) order by a2 desc; 

===============================================
|ID|OPERATOR            |NAME  |EST. ROWS|COST|
-----------------------------------------------
|0 |SORT                |      |200      |376 |
|1 | HASH UNION DISTINCT|      |200      |249 |
|2 |  TABLE SCAN        |set_t1|100      |78  |
|3 |  TABLE SCAN        |set_t2|100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), sort_keys([UNION([1]), DESC])
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  3 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 601(end)  ************** 

***************   Case 602   ***************

SQL: (select a2, a1 from set_t1) union all (select b2, b1 from set_t2) order by a2 desc; 

=======================================
|ID|OPERATOR    |NAME  |EST. ROWS|COST|
---------------------------------------
|0 |SORT        |      |200      |286 |
|1 | UNION ALL  |      |200      |159 |
|2 |  TABLE SCAN|set_t1|100      |78  |
|3 |  TABLE SCAN|set_t2|100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil), sort_keys([UNION([1]), DESC])
  1 - output([UNION([1])], [UNION([2])]), filter(nil)
  2 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  3 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 602(end)  ************** 

***************   Case 603   ***************

SQL: (select a2, a1 from set_t1) except (select b2, b1 from set_t2) order by a2 desc; 

================================================
|ID|OPERATOR             |NAME  |EST. ROWS|COST|
------------------------------------------------
|0 |SORT                 |      |100      |304 |
|1 | HASH EXCEPT DISTINCT|      |100      |249 |
|2 |  TABLE SCAN         |set_t1|100      |78  |
|3 |  TABLE SCAN         |set_t2|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([EXCEPT([1])], [EXCEPT([2])]), filter(nil), sort_keys([EXCEPT([1]), DESC])
  1 - output([EXCEPT([1])], [EXCEPT([2])]), filter(nil)
  2 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  3 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 603(end)  ************** 

***************   Case 604   ***************

SQL: (select a2, a1 from set_t1) intersect (select b2, b1 from set_t2) order by a2 desc; 

===================================================
|ID|OPERATOR                |NAME  |EST. ROWS|COST|
---------------------------------------------------
|0 |SORT                    |      |100      |283 |
|1 | HASH INTERSECT DISTINCT|      |100      |228 |
|2 |  TABLE SCAN            |set_t1|100      |78  |
|3 |  TABLE SCAN            |set_t2|100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])], [INTERSECT([2])]), filter(nil), sort_keys([INTERSECT([1]), DESC])
  1 - output([INTERSECT([1])], [INTERSECT([2])]), filter(nil)
  2 - output([set_t1.a2], [set_t1.a1]), filter(nil), 
      access([set_t1.a2], [set_t1.a1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t1.pk1]), range(MIN ; MAX)always true
  3 - output([set_t2.b2], [set_t2.b1]), filter(nil), 
      access([set_t2.b2], [set_t2.b1]), partitions(p0), 
      is_index_back=false, 
      range_key([set_t2.pk2]), range(MIN ; MAX)always true

*************** Case 604(end)  ************** 

***************   Case 605   ***************

SQL: (select c1 from t15) union all (select c1 from t14) union select 7; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |HASH UNION DISTINCT      |        |901      |1259|
|1 | EXPRESSION              |        |1        |1   |
|2 | UNION ALL               |        |900      |855 |
|3 |  PX COORDINATOR         |        |400      |373 |
|4 |   EXCHANGE OUT DISTR    |:EX10000|400      |351 |
|5 |    PX PARTITION ITERATOR|        |400      |310 |
|6 |     TABLE SCAN          |t15     |400      |310 |
|7 |  PX COORDINATOR         |        |500      |466 |
|8 |   EXCHANGE OUT DISTR    |:EX20000|500      |439 |
|9 |    PX PARTITION ITERATOR|        |500      |387 |
|10|     TABLE SCAN          |t14     |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([?]), filter(nil)
      values({?})
  2 - output([cast(UNION([1]), BIGINT(20, 0))]), filter(nil)
  3 - output([t15.c1]), filter(nil)
  4 - output([t15.c1]), filter(nil), dop=1
  5 - output([t15.c1]), filter(nil), 
      force partition granule.
  6 - output([t15.c1]), filter(nil), 
      access([t15.c1]), partitions(p[0-3]), 
      is_index_back=false, 
      range_key([t15.__pk_increment], [t15.__pk_cluster_id], [t15.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  7 - output([t14.c1]), filter(nil)
  8 - output([t14.c1]), filter(nil), dop=1
  9 - output([t14.c1]), filter(nil), 
      force partition granule.
  10 - output([t14.c1]), filter(nil), 
      access([t14.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t14.c1], [t14.c2], [t14.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 605(end)  ************** 

***************   Case 606   ***************

SQL: select 1 from t1,t2 order by t1.c2+t2.c2; 

==========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST  |
----------------------------------------------------------
|0 |SORT                       |        |150000   |218193|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |8483  |
|2 |  PX COORDINATOR           |        |300      |280   |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |263   |
|4 |    PX PARTITION ITERATOR  |        |300      |233   |
|5 |     TABLE SCAN            |t2      |300      |233   |
|6 |  MATERIAL                 |        |500      |468   |
|7 |   PX COORDINATOR          |        |500      |466   |
|8 |    EXCHANGE OUT DISTR     |:EX20000|500      |439   |
|9 |     PX PARTITION ITERATOR |        |500      |387   |
|10|      TABLE SCAN           |t1      |500      |387   |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), sort_keys([t1.c2 + t2.c2, ASC])
  1 - output([t2.c2], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t2.c2]), filter(nil)
  3 - output([t2.c2]), filter(nil), dop=1
  4 - output([t2.c2]), filter(nil), 
      force partition granule.
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t1.c2]), filter(nil)
  7 - output([t1.c2]), filter(nil)
  8 - output([t1.c2]), filter(nil), dop=1
  9 - output([t1.c2]), filter(nil), 
      force partition granule.
  10 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 606(end)  ************** 

***************   Case 607   ***************

SQL: select 'a', c1 from t1 union select 'b', c1 from t7; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |600      |853 |
|1 | EXCHANGE OUT DISTR          |:EX10001|600      |820 |
|2 |  HASH UNION DISTINCT        |        |600      |758 |
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |100      |94  |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |88  |
|7 |     TABLE SCAN              |t7      |100      |78  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(UNION([1]), UNION([2]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(UNION([1]), UNION([2]))]), filter(nil), dop=1
  2 - output([UNION([1])], [UNION([2])]), filter(nil)
  3 - output([?], [t1.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([?], [t7.c1]), filter(nil)
  6 - (#keys=1, [t7.c1]), output([t7.c1]), filter(nil), is_single, dop=1
  7 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 607(end)  ************** 

***************   Case 608   ***************

SQL: SELECT b FROM t13 WHERE b=1 UNION SELECT b FROM t13 WHERE b=1; 

============================================
|ID|OPERATOR           |NAME|EST. ROWS|COST|
--------------------------------------------
|0 |HASH UNION DISTINCT|    |1        |158 |
|1 | TABLE SCAN        |t13 |1        |79  |
|2 | TABLE SCAN        |t13 |1        |79  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])]), filter(nil)
  1 - output([t13.b]), filter([cast(t13.b, DECIMAL(-1, -1)) = ?]), 
      access([t13.b]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t13.a]), range(MIN ; MAX)always true
  2 - output([t13.b]), filter([cast(t13.b, DECIMAL(-1, -1)) = ?]), 
      access([t13.b]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 608(end)  ************** 

***************   Case 609   ***************

SQL: select * from t7, t8 where (t7.c1, t7.c2) = (t8.c1, t8.c2); 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |82       |184 |
|1 | TABLE SCAN|t7  |100      |78  |
|2 | TABLE SCAN|t8  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1], [t7.c2 = t8.c2]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 609(end)  ************** 

***************   Case 610   ***************

SQL: select * from t7 inner join t8 on (t7.c1, t7.c2) = (t8.c1, t8.c2); 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |82       |184 |
|1 | TABLE SCAN|t7  |100      |78  |
|2 | TABLE SCAN|t8  |100      |78  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c1 = t8.c1], [t7.c2 = t8.c2]), other_conds(nil)
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 610(end)  ************** 

***************   Case 611   ***************

SQL: select * from t7, t8 where (t7.c1, t7.c2) > (t8.c1, t8.c2); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |3334     |1635|
|1 | TABLE SCAN     |t7  |100      |78  |
|2 | MATERIAL       |    |100      |79  |
|3 |  TABLE SCAN    |t8  |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds([(t7.c1, t7.c2) > (t8.c1, t8.c2)]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil)
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 611(end)  ************** 

***************   Case 612   ***************

SQL: select * from t7 inner join t8 on (t7.c1, t7.c2) <= (t8.c1, t8.c2); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |3334     |1635|
|1 | TABLE SCAN     |t7  |100      |78  |
|2 | MATERIAL       |    |100      |79  |
|3 |  TABLE SCAN    |t8  |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds([(t7.c1, t7.c2) <= (t8.c1, t8.c2)]), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil)
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 612(end)  ************** 

***************   Case 613   ***************

SQL: select distinct c1+@var from t1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |500      |960 |
|1 | EXCHANGE OUT DISTR            |:EX10001|500      |933 |
|2 |  MERGE DISTINCT               |        |500      |881 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |858 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|500      |830 |
|5 |     MERGE DISTINCT            |        |500      |779 |
|6 |      SORT                     |        |500      |756 |
|7 |       PX PARTITION ITERATOR   |        |500      |387 |
|8 |        TABLE SCAN             |t1      |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(cast(t1.c1, DOUBLE(-1, -1)) + ?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(cast(t1.c1, DOUBLE(-1, -1)) + ?)]), filter(nil), dop=1
  2 - output([cast(t1.c1, DOUBLE(-1, -1)) + ?]), filter(nil), 
      distinct([cast(t1.c1, DOUBLE(-1, -1)) + ?])
  3 - output([cast(t1.c1, DOUBLE(-1, -1)) + ?]), filter(nil), sort_keys([cast(t1.c1, DOUBLE(-1, -1)) + ?, ASC])
  4 - (#keys=1, [cast(t1.c1, DOUBLE(-1, -1)) + ?]), output([cast(t1.c1, DOUBLE(-1, -1)) + ?]), filter(nil), dop=1
  5 - output([cast(t1.c1, DOUBLE(-1, -1)) + ?]), filter(nil), 
      distinct([cast(t1.c1, DOUBLE(-1, -1)) + ?])
  6 - output([cast(t1.c1, DOUBLE(-1, -1)) + ?]), filter(nil), sort_keys([cast(t1.c1, DOUBLE(-1, -1)) + ?, ASC])
  7 - output([t1.c1]), filter(nil), 
      force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 613(end)  ************** 

***************   Case 614   ***************

SQL: select distinct c1+(@a:=c2) from t1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |500      |1089|
|1 | EXCHANGE OUT DISTR            |:EX10001|500      |1042|
|2 |  MERGE DISTINCT               |        |500      |948 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |923 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|500      |877 |
|5 |     MERGE DISTINCT            |        |500      |783 |
|6 |      SORT                     |        |500      |758 |
|7 |       PX PARTITION ITERATOR   |        |500      |387 |
|8 |        TABLE SCAN             |t1      |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1 + (T_OP_ASSIGN, 'a', t1.c2))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1 + (T_OP_ASSIGN, 'a', t1.c2))]), filter(nil), dop=1
  2 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), 
      distinct([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)])
  3 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), sort_keys([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2), ASC])
  4 - (#keys=1, [t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), dop=1
  5 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), 
      distinct([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)])
  6 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), sort_keys([t1.c1 + (T_OP_ASSIGN, 'a', t1.c2), ASC])
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 614(end)  ************** 

***************   Case 615   ***************

SQL: select distinct c1+(@a:=c1) from t1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |500      |960 |
|1 | EXCHANGE OUT DISTR            |:EX10001|500      |933 |
|2 |  MERGE DISTINCT               |        |500      |881 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |500      |858 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|500      |830 |
|5 |     MERGE DISTINCT            |        |500      |779 |
|6 |      SORT                     |        |500      |756 |
|7 |       PX PARTITION ITERATOR   |        |500      |387 |
|8 |        TABLE SCAN             |t1      |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1 + (T_OP_ASSIGN, 'a', t1.c1))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1 + (T_OP_ASSIGN, 'a', t1.c1))]), filter(nil), dop=1
  2 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil), 
      distinct([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)])
  3 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil), sort_keys([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1), ASC])
  4 - (#keys=1, [t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil), dop=1
  5 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil), 
      distinct([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)])
  6 - output([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1)]), filter(nil), sort_keys([t1.c1 + (T_OP_ASSIGN, 'a', t1.c1), ASC])
  7 - output([t1.c1]), filter(nil), 
      force partition granule.
  8 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 615(end)  ************** 

***************   Case 616   ***************

SQL: select distinct c2+(@a:=c2) from t1; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |604 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |599 |
|2 |  HASH DISTINCT              |        |100      |588 |
|3 |   EXCHANGE IN DISTR         |        |100      |544 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|100      |538 |
|5 |     HASH DISTINCT           |        |100      |528 |
|6 |      PX PARTITION ITERATOR  |        |500      |387 |
|7 |       TABLE SCAN            |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2 + (T_OP_ASSIGN, 'a', t1.c2))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2 + (T_OP_ASSIGN, 'a', t1.c2))]), filter(nil), dop=1
  2 - output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), 
      distinct([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)])
  3 - output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil)
  4 - (#keys=1, [t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), dop=1
  5 - output([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)]), filter(nil), 
      distinct([t1.c2 + (T_OP_ASSIGN, 'a', t1.c2)])
  6 - output([t1.c2]), filter(nil), 
      force partition granule.
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 616(end)  ************** 

***************   Case 617   ***************

SQL: select /*+use_merge(tt1 tt2)*/* from tt1,tt2 where tt1.c1=tt2.c1; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |266 |
|1 | TABLE SCAN |tt2 |100      |78  |
|2 | SORT       |    |100      |156 |
|3 |  TABLE SCAN|tt1 |100      |78  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), 
      equal_conds([cast(tt1.c1, VARCHAR(1048576)) = tt2.c1]), other_conds(nil)
  1 - output([tt2.c1], [tt2.c2]), filter(nil), 
      access([tt2.c1], [tt2.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([tt2.c1]), range(MIN ; MAX)always true
  2 - output([tt1.c1], [tt1.c2], [cast(tt1.c1, VARCHAR(1048576))]), filter(nil), sort_keys([cast(tt1.c1, VARCHAR(1048576)), ASC])
  3 - output([tt1.c1], [tt1.c2]), filter(nil), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 617(end)  ************** 

***************   Case 618   ***************

SQL: select /*+use_merge(tt1 tt2)*/* from tt1,tt2 where tt1.c2=tt2.c2; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |113      |347 |
|1 | SORT       |    |100      |156 |
|2 |  TABLE SCAN|tt2 |100      |78  |
|3 | SORT       |    |100      |156 |
|4 |  TABLE SCAN|tt1 |100      |78  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), 
      equal_conds([cast(tt1.c2, VARCHAR(1048576)) = tt2.c2]), other_conds(nil)
  1 - output([tt2.c1], [tt2.c2]), filter(nil), sort_keys([tt2.c2, ASC])
  2 - output([tt2.c1], [tt2.c2]), filter(nil), 
      access([tt2.c1], [tt2.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([tt2.c1]), range(MIN ; MAX)always true
  3 - output([tt1.c1], [tt1.c2], [cast(tt1.c2, VARCHAR(1048576))]), filter(nil), sort_keys([cast(tt1.c2, VARCHAR(1048576)), ASC])
  4 - output([tt1.c1], [tt1.c2]), filter(nil), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 618(end)  ************** 

***************   Case 619   ***************

SQL: select /*+use_merge(t1, t2)*/* from t1,t2 where t1.c1=t2.c3; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |MERGE JOIN                 |        |300      |1572|
|1 | PX COORDINATOR MERGE SORT |        |300      |641 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|300      |567 |
|3 |   SORT                    |        |300      |409 |
|4 |    PX PARTITION ITERATOR  |        |300      |233 |
|5 |     TABLE SCAN            |t2      |300      |233 |
|6 | PX COORDINATOR MERGE SORT |        |500      |839 |
|7 |  EXCHANGE OUT DISTR       |:EX20000|500      |792 |
|8 |   SORT                    |        |500      |698 |
|9 |    PX PARTITION ITERATOR  |        |500      |387 |
|10|     TABLE SCAN            |t1      |500      |387 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([cast(t1.c1, DECIMAL(11, 0)) = cast(t2.c3, DECIMAL(-1, -1))]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3], [cast(t2.c3, DECIMAL(-1, -1))]), filter(nil), sort_keys([cast(t2.c3, DECIMAL(-1, -1)), ASC])
  2 - output([t2.c1], [t2.c2], [t2.c3], [cast(t2.c3, DECIMAL(-1, -1))]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3], [cast(t2.c3, DECIMAL(-1, -1))]), filter(nil), sort_keys([cast(t2.c3, DECIMAL(-1, -1)), ASC])
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule.
  5 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t1.c1], [t1.c2], [cast(t1.c1, DECIMAL(11, 0))]), filter(nil), sort_keys([cast(t1.c1, DECIMAL(11, 0)), ASC])
  7 - output([t1.c1], [t1.c2], [cast(t1.c1, DECIMAL(11, 0))]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2], [cast(t1.c1, DECIMAL(11, 0))]), filter(nil), sort_keys([cast(t1.c1, DECIMAL(11, 0)), ASC])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 619(end)  ************** 

***************   Case 620   ***************

SQL: select /*+use_merge(t1, t12)*/* from t1,t12 where t1.c1=t12.a; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |749 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |723 |
|2 |  MERGE JOIN                 |        |100      |666 |
|3 |   SORT                      |        |500      |490 |
|4 |    PX PARTITION ITERATOR    |        |500      |387 |
|5 |     TABLE SCAN              |t1      |500      |387 |
|6 |   EXCHANGE IN DISTR         |        |100      |137 |
|7 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|100      |118 |
|8 |     TABLE SCAN              |t12     |100      |78  |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t12.a, t12.b, t12.c)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t12.a, t12.b, t12.c)]), filter(nil), dop=1
  2 - output([t1.c1], [t12.a], [t1.c2], [t12.b], [t12.c]), filter(nil), 
      equal_conds([t1.c1 = t12.a]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t12.a], [t12.b], [t12.c]), filter(nil)
  7 - (#keys=1, [t12.a]), output([t12.a], [t12.b], [t12.c]), filter(nil), is_single, dop=1
  8 - output([t12.a], [t12.b], [t12.c]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true

*************** Case 620(end)  ************** 

***************   Case 621   ***************

SQL: select /*+use_merge(t1, t13)*/* from t1,t13 where t1.c1=t13.b; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |MERGE JOIN                 |        |100      |1003|
|1 | PX COORDINATOR MERGE SORT |        |500      |839 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|500      |792 |
|3 |   SORT                    |        |500      |698 |
|4 |    PX PARTITION ITERATOR  |        |500      |387 |
|5 |     TABLE SCAN            |t1      |500      |387 |
|6 | SORT                      |        |100      |125 |
|7 |  TABLE SCAN               |t13     |100      |78  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t13.b], [t13.c], [t13.a]), filter(nil), 
      equal_conds([cast(t1.c1, DECIMAL(11, 0)) = cast(t13.b, DECIMAL(-1, -1))]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [cast(t1.c1, DECIMAL(11, 0))]), filter(nil), sort_keys([cast(t1.c1, DECIMAL(11, 0)), ASC])
  2 - output([t1.c1], [t1.c2], [cast(t1.c1, DECIMAL(11, 0))]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [cast(t1.c1, DECIMAL(11, 0))]), filter(nil), sort_keys([cast(t1.c1, DECIMAL(11, 0)), ASC])
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t13.b], [t13.c], [t13.a], [cast(t13.b, DECIMAL(-1, -1))]), filter(nil), sort_keys([cast(t13.b, DECIMAL(-1, -1)), ASC])
  7 - output([t13.a], [t13.b], [t13.c]), filter(nil), 
      access([t13.a], [t13.b], [t13.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 621(end)  ************** 

***************   Case 622   ***************

SQL: select /*+use_merge(t1, t_u)*/* from t1,t_u where t1.c1=t_u.c1; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |MERGE JOIN                 |        |270      |1262|
|1 | PX COORDINATOR MERGE SORT |        |300      |483 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|300      |467 |
|3 |   SORT                    |        |300      |436 |
|4 |    PX PARTITION ITERATOR  |        |300      |233 |
|5 |     TABLE SCAN            |t_u     |300      |233 |
|6 | PX COORDINATOR MERGE SORT |        |500      |631 |
|7 |  EXCHANGE OUT DISTR       |:EX20000|500      |584 |
|8 |   SORT                    |        |500      |490 |
|9 |    PX PARTITION ITERATOR  |        |500      |387 |
|10|     TABLE SCAN            |t1      |500      |387 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t_u.c1]), filter(nil), 
      equal_conds([t1.c1 = t_u.c1]), other_conds(nil)
  1 - output([t_u.c1]), filter(nil), sort_keys([t_u.c1, ASC])
  2 - output([t_u.c1]), filter(nil), dop=1
  3 - output([t_u.c1]), filter(nil), sort_keys([t_u.c1, ASC])
  4 - output([t_u.c1]), filter(nil), 
      force partition granule.
  5 - output([t_u.c1]), filter(nil), 
      access([t_u.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t_u.__pk_increment], [t_u.__pk_cluster_id], [t_u.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  6 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC])
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 622(end)  ************** 

***************   Case 623   ***************

SQL: select /*+use_merge(t_u, t12)*/* from t_u,t12 where t12.a=t_u.c1; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |MERGE JOIN                 |        |271      |633 |
|1 | PX COORDINATOR MERGE SORT |        |300      |483 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|300      |467 |
|3 |   SORT                    |        |300      |436 |
|4 |    PX PARTITION ITERATOR  |        |300      |233 |
|5 |     TABLE SCAN            |t_u     |300      |233 |
|6 | TABLE SCAN                |t12     |100      |78  |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_u.c1], [t12.a], [t12.b], [t12.c]), filter(nil), 
      equal_conds([t12.a = t_u.c1]), other_conds(nil)
  1 - output([t_u.c1]), filter(nil), sort_keys([t_u.c1, ASC])
  2 - output([t_u.c1]), filter(nil), dop=1
  3 - output([t_u.c1]), filter(nil), sort_keys([t_u.c1, ASC])
  4 - output([t_u.c1]), filter(nil), 
      force partition granule.
  5 - output([t_u.c1]), filter(nil), 
      access([t_u.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t_u.__pk_increment], [t_u.__pk_cluster_id], [t_u.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  6 - output([t12.a], [t12.b], [t12.c]), filter(nil), 
      access([t12.a], [t12.b], [t12.c]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true

*************** Case 623(end)  ************** 

***************   Case 624   ***************

SQL: select /*+use_merge(t2, t3)*/* from t2,t3 where t2.c3=t3.c3; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |MERGE JOIN                 |        |487      |1397|
|1 | PX COORDINATOR MERGE SORT |        |300      |756 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|300      |682 |
|3 |   SORT                    |        |300      |524 |
|4 |    PX PARTITION ITERATOR  |        |300      |233 |
|5 |     TABLE SCAN            |t2      |300      |233 |
|6 | PX COORDINATOR MERGE SORT |        |200      |491 |
|7 |  EXCHANGE OUT DISTR       |:EX20000|200      |442 |
|8 |   SORT                    |        |200      |336 |
|9 |    PX PARTITION ITERATOR  |        |200      |155 |
|10|     TABLE SCAN            |t3      |200      |155 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c3, ASC])
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c3, ASC])
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule.
  5 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c3, ASC])
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), sort_keys([t3.c3, ASC])
  9 - output([t3.c1], [t3.c3], [t3.c2]), filter(nil), 
      force partition granule.
  10 - output([t3.c1], [t3.c3], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c3], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 624(end)  ************** 

***************   Case 625   ***************

SQL: select * from yuming where c2 in ('-99999.99999','0.0'); 

=====================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST|
-------------------------------------
|0 |TABLE SCAN|yuming|18       |80  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([yuming.c1], [yuming.c2]), filter([cast(yuming.c2, DOUBLE(-1, -1)) IN (?, ?)]), 
      access([yuming.c1], [yuming.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([yuming.c1], [yuming.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 625(end)  ************** 

***************   Case 626   ***************

SQL: select * from query_range where (c1, c2, c3) in ((1, 2, 3), (4, 5, 6)); 

=========================================
|ID|OPERATOR |NAME       |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE GET|query_range|2        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter(nil), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range[1,2,3 ; 1,2,3], [4,5,6 ; 4,5,6], 
      range_cond([(query_range.c1, query_range.c2, query_range.c3) IN ((?, ?, ?), (?, ?, ?))])

*************** Case 626(end)  ************** 

***************   Case 627   ***************

SQL: select * from query_range where (c1, c2, c3) in ((1, 2, 3), (4, (select 5), 6)); 

=========================================
|ID|OPERATOR |NAME       |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE GET|query_range|2        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter(nil), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range[1,2,3 ; 1,2,3], [4,5,6 ; 4,5,6], 
      range_cond([(query_range.c1, query_range.c2, query_range.c3) IN ((?, ?, ?), (?, ?, ?))])

*************** Case 627(end)  ************** 

***************   Case 628   ***************

SQL: select * from query_range where (c1, c2, c3) in (((select 1), 2, 3), ((select 4), 5, 6)); 

=========================================
|ID|OPERATOR |NAME       |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE GET|query_range|2        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter(nil), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range[1,2,3 ; 1,2,3], [4,5,6 ; 4,5,6], 
      range_cond([(query_range.c1, query_range.c2, query_range.c3) IN ((?, ?, ?), (?, ?, ?))])

*************** Case 628(end)  ************** 

***************   Case 629   ***************

SQL: select * from query_range where (c1, c2, c3) in ((1, 2, 3), (4, 5, 6)) and c4>0; 

=========================================
|ID|OPERATOR |NAME       |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE GET|query_range|2        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter([query_range.c4 > ?]), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range[1,2,3 ; 1,2,3], [4,5,6 ; 4,5,6], 
      range_cond([(query_range.c1, query_range.c2, query_range.c3) IN ((?, ?, ?), (?, ?, ?))])

*************** Case 629(end)  ************** 

***************   Case 630   ***************

SQL: select * from query_range where c1=1 and (c2, c3) in ((1, 2), (3, 4)); 

=========================================
|ID|OPERATOR |NAME       |EST. ROWS|COST|
-----------------------------------------
|0 |TABLE GET|query_range|1        |46  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter([(query_range.c2, query_range.c3) IN ((?, ?), (?, ?))]), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range[1,1,2 ; 1,1,2], [1,3,4 ; 1,3,4], 
      range_cond([query_range.c1 = ?])

*************** Case 630(end)  ************** 

***************   Case 631   ***************

SQL: select * from query_range where c1>1 and (c2, c3) in ((1, 2), (3, 4)); 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|query_range|2        |80  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter([(query_range.c2, query_range.c3) IN ((?, ?), (?, ?))]), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range(1,MAX,MAX ; MAX,3,4), 
      range_cond([query_range.c1 > ?])

*************** Case 631(end)  ************** 

***************   Case 632   ***************

SQL: select c2 from t4 where c2=1 and c3 is null group by c2; 

===================================================
|ID|OPERATOR      |NAME            |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE GROUP BY|                |1        |80  |
|1 | TABLE SCAN   |t4(idx_t4_c2_c3)|100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c2]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t4.c2]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(1,NULL,MIN ; 1,NULL,MAX), 
      range_cond([t4.c2 = ?], [(T_OP_IS, t4.c3, NULL, 0)])

*************** Case 632(end)  ************** 

***************   Case 633   ***************

SQL: select count(1) as c from t7 having (select c from t7 t)>0; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |161 |
|1 | SCALAR GROUP BY|    |1        |81  |
|2 |  TABLE SCAN    |t7  |100      |78  |
|3 | TABLE SCAN     |t   |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter([subquery(1) > ?]), 
      exec_params_([T_FUN_COUNT(*)]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  2 - output(nil), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 633(end)  ************** 

***************   Case 634   ***************

SQL: SELECT t1.c1 FROM t7 t1 GROUP BY t1.c1 HAVING t1.c1 < ALL(SELECT t2.c1 FROM t7 t2 GROUP BY t2.c1 HAVING EXISTS(SELECT t3.c1 FROM t7 t3 GROUP BY t3.c1 HAVING SUM(t1.c1+t2.c1) < t3.c1/4)); 

===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |89       |9350|
|1 | TABLE SCAN          |t1   |100      |78  |
|2 | SUBPLAN SCAN        |VIEW2|1        |92  |
|3 |  NESTED-LOOP JOIN   |     |1        |92  |
|4 |   TABLE SCAN        |t3   |1        |46  |
|5 |   MATERIAL          |     |34       |47  |
|6 |    TABLE SCAN       |t2   |34       |46  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil), 
      access(nil)
  3 - output([t2.c1], [t3.c1]), filter(nil), 
      conds([cast(? + t2.c1, DECIMAL(12, 0)) < cast(t3.c1, DECIMAL(11, 0)) / ?]), nl_params_(nil), batch_join=false
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([? >= t2.c1])

*************** Case 634(end)  ************** 

***************   Case 635   ***************

SQL: select count(1) from t_func group by c1,c2; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t_func  |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(1)]), filter(nil), dop=1
  2 - output(nil), filter(nil), 
      force partition granule.
  3 - output(nil), filter(nil), 
      access([t_func.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_func.c1], [t_func.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 635(end)  ************** 

***************   Case 636   ***************

SQL: select count(1) from t_func group by c1; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR                 |        |100      |493 |
|1 | EXCHANGE OUT DISTR            |:EX10001|100      |480 |
|2 |  MERGE GROUP BY               |        |100      |453 |
|3 |   EXCHANGE IN MERGE SORT DISTR|        |100      |446 |
|4 |    EXCHANGE OUT DISTR (HASH)  |:EX10000|100      |437 |
|5 |     PX PARTITION ITERATOR     |        |100      |418 |
|6 |      MERGE GROUP BY           |        |100      |418 |
|7 |       TABLE SCAN              |t_func  |500      |387 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(*)))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT_SUM(T_FUN_COUNT(*)))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group([t_func.c1]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  3 - output([T_FUN_COUNT(*)], [t_func.c1]), filter(nil), sort_keys([t_func.c1, ASC]), Local Order
  4 - (#keys=1, [t_func.c1]), output([T_FUN_COUNT(*)], [t_func.c1]), filter(nil), dop=1
  5 - output([T_FUN_COUNT(*)], [t_func.c1]), filter(nil), 
      force partition granule.
  6 - output([T_FUN_COUNT(*)], [t_func.c1]), filter(nil), 
      group([t_func.c1]), agg_func([T_FUN_COUNT(*)])
  7 - output([t_func.c1]), filter(nil), 
      access([t_func.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_func.c1], [t_func.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 636(end)  ************** 

***************   Case 637   ***************

SQL: select count(1) from t_func group by floor(c2+c1); 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |824 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |759 |
|2 |  PX PARTITION ITERATOR|        |500      |622 |
|3 |   HASH GROUP BY       |        |500      |622 |
|4 |    TABLE SCAN         |t_func  |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(T_FUN_COUNT(*))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(T_FUN_COUNT(*))]), filter(nil), dop=1
  2 - output([T_FUN_COUNT(*)]), filter(nil), 
      partition wise, force partition granule.
  3 - output([T_FUN_COUNT(*)]), filter(nil), 
      group([floor(t_func.c2 + t_func.c1)]), agg_func([T_FUN_COUNT(*)])
  4 - output([t_func.c1], [t_func.c2]), filter(nil), 
      access([t_func.c1], [t_func.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_func.c1], [t_func.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 637(end)  ************** 

***************   Case 638   ***************

SQL: select distinct c1 from t_f; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |604 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |599 |
|2 |  HASH DISTINCT              |        |100      |588 |
|3 |   EXCHANGE IN DISTR         |        |100      |544 |
|4 |    EXCHANGE OUT DISTR (HASH)|:EX10000|100      |538 |
|5 |     HASH DISTINCT           |        |100      |528 |
|6 |      PX PARTITION ITERATOR  |        |500      |387 |
|7 |       TABLE SCAN            |t_f     |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_f.c1)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t_f.c1)]), filter(nil), dop=1
  2 - output([t_f.c1]), filter(nil), 
      distinct([t_f.c1])
  3 - output([t_f.c1]), filter(nil)
  4 - (#keys=1, [t_f.c1]), output([t_f.c1]), filter(nil), dop=1
  5 - output([t_f.c1]), filter(nil), 
      distinct([t_f.c1])
  6 - output([t_f.c1]), filter(nil), 
      force partition granule.
  7 - output([t_f.c1]), filter(nil), 
      access([t_f.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_f.__pk_increment], [t_f.__pk_cluster_id], [t_f.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 638(end)  ************** 

***************   Case 639   ***************

SQL: select distinct c1,c2 from t_f; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |761 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |715 |
|2 |  PX PARTITION ITERATOR|        |500      |621 |
|3 |   HASH DISTINCT       |        |500      |621 |
|4 |    TABLE SCAN         |t_f     |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_f.c1, t_f.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t_f.c1, t_f.c2)]), filter(nil), dop=1
  2 - output([t_f.c1], [t_f.c2]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t_f.c1], [t_f.c2]), filter(nil), 
      distinct([t_f.c1], [t_f.c2])
  4 - output([t_f.c2], [t_f.c1]), filter(nil), 
      access([t_f.c2], [t_f.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_f.__pk_increment], [t_f.__pk_cluster_id], [t_f.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 639(end)  ************** 

***************   Case 640   ***************

SQL: select distinct c1,c2,c3 from t_f; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |832 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |766 |
|2 |  PX PARTITION ITERATOR|        |500      |630 |
|3 |   HASH DISTINCT       |        |500      |630 |
|4 |    TABLE SCAN         |t_f     |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t_f.c1, t_f.c2, t_f.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t_f.c1, t_f.c2, t_f.c3)]), filter(nil), dop=1
  2 - output([t_f.c1], [t_f.c2], [t_f.c3]), filter(nil), 
      partition wise, force partition granule.
  3 - output([t_f.c1], [t_f.c2], [t_f.c3]), filter(nil), 
      distinct([t_f.c1], [t_f.c2], [t_f.c3])
  4 - output([t_f.c2], [t_f.c1], [t_f.c3]), filter(nil), 
      access([t_f.c2], [t_f.c1], [t_f.c3]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t_f.__pk_increment], [t_f.__pk_cluster_id], [t_f.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 640(end)  ************** 

***************   Case 641   ***************

SQL: select c1 from t7 group by c1 having (select count(t7.c1) from t7 t)>0; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |7991|
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t   |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([subquery(1) > ?]), 
      exec_params_([CASE WHEN (T_OP_IS_NOT, t7.c1, NULL, 0) THEN 1 ELSE 0 END]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 641(end)  ************** 

***************   Case 642   ***************

SQL: select c1 from t7 having (select t7.c1 from t7 t)>0; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |7991|
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t   |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([subquery(1) > ?]), 
      exec_params_([t7.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 642(end)  ************** 

***************   Case 643   ***************

SQL: select c1 from t7 group by c2 having (select t7.c1 from t7 t)>0; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |4        |895 |
|1 | HASH GROUP BY|    |10       |104 |
|2 |  TABLE SCAN  |t7  |100      |78  |
|3 | TABLE SCAN   |t   |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([subquery(1) > ?]), 
      exec_params_([t7.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 643(end)  ************** 

***************   Case 644   ***************

SQL: select /*+leading(b, a) use_nl(a, b) read_consistency(weak) query_timeout(120000000)*/ count(*) as COUNT, nvl(sum(b.receive_fee),0) as AMOUNT from trade_process_000 b, trade_base_000 a where a.trade_no = b.trade_no and b.gmt_receive_pay >= '2023-09-26 10:21:55' and b.gmt_receive_pay < '2023-09-26 15:55:15' and (a.product IN ('S','M','L') or a.product not IN ('M','L','XL'))and (a.trade_type IN ('S','FP','RM','MT') or a.trade_type not IN ('FP','RM','MT','COD')); 

=======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST |
-------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |32061|
|1 | PX COORDINATOR          |        |1        |32061|
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |32060|
|3 |   MERGE GROUP BY        |        |1        |32059|
|4 |    PX PARTITION ITERATOR|        |1        |32059|
|5 |     NESTED-LOOP JOIN    |        |1        |32059|
|6 |      TABLE SCAN         |b       |1        |32059|
|7 |      TABLE GET          |a       |1        |1737 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [nvl(T_FUN_SUM(T_FUN_SUM(b.RECEIVE_FEE)), ?)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [T_FUN_SUM(T_FUN_SUM(b.RECEIVE_FEE))])
  1 - output([T_FUN_COUNT(*)], [T_FUN_SUM(b.RECEIVE_FEE)]), filter(nil)
  2 - output([T_FUN_COUNT(*)], [T_FUN_SUM(b.RECEIVE_FEE)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(*)], [T_FUN_SUM(b.RECEIVE_FEE)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)], [T_FUN_SUM(b.RECEIVE_FEE)])
  4 - output([b.RECEIVE_FEE]), filter(nil), 
      partition wise, force partition granule.
  5 - output([b.RECEIVE_FEE]), filter(nil), 
      conds(nil), nl_params_([b.TRADE_NO]), batch_join=true
  6 - output([b.TRADE_NO], [b.RECEIVE_FEE]), filter([b.GMT_RECEIVE_PAY < ?], [b.GMT_RECEIVE_PAY >= ?]), 
      access([b.TRADE_NO], [b.GMT_RECEIVE_PAY], [b.RECEIVE_FEE]), partitions(p[0-399]), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([b.TRADE_NO]), range(MIN ; MAX)always true
  7 - output(nil), filter([a.TRADE_TYPE IN (?, ?, ?, ?) OR (T_OP_NOT_IN, a.TRADE_TYPE, (?, ?, ?, ?))], [a.PRODUCT IN (?, ?, ?) OR (T_OP_NOT_IN, a.PRODUCT, (?, ?, ?))]), 
      access([a.PRODUCT], [a.TRADE_TYPE]), partitions(p[0-399]), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([a.TRADE_NO]), range(MIN ; MAX), 
      range_cond([a.TRADE_NO = ?])

*************** Case 644(end)  ************** 

***************   Case 645   ***************

SQL: select * from t0, t0 t where t0.c1=t.c2 and t0.c1=t.c1 order by t0.c1, t.c1; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |SORT        |    |73       |223 |
|1 | HASH JOIN  |    |73       |184 |
|2 |  TABLE SCAN|t   |9        |80  |
|3 |  TABLE SCAN|t0  |100      |78  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3], [t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), sort_keys([t0.c1, ASC])
  1 - output([t0.c1], [t0.pk], [t0.c2], [t0.a3], [t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), 
      equal_conds([t0.c1 = t.c2]), other_conds(nil)
  2 - output([t.pk], [t.c2], [t.c1], [t.a3]), filter([t.c2 = t.c1]), 
      access([t.pk], [t.c2], [t.c1], [t.a3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t.pk]), range(MIN ; MAX)always true
  3 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3]), filter(nil), 
      access([t0.pk], [t0.c1], [t0.c2], [t0.a3]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 645(end)  ************** 

***************   Case 646   ***************

SQL: select * from t0, t0 t where t0.c1=t.c1 and t0.c1=t.c2 order by t0.c1, t.c1; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |SORT        |    |73       |223 |
|1 | HASH JOIN  |    |73       |184 |
|2 |  TABLE SCAN|t   |9        |80  |
|3 |  TABLE SCAN|t0  |100      |78  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3], [t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), sort_keys([t0.c1, ASC])
  1 - output([t0.c1], [t0.pk], [t0.c2], [t0.a3], [t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), 
      equal_conds([t0.c1 = t.c1]), other_conds(nil)
  2 - output([t.pk], [t.c1], [t.c2], [t.a3]), filter([t.c1 = t.c2]), 
      access([t.pk], [t.c1], [t.c2], [t.a3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t.pk]), range(MIN ; MAX)always true
  3 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3]), filter(nil), 
      access([t0.pk], [t0.c1], [t0.c2], [t0.a3]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 646(end)  ************** 

***************   Case 647   ***************

SQL: select * from t0, t0 t where t0.c1=t.c1 and t0.c1=t.c1 order by t0.c1, t.c1; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |SORT        |    |810      |867 |
|1 | HASH JOIN  |    |810      |204 |
|2 |  TABLE SCAN|t0  |100      |78  |
|3 |  TABLE SCAN|t   |100      |78  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3], [t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), sort_keys([t0.c1, ASC])
  1 - output([t0.c1], [t0.pk], [t0.c2], [t0.a3], [t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), 
      equal_conds([t0.c1 = t.c1]), other_conds(nil)
  2 - output([t0.pk], [t0.c1], [t0.c2], [t0.a3]), filter(nil), 
      access([t0.pk], [t0.c1], [t0.c2], [t0.a3]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true
  3 - output([t.pk], [t.c1], [t.c2], [t.a3]), filter(nil), 
      access([t.pk], [t.c1], [t.c2], [t.a3]), partitions(p0), 
      is_index_back=false, 
      range_key([t.pk]), range(MIN ; MAX)always true

*************** Case 647(end)  ************** 

***************   Case 648   ***************

SQL: select * from t17 where c1=1 and c2 is null and c3=1; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |300      |354 |
|1 | EXCHANGE OUT DISTR    |:EX10000|300      |314 |
|2 |  PX PARTITION ITERATOR|        |300      |233 |
|3 |   TABLE SCAN          |t17     |300      |233 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t17.c1, t17.c2, t17.c3)]), filter(nil), startup_filter([0])
  1 - output([INTERNAL_FUNCTION(t17.c1, t17.c2, t17.c3)]), filter(nil), dop=1
  2 - output([t17.c1], [t17.c2], [t17.c3]), filter(nil), 
      force partition granule.
  3 - output([t17.c1], [t17.c2], [t17.c3]), filter(nil), 
      access([t17.c1], [t17.c2], [t17.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t17.c1], [t17.c2], [t17.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 648(end)  ************** 

***************   Case 649   ***************

SQL: select c3 from t_normal_idx order by c3; 

=================================================
|ID|OPERATOR   |NAME             |EST. ROWS|COST|
-------------------------------------------------
|0 |SORT       |                 |100      |133 |
|1 | TABLE SCAN|t_normal_idx(idx)|100      |78  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), sort_keys([t_normal_idx.c3, ASC])
  1 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 649(end)  ************** 

***************   Case 650   ***************

SQL: select c3 from t_normal_idx where c2=1 order by c3; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?])

*************** Case 650(end)  ************** 

***************   Case 651   ***************

SQL: select c3 from t_normal_idx where c2 is null order by c3; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,MIN,MIN,MIN,MIN,MIN ; NULL,MAX,MAX,MAX,MAX,MAX), 
      range_cond([(T_OP_IS, t_normal_idx.c2, NULL, 0)])

*************** Case 651(end)  ************** 

***************   Case 652   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null order by c4,c5; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,MIN,MIN,MIN,MIN ; 1,NULL,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 652(end)  ************** 

***************   Case 653   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 order by c5,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 653(end)  ************** 

***************   Case 654   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3 is null and c4 is null and c5 is null order by c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,NULL,NULL,NULL,MIN,MIN ; NULL,NULL,NULL,NULL,MAX,MAX), 
      range_cond([(T_OP_IS, t_normal_idx.c2, NULL, 0)], [(T_OP_IS, t_normal_idx.c3, NULL, 0)], [(T_OP_IS, t_normal_idx.c4, NULL, 0)], [(T_OP_IS, t_normal_idx.c5, NULL, 0)])

*************** Case 654(end)  ************** 

***************   Case 655   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3=1 order by c4; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,1,MIN,MIN,MIN,MIN ; NULL,1,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c3 = ?], [(T_OP_IS, t_normal_idx.c2, NULL, 0)])

*************** Case 655(end)  ************** 

***************   Case 656   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3=1 and c4 is null order by c5,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,1,NULL,MIN,MIN,MIN ; NULL,1,NULL,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c3 = ?], [(T_OP_IS, t_normal_idx.c2, NULL, 0)], [(T_OP_IS, t_normal_idx.c4, NULL, 0)])

*************** Case 656(end)  ************** 

***************   Case 657   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 order by c3,c5,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 657(end)  ************** 

***************   Case 658   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 order by c2,c3,c4,c5,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|100      |78  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 658(end)  ************** 

***************   Case 659   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 and c6 is null order by c5,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|10       |80  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter([(T_OP_IS, t_normal_idx.c6, NULL, 0)]), 
      access([t_normal_idx.c3], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 659(end)  ************** 

***************   Case 660   ***************

SQL: select c3 from t_normal_idx where c2=1 and c4 is null and c5=1 order by c3,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|1        |79  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter([t_normal_idx.c5 = ?], [(T_OP_IS, t_normal_idx.c4, NULL, 0)]), 
      access([t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?])

*************** Case 660(end)  ************** 

***************   Case 661   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c5=1 order by c4,c6; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|9        |79  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter([t_normal_idx.c5 = ?]), 
      access([t_normal_idx.c3], [t_normal_idx.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,MIN,MIN,MIN,MIN ; 1,NULL,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 661(end)  ************** 

***************   Case 662   ***************

SQL: select c3 from t_normal_idx where c2 is not null order by c3; 

=================================================
|ID|OPERATOR   |NAME             |EST. ROWS|COST|
-------------------------------------------------
|0 |SORT       |                 |90       |129 |
|1 | TABLE SCAN|t_normal_idx(idx)|90       |80  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), sort_keys([t_normal_idx.c3, ASC])
  1 - output([t_normal_idx.c3]), filter([(T_OP_IS_NOT, t_normal_idx.c2, NULL, 0)]), 
      access([t_normal_idx.c2], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 662(end)  ************** 

***************   Case 663   ***************

SQL: select c3 from t_normal_idx group by c3; 

===================================================
|ID|OPERATOR     |NAME             |EST. ROWS|COST|
---------------------------------------------------
|0 |HASH GROUP BY|                 |10       |104 |
|1 | TABLE SCAN  |t_normal_idx(idx)|100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c3]), agg_func(nil)
  1 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 663(end)  ************** 

***************   Case 664   ***************

SQL: select c3 from t_normal_idx where c2=1 group by c3; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |10       |82  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c3]), agg_func(nil)
  1 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?])

*************** Case 664(end)  ************** 

***************   Case 665   ***************

SQL: select c3 from t_normal_idx where c2 is null group by c3; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |10       |82  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c3]), agg_func(nil)
  1 - output([t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,MIN,MIN,MIN,MIN,MIN ; NULL,MAX,MAX,MAX,MAX,MAX), 
      range_cond([(T_OP_IS, t_normal_idx.c2, NULL, 0)])

*************** Case 665(end)  ************** 

***************   Case 666   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null group by c4,c5; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |71       |83  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c4], [t_normal_idx.c5]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,MIN,MIN,MIN,MIN ; 1,NULL,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 666(end)  ************** 

***************   Case 667   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 group by c5,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |71       |84  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c5], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 667(end)  ************** 

***************   Case 668   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3 is null and c4 is null and c5 is null group by c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |10       |82  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c6]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,NULL,NULL,NULL,MIN,MIN ; NULL,NULL,NULL,NULL,MAX,MAX), 
      range_cond([(T_OP_IS, t_normal_idx.c2, NULL, 0)], [(T_OP_IS, t_normal_idx.c3, NULL, 0)], [(T_OP_IS, t_normal_idx.c4, NULL, 0)], [(T_OP_IS, t_normal_idx.c5, NULL, 0)])

*************** Case 668(end)  ************** 

***************   Case 669   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3=1 group by c4; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |10       |82  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c4]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c4]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c4]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,1,MIN,MIN,MIN,MIN ; NULL,1,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c3 = ?], [(T_OP_IS, t_normal_idx.c2, NULL, 0)])

*************** Case 669(end)  ************** 

***************   Case 670   ***************

SQL: select c3 from t_normal_idx where c2 is null and c3=1 and c4 is null group by c5,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |71       |84  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c5], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(NULL,1,NULL,MIN,MIN,MIN ; NULL,1,NULL,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c3 = ?], [(T_OP_IS, t_normal_idx.c2, NULL, 0)], [(T_OP_IS, t_normal_idx.c4, NULL, 0)])

*************** Case 670(end)  ************** 

***************   Case 671   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 group by c3,c5,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |71       |84  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c5], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 671(end)  ************** 

***************   Case 672   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 group by c2,c3,c4,c5,c6     ; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |71       |84  |
|1 | TABLE SCAN   |t_normal_idx(idx)|100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c5], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), filter(nil), 
      access([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 672(end)  ************** 

***************   Case 673   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c4=1 and c6 is null group by      c5,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |7        |81  |
|1 | TABLE SCAN   |t_normal_idx(idx)|10       |80  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c5]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c5]), filter([(T_OP_IS, t_normal_idx.c6, NULL, 0)]), 
      access([t_normal_idx.c3], [t_normal_idx.c6], [t_normal_idx.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,1,MIN,MIN,MIN ; 1,NULL,1,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [t_normal_idx.c4 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 673(end)  ************** 

***************   Case 674   ***************

SQL: select c3 from t_normal_idx where c2=1 and c4 is null and c5=1 group by c3,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |1        |79  |
|1 | TABLE SCAN   |t_normal_idx(idx)|1        |79  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c3], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c6]), filter([t_normal_idx.c5 = ?], [(T_OP_IS, t_normal_idx.c4, NULL, 0)]), 
      access([t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c3], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,MIN,MIN,MIN,MIN,MIN ; 1,MAX,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?])

*************** Case 674(end)  ************** 

***************   Case 675   ***************

SQL: select c3 from t_normal_idx where c2=1 and c3 is null and c5=1 group by c4,c6; 

====================================================
|ID|OPERATOR      |NAME             |EST. ROWS|COST|
----------------------------------------------------
|0 |MERGE GROUP BY|                 |9        |80  |
|1 | TABLE SCAN   |t_normal_idx(idx)|9        |79  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c4], [t_normal_idx.c6]), agg_func(nil)
  1 - output([t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c6]), filter([t_normal_idx.c5 = ?]), 
      access([t_normal_idx.c3], [t_normal_idx.c5], [t_normal_idx.c4], [t_normal_idx.c6]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(1,NULL,MIN,MIN,MIN,MIN ; 1,NULL,MAX,MAX,MAX,MAX), 
      range_cond([t_normal_idx.c2 = ?], [(T_OP_IS, t_normal_idx.c3, NULL, 0)])

*************** Case 675(end)  ************** 

***************   Case 676   ***************

SQL: select c3 from t_normal_idx where c2 is not null group by c3; 

===================================================
|ID|OPERATOR     |NAME             |EST. ROWS|COST|
---------------------------------------------------
|0 |HASH GROUP BY|                 |10       |104 |
|1 | TABLE SCAN  |t_normal_idx(idx)|90       |80  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c3]), filter(nil), 
      group([t_normal_idx.c3]), agg_func(nil)
  1 - output([t_normal_idx.c3]), filter([(T_OP_IS_NOT, t_normal_idx.c2, NULL, 0)]), 
      access([t_normal_idx.c2], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 676(end)  ************** 

***************   Case 677   ***************

SQL: select c1 from t7 where c1=(select t7.c1 as c from t7 t having c1>(select c from t7)); 

=========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST |
-----------------------------------------
|0 |SUBPLAN FILTER |    |1        |15902|
|1 | TABLE SCAN    |t7  |100      |78   |
|2 | SUBPLAN FILTER|    |100      |157  |
|3 |  TABLE SCAN   |t   |100      |78   |
|4 |  TABLE SCAN   |t7  |100      |78   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([t7.c1 = subquery(1)]), 
      exec_params_([t7.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? > subquery(1)]), init_plan_idxs_(nil)
  3 - output(nil), filter(nil), startup_filter([?]), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true
  4 - output([?]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 677(end)  ************** 

***************   Case 678   ***************

SQL: select c1+1 as c from t7 group by (select c from t7 t); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |HASH GROUP BY  |    |100      |8035|
|1 | SUBPLAN FILTER|    |100      |7991|
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  TABLE SCAN   |t   |100      |78  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1 + ?]), filter(nil), 
      group([subquery(1)]), agg_func(nil)
  1 - output([subquery(1)], [t7.c1 + ?]), filter(nil), 
      exec_params_([t7.c1 + ?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 678(end)  ************** 

***************   Case 679   ***************

SQL: select count(c1) + 1 from t7 having (select count(t7.c1) from t7 t)>0; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |161 |
|1 | SCALAR GROUP BY|    |1        |81  |
|2 |  TABLE SCAN    |t7  |100      |78  |
|3 | TABLE SCAN     |t   |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(t7.c1) + ?]), filter([subquery(1) > ?]), 
      exec_params_([T_FUN_COUNT(t7.c1)]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 679(end)  ************** 

***************   Case 680   ***************

SQL: select count(c1) + 1 as c from t7 having (select c from t7 t)>0; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |1        |161 |
|1 | SCALAR GROUP BY|    |1        |81  |
|2 |  TABLE SCAN    |t7  |100      |78  |
|3 | TABLE SCAN     |t   |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(t7.c1) + ?]), filter([subquery(1) > ?]), 
      exec_params_([T_FUN_COUNT(t7.c1) + ?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([T_FUN_COUNT(t7.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t7.c1)])
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 680(end)  ************** 

***************   Case 681   ***************

SQL: select (select c1 from t7 t) as c from t7 group by (select c from t7 tt); 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |HASH GROUP BY   |    |1        |8094|
|1 | SUBPLAN FILTER |    |100      |8070|
|2 |  SUBPLAN FILTER|    |100      |157 |
|3 |   TABLE SCAN   |t7  |100      |78  |
|4 |   TABLE SCAN   |t   |100      |78  |
|5 |  TABLE SCAN    |tt  |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([?]), filter(nil), 
      group([subquery(1)]), agg_func(nil)
  1 - output([subquery(1)], [?]), filter(nil), 
      exec_params_([?]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output(nil), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t.c1]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true
  5 - output([?]), filter(nil), 
      access([tt.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([tt.c1]), range(MIN ; MAX)always true

*************** Case 681(end)  ************** 

***************   Case 682   ***************

SQL: select 1 as c, c1 from t7 having c1>(select c from t7 t); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |124 |
|1 | TABLE SCAN   |t7  |34       |46  |
|2 | TABLE SCAN   |t   |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([?], [t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 > ?])
  2 - output([?]), filter(nil), 
      access([t.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t.c1]), range(MIN ; MAX)always true

*************** Case 682(end)  ************** 

***************   Case 683   ***************

SQL: SELECT c7 FROM query_range1 t8_1 WHERE ( ( t8_1.c7 in ((450) , (2001)) ) ) OR ( ( t8_1.c7 < 220 ) ); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t8_1|92       |80  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t8_1.c7]), filter([t8_1.c7 IN (?, ?) OR t8_1.c7 < ?]), 
      access([t8_1.c7]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8_1.c9], [t8_1.c11], [t8_1.c8], [t8_1.c1], [t8_1.c12], [t8_1.c7], [t8_1.c5]), range(MIN,MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 683(end)  ************** 

***************   Case 684   ***************

SQL: select (1>(select count(*) from t2 where c1=1)) from t1 where c1=1; 

======================================================
|ID|OPERATOR                    |NAME |EST. ROWS|COST|
------------------------------------------------------
|0 |EXCHANGE IN REMOTE          |     |1        |93  |
|1 | EXCHANGE OUT REMOTE        |     |1        |93  |
|2 |  NESTED-LOOP JOIN CARTESIAN|     |1        |92  |
|3 |   TABLE GET                |t1   |1        |46  |
|4 |   SUBPLAN SCAN             |VIEW1|1        |46  |
|5 |    SCALAR GROUP BY         |     |1        |46  |
|6 |     TABLE GET              |t2   |1        |46  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([? > VIEW1.count(*)]), filter(nil)
  1 - output([? > VIEW1.count(*)]), filter(nil)
  2 - output([? > VIEW1.count(*)]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  3 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t1.c1]), range[1 ; 1], 
      range_cond([t1.c1 = ?])
  4 - output([VIEW1.count(*)]), filter(nil), 
      access([VIEW1.count(*)])
  5 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  6 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p1), 
      is_index_back=false, 
      range_key([t2.c1]), range[1 ; 1], 
      range_cond([t2.c1 = ?])

*************** Case 684(end)  ************** 

***************   Case 685   ***************

SQL: select c1 from t1 group by c1, 'a' asc; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |567 |
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |540 |
|2 |  SORT                    |        |500      |488 |
|3 |   PX PARTITION ITERATOR  |        |500      |387 |
|4 |    TABLE SCAN            |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 685(end)  ************** 

***************   Case 686   ***************

SQL: select c1 from t1 order by c1, 'a' asc; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |567 |
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |540 |
|2 |  SORT                    |        |500      |488 |
|3 |   PX PARTITION ITERATOR  |        |500      |387 |
|4 |    TABLE SCAN            |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1)]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1)]), filter(nil), dop=1
  2 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 686(end)  ************** 

***************   Case 687   ***************

SQL: select c1, exists(select c1 from t7) from t7 group by 2; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE GROUP BY |    |1        |127 |
|1 | SUBPLAN FILTER|    |100      |125 |
|2 |  TABLE SCAN   |t7  |100      |78  |
|3 |  TABLE SCAN   |t7  |1        |46  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [?]), filter(nil), 
      group(nil), agg_func(nil)
  1 - output([t7.c1], [?]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 687(end)  ************** 

***************   Case 688   ***************

SQL: select * from t1 where c1 is false; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |1        |400 |
|1 | EXCHANGE OUT DISTR    |:EX10000|1        |400 |
|2 |  PX PARTITION ITERATOR|        |1        |400 |
|3 |   TABLE SCAN          |t1      |1        |400 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c1, 0, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 688(end)  ************** 

***************   Case 689   ***************

SQL: select * from t1 where (c1 + 1) is false; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |250      |470 |
|1 | EXCHANGE OUT DISTR    |:EX10000|250      |447 |
|2 |  PX PARTITION ITERATOR|        |250      |400 |
|3 |   TABLE SCAN          |t1      |250      |400 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c1 + ?, 0, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 689(end)  ************** 

***************   Case 690   ***************

SQL: select * from t1 where c1 is null; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), startup_filter([0])
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 690(end)  ************** 

***************   Case 691   ***************

SQL: select * from t1 where c2 is null; 

=========================================================
|ID|OPERATOR               |NAME         |EST. ROWS|COST|
---------------------------------------------------------
|0 |PX COORDINATOR         |             |50       |242 |
|1 | EXCHANGE OUT DISTR    |:EX10000     |50       |238 |
|2 |  PX PARTITION ITERATOR|             |50       |228 |
|3 |   TABLE SCAN          |t1(idx_t1_c2)|50       |228 |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(NULL,MIN ; NULL,MAX), 
      range_cond([(T_OP_IS, t1.c2, NULL, 0)])

*************** Case 691(end)  ************** 

***************   Case 692   ***************

SQL: select * from t1 where c2 is not null; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |450      |526 |
|1 | EXCHANGE OUT DISTR    |:EX10000|450      |484 |
|2 |  PX PARTITION ITERATOR|        |450      |400 |
|3 |   TABLE SCAN          |t1      |450      |400 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([(T_OP_IS_NOT, t1.c2, NULL, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 692(end)  ************** 

***************   Case 693   ***************

SQL: select * from t1 where c1 is not null; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |528 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 693(end)  ************** 

***************   Case 694   ***************

SQL: select * from t1 where (c1 + 1) is null; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |250      |470 |
|1 | EXCHANGE OUT DISTR    |:EX10000|250      |447 |
|2 |  PX PARTITION ITERATOR|        |250      |400 |
|3 |   TABLE SCAN          |t1      |250      |400 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c1], [t1.c2]), filter([(T_OP_IS, t1.c1 + ?, NULL, 0)]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 694(end)  ************** 

***************   Case 695   ***************

SQL: select /*+ index(y_t1 i1)*/* from y_t1 where c2=10 order by c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|y_t1|1        |79  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter([cast(y_t1.c2, DECIMAL(-1, -1)) = ?]), 
      access([y_t1.c1], [y_t1.c2], [y_t1.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([y_t1.c1]), range(MIN ; MAX)always true

*************** Case 695(end)  ************** 

***************   Case 696   ***************

SQL: select /*+ index(y_t1 y_t1_i1) */ * from y_t1 where c2=10 order by c1; 

=============================================
|ID|OPERATOR   |NAME         |EST. ROWS|COST|
---------------------------------------------
|0 |SORT       |             |1        |79  |
|1 | TABLE SCAN|y_t1(y_t1_i1)|1        |79  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), sort_keys([y_t1.c1, ASC])
  1 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter([cast(y_t1.c2, DECIMAL(-1, -1)) = ?]), 
      access([y_t1.c1], [y_t1.c2], [y_t1.c3]), partitions(p0), 
      is_index_back=true, filter_before_indexback[true], 
      range_key([y_t1.c2], [y_t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 696(end)  ************** 

***************   Case 697   ***************

SQL: select /*+ index(y_t1 y_t1_i1) */ * from y_t1 where c2='10' order by c1; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t1(y_t1_i1)|100      |95  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), 
      access([y_t1.c1], [y_t1.c2], [y_t1.c3]), partitions(p0), 
      is_index_back=true, 
      range_key([y_t1.c2], [y_t1.c1]), range(10,MIN ; 10,MAX), 
      range_cond([y_t1.c2 = ?])

*************** Case 697(end)  ************** 

***************   Case 698   ***************

SQL: select /*+ index(y_t1 y_t1_i1) */ * from y_t1 where c2=c1 order by c1; 

=============================================
|ID|OPERATOR   |NAME         |EST. ROWS|COST|
---------------------------------------------
|0 |SORT       |             |1        |79  |
|1 | TABLE SCAN|y_t1(y_t1_i1)|1        |79  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), sort_keys([y_t1.c1, ASC])
  1 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter([cast(y_t1.c2, DECIMAL(-1, -1)) = cast(y_t1.c1, DECIMAL(11, 0))]), 
      access([y_t1.c1], [y_t1.c2], [y_t1.c3]), partitions(p0), 
      is_index_back=true, filter_before_indexback[true], 
      range_key([y_t1.c2], [y_t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 698(end)  ************** 

***************   Case 699   ***************

SQL: select * from y_t1 where c2=c1 order by c1, c2; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|y_t1|1        |79  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter([cast(y_t1.c2, DECIMAL(-1, -1)) = cast(y_t1.c1, DECIMAL(11, 0))]), 
      access([y_t1.c1], [y_t1.c2], [y_t1.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([y_t1.c1]), range(MIN ; MAX)always true

*************** Case 699(end)  ************** 

***************   Case 700   ***************

SQL: select /*+ index(y_t1 y_t1_i1) */ * from y_t1 where c2=c1 order by c1, c2; 

=============================================
|ID|OPERATOR   |NAME         |EST. ROWS|COST|
---------------------------------------------
|0 |SORT       |             |1        |79  |
|1 | TABLE SCAN|y_t1(y_t1_i1)|1        |79  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), sort_keys([y_t1.c1, ASC])
  1 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter([cast(y_t1.c2, DECIMAL(-1, -1)) = cast(y_t1.c1, DECIMAL(11, 0))]), 
      access([y_t1.c1], [y_t1.c2], [y_t1.c3]), partitions(p0), 
      is_index_back=true, filter_before_indexback[true], 
      range_key([y_t1.c2], [y_t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 700(end)  ************** 

***************   Case 701   ***************

SQL: select /*+ index(y_t1 y_t1_i2) */ * from y_t1 where c3=c1 order by c1, c3; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t1(y_t1_i2)|1        |79  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter([y_t1.c3 = y_t1.c1]), 
      access([y_t1.c1], [y_t1.c3], [y_t1.c2]), partitions(p0), 
      is_index_back=true, filter_before_indexback[true], 
      range_key([y_t1.c3], [y_t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 701(end)  ************** 

***************   Case 702   ***************

SQL: select /*+ index(y_t1 y_t1_i2) */ * from y_t1 where c3=10 order by c1; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t1(y_t1_i2)|100      |95  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), 
      access([y_t1.c1], [y_t1.c3], [y_t1.c2]), partitions(p0), 
      is_index_back=true, 
      range_key([y_t1.c3], [y_t1.c1]), range(10,MIN ; 10,MAX), 
      range_cond([y_t1.c3 = ?])

*************** Case 702(end)  ************** 

***************   Case 703   ***************

SQL: select /*+ index(y_t1 y_t1_i2) */ * from y_t1 where c3='10' order by c1; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t1(y_t1_i2)|100      |95  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter(nil), 
      access([y_t1.c1], [y_t1.c3], [y_t1.c2]), partitions(p0), 
      is_index_back=true, 
      range_key([y_t1.c3], [y_t1.c1]), range(10,MIN ; 10,MAX), 
      range_cond([cast(y_t1.c3, DECIMAL(10, 0)) = ?])

*************** Case 703(end)  ************** 

***************   Case 704   ***************

SQL: select /*+ index(y_t1 y_t1_i2) */ * from y_t1 where c3=c1 order by c1; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t1(y_t1_i2)|1        |79  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t1.c1], [y_t1.c2], [y_t1.c3]), filter([y_t1.c3 = y_t1.c1]), 
      access([y_t1.c1], [y_t1.c3], [y_t1.c2]), partitions(p0), 
      is_index_back=true, filter_before_indexback[true], 
      range_key([y_t1.c3], [y_t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 704(end)  ************** 

***************   Case 705   ***************

SQL: select a from y_t3 where a = 'A' collate utf8mb4_general_ci order by a; 

====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |SORT       |    |1        |84  |
|1 | TABLE SCAN|y_t3|1        |84  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t3.a]), filter(nil), sort_keys([y_t3.a, ASC])
  1 - output([y_t3.a]), filter([cast(y_t3.a, VARCHAR(1048576)) = ?]), 
      access([y_t3.a]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([y_t3.__pk_increment], [y_t3.__pk_cluster_id], [y_t3.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 705(end)  ************** 

***************   Case 706   ***************

SQL: select * from hint.t1 group by b having (select b from hint.t2 limit 1); 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |HASH GROUP BY  |    |10       |151 |
|1 | SUBPLAN FILTER|    |100      |125 |
|2 |  TABLE SCAN   |t1  |100      |78  |
|3 |  TABLE SCAN   |t2  |1        |46  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      group([t1.b]), agg_func(nil)
  1 - output([t1.b], [t1.a]), filter(nil), 
      exec_params_(nil), onetime_exprs_([BOOL(subquery(1))]), init_plan_idxs_(nil)
  2 - output([t1.a], [t1.b]), filter(nil), startup_filter([?]), 
      access([t1.a], [t1.b]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  3 - output([t2.b]), filter(nil), 
      access([t2.b]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.a]), range(MIN ; MAX)always true

*************** Case 706(end)  ************** 

***************   Case 707   ***************

SQL: select * from hint.t1 group by b having (select b from hint.t2 limit 1) = 1; 

========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |HASH GROUP BY  |    |10       |151 |
|1 | SUBPLAN FILTER|    |100      |125 |
|2 |  TABLE SCAN   |t1  |100      |78  |
|3 |  TABLE SCAN   |t2  |1        |46  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      group([t1.b]), agg_func(nil)
  1 - output([t1.b], [t1.a]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1) = ?]), init_plan_idxs_(nil)
  2 - output([t1.a], [t1.b]), filter(nil), startup_filter([?]), 
      access([t1.a], [t1.b]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  3 - output([t2.b]), filter(nil), 
      access([t2.b]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.a]), range(MIN ; MAX)always true

*************** Case 707(end)  ************** 

***************   Case 708   ***************

SQL: select * from hint.t1 group by b having (select b from hint.t2 limit 1) = 1 or sum(b) = 1; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |151 |
|1 | HASH GROUP BY|    |10       |106 |
|2 |  TABLE SCAN  |t1  |100      |78  |
|3 | TABLE SCAN   |t2  |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([? OR T_FUN_SUM(t1.b) = ?]), 
      exec_params_(nil), onetime_exprs_([subquery(1) = ?]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b], [T_FUN_SUM(t1.b)]), filter(nil), 
      group([t1.b]), agg_func([T_FUN_SUM(t1.b)])
  2 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.a]), range(MIN ; MAX)always true
  3 - output([t2.b]), filter(nil), 
      access([t2.b]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.a]), range(MIN ; MAX)always true

*************** Case 708(end)  ************** 

***************   Case 709   ***************

SQL: select c1 from t0 where pk is null; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t0  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.c1]), filter(nil), startup_filter([0]), 
      access([t0.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 709(end)  ************** 

***************   Case 710   ***************

SQL: select c1 from t0 where pk <=> null; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t0  |1        |46  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.c1]), filter(nil), 
      access([t0.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range[NULL ; NULL], 
      range_cond([t0.pk <=> ?])

*************** Case 710(end)  ************** 

***************   Case 711   ***************

SQL: select c1 from t4 where c1 <=> null and c2 <=> null; 

===========================================
|ID|OPERATOR |NAME         |EST. ROWS|COST|
-------------------------------------------
|0 |TABLE GET|t4(idx_t4_c2)|1        |46  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range[NULL,NULL ; NULL,NULL], 
      range_cond([t4.c1 <=> ?], [t4.c2 <=> ?])

*************** Case 711(end)  ************** 

***************   Case 712   ***************

SQL: select c1 from t4 where c1 <=> 1 and c2 <=> 1; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t4  |1        |46  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range[1,1 ; 1,1], 
      range_cond([t4.c1 <=> ?], [t4.c2 <=> ?])

*************** Case 712(end)  ************** 

***************   Case 713   ***************

SQL: select c1 from t4 where c1 is null and c2 <=> null; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|100      |78  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1]), filter(nil), startup_filter([0]), 
      access([t4.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 713(end)  ************** 

***************   Case 714   ***************

SQL: select c1 from (select c1, c2 from t1 limit 1) ta group by ta.c1; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |LIMIT                    |        |1        |227 |
|1 | PX COORDINATOR          |        |1        |227 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |227 |
|3 |   LIMIT                 |        |1        |227 |
|4 |    PX PARTITION ITERATOR|        |1        |227 |
|5 |     TABLE SCAN          |t1      |1        |227 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 714(end)  ************** 

***************   Case 715   ***************

SQL: select * from (select count(c1) from t1) ta; 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |405 |
|1 | PX COORDINATOR          |        |1        |405 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |405 |
|3 |   MERGE GROUP BY        |        |1        |405 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(t1.c1))])
  1 - output([T_FUN_COUNT(t1.c1)]), filter(nil)
  2 - output([T_FUN_COUNT(t1.c1)]), filter(nil), dop=1
  3 - output([T_FUN_COUNT(t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t1.c1)])
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 715(end)  ************** 

***************   Case 716   ***************

SQL: select c1 from (select c1, c2 from (select * from t4 limit 10)ta limit 5) ta1 group by ta1.c1; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |5        |46  |
|1 | SUBPLAN SCAN |ta1 |5        |46  |
|2 |  TABLE SCAN  |t4  |5        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([ta1.c1]), filter(nil), 
      group([ta1.c1]), agg_func(nil)
  1 - output([ta1.c1]), filter(nil), 
      access([ta1.c1])
  2 - output([t4.c1]), filter(nil), 
      access([t4.c1]), partitions(p0), 
      limit(?), offset(nil), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 716(end)  ************** 

***************   Case 717   ***************

SQL: select tb.a from (select a, b from (select * from t12 limit 10)ta limit 5) ta1 join (select a, b from t13 limit 10) tb on ta1.a = tb.a; 

======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |MERGE JOIN   |    |6        |93  |
|1 | SUBPLAN SCAN|tb  |10       |46  |
|2 |  TABLE SCAN |t13 |10       |46  |
|3 | SUBPLAN SCAN|ta1 |5        |46  |
|4 |  TABLE SCAN |t12 |5        |46  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([tb.a]), filter(nil), 
      equal_conds([ta1.a = tb.a]), other_conds(nil)
  1 - output([tb.a]), filter(nil), 
      access([tb.a])
  2 - output([t13.a]), filter(nil), 
      access([t13.a]), partitions(p0), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true
  3 - output([ta1.a]), filter(nil), 
      access([ta1.a])
  4 - output([t12.a]), filter(nil), 
      access([t12.a]), partitions(p0), 
      limit(?), offset(nil), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true

*************** Case 717(end)  ************** 

***************   Case 718   ***************

SQL: select t13.a from (select * from t12) ta, t13; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |2736|
|1 | TABLE SCAN               |t13 |100      |78  |
|2 | MATERIAL                 |    |100      |78  |
|3 |  TABLE SCAN              |t12 |100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t13.a]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t13.a]), filter(nil), 
      access([t13.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t13.a]), range(MIN ; MAX)always true
  2 - output(nil), filter(nil)
  3 - output(nil), filter(nil), 
      access([t12.a]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true

*************** Case 718(end)  ************** 

***************   Case 719   ***************

SQL: select ta.a from (select * from t12) ta where ta.a > (select t13.a from t13 where t13.b < ta.b limit 1) ; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |4640|
|1 | TABLE SCAN   |t12 |100      |78  |
|2 | TABLE SCAN   |t13 |1        |46  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.a]), filter([t12.a > subquery(1)]), 
      exec_params_([t12.b]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t12.a], [t12.b]), filter(nil), 
      access([t12.a], [t12.b]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.a]), range(MIN ; MAX)always true
  2 - output([t13.a]), filter([t13.b < ?]), 
      access([t13.a], [t13.b]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t13.a]), range(MIN ; MAX)always true

*************** Case 719(end)  ************** 

***************   Case 720   ***************

SQL: select (select min(c1) from agg_t2) from agg_t1; 

===========================================
|ID|OPERATOR        |NAME  |EST. ROWS|COST|
-------------------------------------------
|0 |SUBPLAN FILTER  |      |1        |125 |
|1 | SCALAR GROUP BY|      |1        |46  |
|2 |  SUBPLAN SCAN  |VIEW1 |1        |46  |
|3 |   TABLE SCAN   |agg_t1|1        |46  |
|4 | TABLE SCAN     |agg_t2|100      |78  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([subquery(1)]), filter(nil), 
      exec_params_([T_FUN_MIN(VIEW1.agg_t1.c1)]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([T_FUN_MIN(VIEW1.agg_t1.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW1.agg_t1.c1)])
  2 - output([VIEW1.agg_t1.c1]), filter(nil), 
      access([VIEW1.agg_t1.c1])
  3 - output([agg_t1.c1]), filter(nil), 
      access([agg_t1.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([agg_t1.c1]), range(MIN ; MAX)always true
  4 - output([?]), filter(nil), 
      access([agg_t2.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([agg_t2.c2]), range(MIN ; MAX)always true

*************** Case 720(end)  ************** 

***************   Case 721   ***************

SQL: select * from (select c1 from t1 order by c1) ta limit 1; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |LIMIT                      |        |1        |228 |
|1 | PX COORDINATOR MERGE SORT |        |1        |228 |
|2 |  EXCHANGE OUT DISTR       |:EX10000|1        |228 |
|3 |   TOP-N SORT              |        |1        |227 |
|4 |    PX PARTITION ITERATOR  |        |1        |227 |
|5 |     TABLE SCAN            |t1      |1        |227 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), limit(1), offset(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC])
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), topn(1), local merge sort
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 721(end)  ************** 

***************   Case 722   ***************

SQL: select * from t4,t7 order by t4.c3; 

============================================================
|ID|OPERATOR                  |NAME         |EST. ROWS|COST|
------------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|             |10000    |2736|
|1 | TABLE SCAN               |t4(idx_t4_c3)|100      |78  |
|2 | MATERIAL                 |             |100      |79  |
|3 |  TABLE SCAN              |t7           |100      |78  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c1], [t4.c2], [t4.c3], [t7.c1], [t7.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c3], [t4.c1], [t4.c2]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([t7.c1], [t7.c2]), filter(nil)
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 722(end)  ************** 

***************   Case 723   ***************

SQL: select /*+use_nl(tg1 tg2)*/* from tg1, tg1 tg2 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3=1 and tg2.c2=2 and tg2.c3=2; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |84  |
|1 | TABLE SCAN     |tg1 |1        |79  |
|2 | TABLE GET      |tg2 |1        |5   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      conds(nil), nl_params_([tg1.c1]), batch_join=true
  1 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), filter([tg1.c2 = ?], [tg1.c3 = ?]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN ; MAX), 
      range_cond([tg2.c2 = ?], [tg2.c3 = ?], [? = tg2.c1])

*************** Case 723(end)  ************** 

***************   Case 724   ***************

SQL: select /*+use_nl(tg1 tg2)*/* from tg1, tg1 tg2 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3=1 and tg2.c2=2 and tg2.c3=2 and tg1.c2 = tg2.c2; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |80  |
|1 | TABLE SCAN     |tg1 |1        |79  |
|2 | TABLE GET      |tg2 |1        |5   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      conds(nil), nl_params_([tg1.c1]), batch_join=true
  1 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), filter([tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MAX,MAX,MAX ; MIN,MIN,MIN)always false
  2 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN ; MAX), 
      range_cond([tg2.c2 = ?], [tg2.c3 = ?], [tg2.c2 = ?], [? = tg2.c1])

*************** Case 724(end)  ************** 

***************   Case 725   ***************

SQL: select /*+use_nl(tg1 tg2)*/* from tg1, tg1 tg2 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3 = 1 and tg2.c2=1 and tg2.c3=1 or tg2.c1=2 and tg2.c2=2 and tg2.c3 = 4 and tg1.c1 = 1 and tg1.c2 = 2 and tg1.c3 = 4; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |161 |
|1 | TABLE SCAN     |tg1 |1        |80  |
|2 | MATERIAL       |    |1        |80  |
|3 |  TABLE SCAN    |tg2 |1        |80  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      conds([(T_OP_AND, tg1.c1 = tg2.c1, tg1.c2 = ?, tg1.c3 = ?, tg2.c2 = ?, tg2.c3 = ?) OR (T_OP_AND, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?, tg1.c1 = ?, tg1.c2 = ?, tg1.c3 = ?)]), nl_params_(nil), batch_join=false
  1 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?], [tg1.c2 = ?], [tg1.c3 = ?]), filter([tg1.c2 = ? AND tg1.c3 = ? OR (T_OP_AND, tg1.c1 = ?, tg1.c2 = ?, tg1.c3 = ?)]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5], [tg2.c2 = ?], [tg2.c3 = ?], [tg2.c1 = ?], [tg2.c2 = ?], [tg2.c3 = ?]), filter(nil)
  3 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5], [tg2.c2 = ?], [tg2.c3 = ?], [tg2.c1 = ?], [tg2.c2 = ?], [tg2.c3 = ?]), filter([tg2.c2 = ? AND tg2.c3 = ? OR (T_OP_AND, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?)]), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 725(end)  ************** 

***************   Case 726   ***************

SQL: select /*+use_nl(tg2 tg1)*/* from tg2,tg1 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3=1 or tg1.c2=2 and tg1.c3=2 and tg1.c1 = 2 and tg2.c1 = 3 and tg2.c2 =  3 and tg2.c3 = 3; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |8        |168 |
|1 | TABLE SCAN     |tg2 |100      |78  |
|2 | MATERIAL       |    |1        |80  |
|3 |  TABLE SCAN    |tg1 |1        |80  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5], [tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), filter(nil), 
      conds([(T_OP_AND, tg1.c1 = tg2.c1, tg1.c2 = ?, tg1.c3 = ?) OR (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?)]), nl_params_(nil), batch_join=false
  1 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter(nil)
  3 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter([tg1.c2 = ? AND tg1.c3 = ? OR (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?)]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 726(end)  ************** 

***************   Case 727   ***************

SQL: select /*+use_nl(tg1 tg2)*/* from tg2,tg1 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3=1 or tg1.c2=2 and tg1.c3=2 and tg1.c1 = 2 and tg2.c1 = 3 and tg2.c2 =  3 and tg2.c3 = 3 or tg1.c2=3 and tg1.c3=3 and tg1.c1 = 3 and tg2.c1 = 4 and tg2.c2 =  4 and tg2.c3 = 4; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |9        |169 |
|1 | TABLE SCAN     |tg2 |100      |78  |
|2 | MATERIAL       |    |1        |80  |
|3 |  TABLE SCAN    |tg1 |1        |80  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5], [tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), filter(nil), 
      conds([(T_OP_OR, (T_OP_AND, tg1.c1 = tg2.c1, tg1.c2 = ?, tg1.c3 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?))]), nl_params_(nil), batch_join=false
  1 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter(nil)
  3 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter([(T_OP_OR, tg1.c2 = ? AND tg1.c3 = ?, (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?))]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 727(end)  ************** 

***************   Case 728   ***************

SQL: select /*+use_nl(tg1 tg2)*/* from tg2,tg1 where tg1.c1=tg2.c1 and tg1.c2=1 and tg1.c3=1 or tg1.c2=2 and tg1.c3=2 and tg1.c1 = 2 and tg2.c1 = 3 and tg2.c2 =  3 and tg2.c3 = 3 or tg1.c2=3 and tg1.c3=3 and tg1.c1 = 3 and tg2.c1 = 4 and tg2.c2 =  4 and tg2.c3 = 4; 

=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |9        |169 |
|1 | TABLE SCAN     |tg2 |100      |78  |
|2 | MATERIAL       |    |1        |80  |
|3 |  TABLE SCAN    |tg1 |1        |80  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5], [tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), filter(nil), 
      conds([(T_OP_OR, (T_OP_AND, tg1.c1 = tg2.c1, tg1.c2 = ?, tg1.c3 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?, tg2.c1 = ?, tg2.c2 = ?, tg2.c3 = ?))]), nl_params_(nil), batch_join=false
  1 - output([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), filter(nil), 
      access([tg2.c1], [tg2.c2], [tg2.c3], [tg2.c4], [tg2.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([tg2.c1], [tg2.c2], [tg2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  2 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter(nil)
  3 - output([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?], [tg1.c2 = ?], [tg1.c3 = ?], [tg1.c1 = ?]), filter([(T_OP_OR, tg1.c2 = ? AND tg1.c3 = ?, (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?), (T_OP_AND, tg1.c2 = ?, tg1.c3 = ?, tg1.c1 = ?))]), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 728(end)  ************** 

***************   Case 729   ***************

SQL: select /*+ use_nl(t1, t2) */ t2.c2, t2.c3 from (select * from y_t4 t where t.c1=100 order by t.c2 DESC, t.c3 DESC limit 1) t1 join y_t4 t2 on t1.c2=t2.c2 and t1.c3=t2.c3 order by t2.c2 DESC, t2.c3 DESC; 

================================================
|ID|OPERATOR         |NAME      |EST. ROWS|COST|
------------------------------------------------
|0 |SORT             |          |2        |134 |
|1 | NESTED-LOOP JOIN|          |2        |133 |
|2 |  TABLE SCAN     |t2        |100      |78  |
|3 |  MATERIAL       |          |1        |46  |
|4 |   SUBPLAN SCAN  |t1        |1        |46  |
|5 |    TABLE SCAN   |t(Reverse)|1        |46  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c2], [t2.c3]), filter(nil), sort_keys([t2.c2, DESC], [t2.c3, DESC])
  1 - output([t2.c2], [t2.c3]), filter(nil), 
      conds([t1.c2 = t2.c2], [t1.c3 = t2.c3]), nl_params_(nil), batch_join=false
  2 - output([t2.c2], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t2.c1], [t2.c2], [t2.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
  3 - output([t1.c2], [t1.c3]), filter(nil)
  4 - output([t1.c2], [t1.c3]), filter(nil), 
      access([t1.c2], [t1.c3])
  5 - output([t.c2], [t.c3]), filter(nil), 
      access([t.c2], [t.c3]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t.c1], [t.c2], [t.c3]), range(100,MIN,MIN ; 100,MAX,MAX), 
      range_cond([t.c1 = ?])

*************** Case 729(end)  ************** 

***************   Case 730   ***************

SQL: select count(1) from (select * from t1 order by c2 limit 10) t; 

===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |SCALAR GROUP BY              |             |1        |232 |
|1 | SUBPLAN SCAN                |t            |10       |231 |
|2 |  LIMIT                      |             |10       |231 |
|3 |   PX COORDINATOR MERGE SORT |             |10       |231 |
|4 |    EXCHANGE OUT DISTR       |:EX10000     |10       |231 |
|5 |     TOP-N SORT              |             |10       |229 |
|6 |      PX PARTITION ITERATOR  |             |10       |227 |
|7 |       TABLE SCAN            |t1(idx_t1_c2)|10       |227 |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([1]), filter(nil), limit(10), offset(nil)
  3 - output(nil), filter(nil), sort_keys([t1.c2, ASC])
  4 - output([t1.c2]), filter(nil), dop=1
  5 - output([t1.c2]), filter(nil), sort_keys([t1.c2, ASC]), topn(10), local merge sort
  6 - output([t1.c2]), filter(nil), 
      force partition granule.
  7 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      limit(10), offset(nil), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 730(end)  ************** 

***************   Case 731   ***************

SQL: select count(1) from (select c1, c2, (select c3 from t2) as ca from t1 order by ca limit 10) t; 

========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST|
--------------------------------------------------------
|0 |SCALAR GROUP BY            |        |1        |620 |
|1 | SUBPLAN SCAN              |t       |10       |620 |
|2 |  LIMIT                    |        |10       |620 |
|3 |   SUBPLAN FILTER          |        |10       |619 |
|4 |    PX COORDINATOR         |        |10       |229 |
|5 |     EXCHANGE OUT DISTR    |:EX10000|10       |228 |
|6 |      PX PARTITION ITERATOR|        |10       |227 |
|7 |       TABLE SCAN          |t1      |10       |227 |
|8 |    PX COORDINATOR         |        |300      |391 |
|9 |     EXCHANGE OUT DISTR    |:EX20000|300      |340 |
|10|      PX PARTITION ITERATOR|        |300      |233 |
|11|       TABLE SCAN          |t2      |300      |233 |
========================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output(nil), filter(nil), 
      access(nil)
  2 - output([1]), filter(nil), limit(10), offset(nil)
  3 - output(nil), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output(nil), filter(nil)
  5 - output(nil), filter(nil), dop=1
  6 - output(nil), filter(nil), 
      force partition granule.
  7 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  8 - output([t2.c3]), filter(nil)
  9 - output([t2.c3]), filter(nil), dop=1
  10 - output([t2.c3]), filter(nil), 
      force partition granule.
  11 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 731(end)  ************** 

***************   Case 732   ***************

SQL: select distinct c3, c2 from t4; 

===================================================
|ID|OPERATOR      |NAME            |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE DISTINCT|                |71       |83  |
|1 | TABLE SCAN   |t4(idx_t4_c2_c3)|100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t4.c3], [t4.c2]), filter(nil), 
      distinct([t4.c2], [t4.c3])
  1 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 732(end)  ************** 

***************   Case 733   ***************

SQL: select count(c2) from t4 group by c3, c2; 

===================================================
|ID|OPERATOR      |NAME            |EST. ROWS|COST|
---------------------------------------------------
|0 |MERGE GROUP BY|                |71       |85  |
|1 | TABLE SCAN   |t4(idx_t4_c2_c3)|100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(t4.c2)]), filter(nil), 
      group([t4.c2], [t4.c3]), agg_func([T_FUN_COUNT(t4.c2)])
  1 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c3], [t4.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 733(end)  ************** 

***************   Case 734   ***************

SQL: select count(c2) from t4 group by c3, c1, c2; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t4(idx_t4_c2)|100      |78  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN (T_OP_IS_NOT, t4.c2, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      access([t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c2], [t4.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 734(end)  ************** 

***************   Case 735   ***************

SQL: select count(c2) from y_t4 group by c2, c1; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE GROUP BY|    |71       |85  |
|1 | TABLE SCAN   |y_t4|100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(y_t4.c2)]), filter(nil), 
      group([y_t4.c1], [y_t4.c2]), agg_func([T_FUN_COUNT(y_t4.c2)])
  1 - output([y_t4.c1], [y_t4.c2]), filter(nil), 
      access([y_t4.c1], [y_t4.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([y_t4.c1], [y_t4.c2], [y_t4.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 735(end)  ************** 

***************   Case 736   ***************

SQL: select count(c4) from tg1 group by c4, c3, c5, c2, c1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tg1 |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE WHEN (T_OP_IS_NOT, tg1.c4, NULL, 0) THEN 1 ELSE 0 END]), filter(nil), 
      access([tg1.c4]), partitions(p0), 
      is_index_back=false, 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 736(end)  ************** 

***************   Case 737   ***************

SQL: select distinct c3, c2, c4, c5, c1 from tg1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tg1 |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tg1.c3], [tg1.c2], [tg1.c4], [tg1.c5], [tg1.c1]), filter(nil), 
      access([tg1.c1], [tg1.c2], [tg1.c3], [tg1.c4], [tg1.c5]), partitions(p0), 
      is_index_back=false, 
      range_key([tg1.c1], [tg1.c2], [tg1.c3]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 737(end)  ************** 

***************   Case 738   ***************

SQL: select distinct b from y_t5 where (a2 >= 'b') and (b = 'a'); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|y_t5|0        |84  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t5.b]), filter([y_t5.a2 >= ?], [y_t5.b = ?]), 
      access([y_t5.a2], [y_t5.b]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([y_t5.__pk_increment], [y_t5.__pk_cluster_id], [y_t5.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 738(end)  ************** 

***************   Case 739   ***************

SQL: select distinct c2 from y_t6 where c1=c2; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|y_t6(y_t6_i1)|1        |80  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t6.c2]), filter([y_t6.c1 = y_t6.c2]), 
      access([y_t6.c1], [y_t6.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([y_t6.c2], [y_t6.c3], [y_t6.c1]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 739(end)  ************** 

***************   Case 740   ***************

SQL: select * from tt1 where c2 like "a%"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |90       |84  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_LIKE, tt1.c2, ?, '\\')]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 740(end)  ************** 

***************   Case 741   ***************

SQL: select * from tt1 where c2 like "%a"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |34       |84  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_LIKE, tt1.c2, ?, '\\')]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 741(end)  ************** 

***************   Case 742   ***************

SQL: select * from tt1 where c2 like "ab%"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |5        |84  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_LIKE, tt1.c2, ?, '\\')]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 742(end)  ************** 

***************   Case 743   ***************

SQL: select * from tt1 where c2 between "aa" and "ab"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |5        |84  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([tt1.c2 <= ?], [tt1.c2 >= ?]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 743(end)  ************** 

***************   Case 744   ***************

SQL: select * from tt1 where c2 between "aa" and "ai"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |30       |84  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([tt1.c2 <= ?], [tt1.c2 >= ?]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 744(end)  ************** 

***************   Case 745   ***************

SQL: select * from tt1 where c2 not between "aa" and "ab"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |88       |80  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([tt1.c2 < ? OR tt1.c2 > ?]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 745(end)  ************** 

***************   Case 746   ***************

SQL: select * from tt1 where c2 not between "aa" and "ai"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |63       |80  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([tt1.c2 < ? OR tt1.c2 > ?]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 746(end)  ************** 

***************   Case 747   ***************

SQL: select * from tt1 where "ag" between c2 and "ai"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |23       |84  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_BTW, ?, tt1.c2, ?)]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 747(end)  ************** 

***************   Case 748   ***************

SQL: select * from tt1 where "ag" between "aa" and "c2"; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter(nil), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 748(end)  ************** 

***************   Case 749   ***************

SQL: select * from tt1 where 'ag' not between c1 and 'ai'; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tt1 |34       |84  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2]), filter([(T_OP_NOT_BTW, ?, tt1.c1, ?)]), 
      access([tt1.c1], [tt1.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tt1.c1]), range(MIN ; MAX)always true

*************** Case 749(end)  ************** 

***************   Case 750   ***************

SQL: select /*+index(t_normal_idx idx)*/* from t_normal_idx order by c3 limit 1; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |111 |
|1 | TOP-N SORT     |                  |1        |80  |
|2 |  TABLE SCAN    |t_normal_idx(idx) |100      |78  |
|3 | TABLE GET      |t_normal_idx_alias|1        |31  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c2], [t_normal_idx.c3], [t_normal_idx_alias.c4], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=false
  1 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  2 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  3 - output([t_normal_idx_alias.c2], [t_normal_idx_alias.c4], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      access([t_normal_idx_alias.c2], [t_normal_idx_alias.c4], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 750(end)  ************** 

***************   Case 751   ***************

SQL: select /*+index(t_normal_idx idx)*/* from t_normal_idx where c4>1 order by c3 limit 1; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |112 |
|1 | TOP-N SORT     |                  |1        |81  |
|2 |  TABLE SCAN    |t_normal_idx(idx) |86       |79  |
|3 | TABLE GET      |t_normal_idx_alias|1        |31  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=false
  1 - output([t_normal_idx.c1], [t_normal_idx.c3], [t_normal_idx.c4]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  2 - output([t_normal_idx.c1], [t_normal_idx.c4], [t_normal_idx.c3]), filter([t_normal_idx.c4 > ?]), 
      access([t_normal_idx.c1], [t_normal_idx.c4], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  3 - output([t_normal_idx_alias.c2], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      access([t_normal_idx_alias.c2], [t_normal_idx_alias.c5], [t_normal_idx_alias.c6], [t_normal_idx_alias.c7], [t_normal_idx_alias.c8], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 751(end)  ************** 

***************   Case 752   ***************

SQL: select /*+index(t_normal_idx idx)*/* from t_normal_idx order by c2 limit 1; 

================================================
|ID|OPERATOR  |NAME             |EST. ROWS|COST|
------------------------------------------------
|0 |TABLE SCAN|t_normal_idx(idx)|1        |46  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9], [t_normal_idx.c10]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9], [t_normal_idx.c10]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=true, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 752(end)  ************** 

***************   Case 753   ***************

SQL: select /*+index(t_normal_idx idx)*/* from t_normal_idx where c10>1 order by c3 limit 1; 

=================================================
|ID|OPERATOR   |NAME             |EST. ROWS|COST|
-------------------------------------------------
|0 |TOP-N SORT |                 |1        |138 |
|1 | TABLE SCAN|t_normal_idx(idx)|86       |135 |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9], [t_normal_idx.c10]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  1 - output([t_normal_idx.c1], [t_normal_idx.c10], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9]), filter([t_normal_idx.c10 > ?]), 
      access([t_normal_idx.c1], [t_normal_idx.c10], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9]), partitions(p0), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 753(end)  ************** 

***************   Case 754   ***************

SQL: select /*+index(t_normal_idx idx)*/c2,c9,c10 from t_normal_idx order by c3 limit 1; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |111 |
|1 | TOP-N SORT     |                  |1        |80  |
|2 |  TABLE SCAN    |t_normal_idx(idx) |100      |78  |
|3 | TABLE GET      |t_normal_idx_alias|1        |31  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx_alias.c2], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=false
  1 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  2 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  3 - output([t_normal_idx_alias.c2], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), filter(nil), 
      access([t_normal_idx_alias.c2], [t_normal_idx_alias.c9], [t_normal_idx_alias.c10]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 754(end)  ************** 

***************   Case 755   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 limit 1; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |111 |
|1 | TOP-N SORT     |                  |1        |80  |
|2 |  TABLE SCAN    |t_normal_idx(idx) |100      |78  |
|3 | TABLE GET      |t_normal_idx_alias|1        |31  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=false
  1 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  2 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  3 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 755(end)  ************** 

***************   Case 756   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c1 limit 1; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |110 |
|1 | TOP-N SORT     |                  |1        |80  |
|2 |  TABLE SCAN    |t_normal_idx(idx) |100      |78  |
|3 | TABLE GET      |t_normal_idx_alias|1        |31  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=false
  1 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c1, ASC]), topn(1)
  2 - output([t_normal_idx.c1]), filter(nil), 
      access([t_normal_idx.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  3 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 756(end)  ************** 

***************   Case 757   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 limit 1 offset 10; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |120 |
|1 | LIMIT          |                  |1        |89  |
|2 |  TOP-N SORT    |                  |11       |89  |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |78  |
|4 | TABLE GET      |t_normal_idx_alias|1        |31  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=false
  1 - output([t_normal_idx.c1]), filter(nil), limit(1), offset(?)
  2 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1 + ?)
  3 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 757(end)  ************** 

***************   Case 758   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 desc limit 1 offset 10; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |120 |
|1 | LIMIT          |                  |1        |89  |
|2 |  TOP-N SORT    |                  |11       |89  |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |78  |
|4 | TABLE GET      |t_normal_idx_alias|1        |31  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=false
  1 - output([t_normal_idx.c1]), filter(nil), limit(1), offset(?)
  2 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, DESC]), topn(1 + ?)
  3 - output([t_normal_idx.c1], [t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 758(end)  ************** 

***************   Case 759   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 desc ,c4 desc limit 1 offset 10; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |121 |
|1 | LIMIT          |                  |1        |90  |
|2 |  TOP-N SORT    |                  |11       |90  |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |78  |
|4 | TABLE GET      |t_normal_idx_alias|1        |31  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=false
  1 - output([t_normal_idx.c1]), filter(nil), limit(1), offset(?)
  2 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, DESC], [t_normal_idx.c4, DESC]), topn(1 + ?)
  3 - output([t_normal_idx.c1], [t_normal_idx.c3], [t_normal_idx.c4]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3], [t_normal_idx.c4]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 759(end)  ************** 

***************   Case 760   ***************

SQL: select /*+index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 desc, c4 limit 1 offset 10; 

=======================================================
|ID|OPERATOR        |NAME              |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN|                  |1        |121 |
|1 | LIMIT          |                  |1        |90  |
|2 |  TOP-N SORT    |                  |11       |90  |
|3 |   TABLE SCAN   |t_normal_idx(idx) |100      |78  |
|4 | TABLE GET      |t_normal_idx_alias|1        |31  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx_alias.c9]), filter(nil), 
      conds(nil), nl_params_([t_normal_idx.c1]), batch_join=false
  1 - output([t_normal_idx.c1]), filter(nil), limit(1), offset(?)
  2 - output([t_normal_idx.c1]), filter(nil), sort_keys([t_normal_idx.c3, DESC], [t_normal_idx.c4, ASC]), topn(1 + ?)
  3 - output([t_normal_idx.c1], [t_normal_idx.c3], [t_normal_idx.c4]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c3], [t_normal_idx.c4]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true
  4 - output([t_normal_idx_alias.c9]), filter(nil), 
      access([t_normal_idx_alias.c9]), partitions(p0), 
      is_index_back=false, 
      range_key([t_normal_idx_alias.c1]), range(MIN ; MAX), 
      range_cond([t_normal_idx_alias.c1 = ?])

*************** Case 760(end)  ************** 

***************   Case 761   ***************

SQL: select /*+no_use_late_materialization index(t_normal_idx idx)*/c1,c9 from t_normal_idx order by c3 desc limit 1 offset 10; 

==================================================
|ID|OPERATOR    |NAME             |EST. ROWS|COST|
--------------------------------------------------
|0 |LIMIT       |                 |1        |108 |
|1 | TOP-N SORT |                 |11       |108 |
|2 |  TABLE SCAN|t_normal_idx(idx)|100      |97  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx.c9]), filter(nil), limit(1), offset(?)
  1 - output([t_normal_idx.c1], [t_normal_idx.c9]), filter(nil), sort_keys([t_normal_idx.c3, DESC]), topn(1 + ?)
  2 - output([t_normal_idx.c1], [t_normal_idx.c9], [t_normal_idx.c3]), filter(nil), 
      access([t_normal_idx.c1], [t_normal_idx.c9], [t_normal_idx.c3]), partitions(p0), 
      is_index_back=true, 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 761(end)  ************** 

***************   Case 762   ***************

SQL: select /*+use_late_materialization index(t_normal_idx idx)*/* from t_normal_idx where c10>1 order by c3 limit 1; 

=================================================
|ID|OPERATOR   |NAME             |EST. ROWS|COST|
-------------------------------------------------
|0 |TOP-N SORT |                 |1        |138 |
|1 | TABLE SCAN|t_normal_idx(idx)|86       |135 |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_normal_idx.c1], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9], [t_normal_idx.c10]), filter(nil), sort_keys([t_normal_idx.c3, ASC]), topn(1)
  1 - output([t_normal_idx.c1], [t_normal_idx.c10], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9]), filter([t_normal_idx.c10 > ?]), 
      access([t_normal_idx.c1], [t_normal_idx.c10], [t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c7], [t_normal_idx.c8], [t_normal_idx.c9]), partitions(p0), 
      is_index_back=true, filter_before_indexback[false], 
      range_key([t_normal_idx.c2], [t_normal_idx.c3], [t_normal_idx.c4], [t_normal_idx.c5], [t_normal_idx.c6], [t_normal_idx.c1]), range(MIN,MIN,MIN,MIN,MIN,MIN ; MAX,MAX,MAX,MAX,MAX,MAX)always true

*************** Case 762(end)  ************** 

***************   Case 763   ***************

SQL: select * from t7, t8 where t7.c1 = t8.c1 limit 1; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |LIMIT            |    |1        |56  |
|1 | NESTED-LOOP JOIN|    |1        |56  |
|2 |  TABLE SCAN     |t7  |1        |46  |
|3 |  TABLE GET      |t8  |1        |5   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), limit(1), offset(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_([t7.c1]), batch_join=true
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX), 
      range_cond([? = t8.c1])

*************** Case 763(end)  ************** 

***************   Case 764   ***************

SQL: select * from t7, t8 where t7.c1 = t8.c2 limit 1; 

==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |LIMIT            |    |1        |56  |
|1 | NESTED-LOOP JOIN|    |1        |56  |
|2 |  TABLE SCAN     |t8  |2        |46  |
|3 |  TABLE GET      |t7  |1        |5   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), limit(1), offset(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_([t8.c2]), batch_join=true
  2 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX), 
      range_cond([t7.c1 = ?])

*************** Case 764(end)  ************** 

***************   Case 765   ***************

SQL: select * from t7, t8 where t7.c2 = t8.c2 limit 1; 

=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |LIMIT       |    |1        |148 |
|1 | HASH JOIN  |    |1        |148 |
|2 |  TABLE SCAN|t7  |100      |78  |
|3 |  TABLE SCAN|t8  |1        |46  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), limit(1), offset(nil)
  1 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      equal_conds([t7.c2 = t8.c2]), other_conds(nil)
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 765(end)  ************** 

***************   Case 766   ***************

SQL: select * from t7 where c1=c2 and c2='1'; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |1        |81  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter([t7.c1 = t7.c2], [cast(t7.c2, DECIMAL(11, 0)) = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 766(end)  ************** 

***************   Case 767   ***************

SQL: select * from y_t7 where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|y_t7|1        |79  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([y_t7.c1], [y_t7.c2], [y_t7.c3]), filter([cast(y_t7.c1, DATETIME(-1, -1)) = ?], [cast(y_t7.c1, DECIMAL(20, 0)) = cast(y_t7.c2, DECIMAL(-1, -1))]), 
      access([y_t7.c1], [y_t7.c2], [y_t7.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([y_t7.__pk_increment], [y_t7.__pk_cluster_id], [y_t7.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true

*************** Case 767(end)  ************** 

***************   Case 768   ***************

SQL: select * from t1 order by c1,(select c1 from t2); 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SORT                     |        |500      |919 |
|1 | SUBPLAN FILTER          |        |500      |816 |
|2 |  PX COORDINATOR         |        |500      |528 |
|3 |   EXCHANGE OUT DISTR    |:EX10000|500      |481 |
|4 |    PX PARTITION ITERATOR|        |500      |387 |
|5 |     TABLE SCAN          |t1      |500      |387 |
|6 |  PX COORDINATOR         |        |300      |280 |
|7 |   EXCHANGE OUT DISTR    |:EX20000|300      |263 |
|8 |    PX PARTITION ITERATOR|        |300      |233 |
|9 |     TABLE SCAN          |t2      |300      |233 |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil)
  7 - output([t2.c1]), filter(nil), dop=1
  8 - output([t2.c1]), filter(nil), 
      force partition granule.
  9 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 768(end)  ************** 

***************   Case 769   ***************

SQL: select * from (select * from t1 order by c1)v; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |631 |
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |584 |
|2 |  SORT                    |        |500      |490 |
|3 |   PX PARTITION ITERATOR  |        |500      |387 |
|4 |    TABLE SCAN            |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 769(end)  ************** 

***************   Case 770   ***************

SQL: select * from (select * from t1 order by c1)v,t2; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |150000   |8729|
|1 | PX COORDINATOR           |        |300      |464 |
|2 |  EXCHANGE OUT DISTR      |:EX10000|300      |391 |
|3 |   PX PARTITION ITERATOR  |        |300      |233 |
|4 |    TABLE SCAN            |t2      |300      |233 |
|5 | MATERIAL                 |        |500      |531 |
|6 |  PX COORDINATOR          |        |500      |528 |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500      |481 |
|8 |    PX PARTITION ITERATOR |        |500      |387 |
|9 |     TABLE SCAN           |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 770(end)  ************** 

***************   Case 771   ***************

SQL: select * from (select * from t1 order by c1)v,(select * from t2 order by c1)vv; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |150000   |8729|
|1 | PX COORDINATOR           |        |300      |464 |
|2 |  EXCHANGE OUT DISTR      |:EX10000|300      |391 |
|3 |   PX PARTITION ITERATOR  |        |300      |233 |
|4 |    TABLE SCAN            |t2      |300      |233 |
|5 | MATERIAL                 |        |500      |531 |
|6 |  PX COORDINATOR          |        |500      |528 |
|7 |   EXCHANGE OUT DISTR     |:EX20000|500      |481 |
|8 |    PX PARTITION ITERATOR |        |500      |387 |
|9 |     TABLE SCAN           |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 771(end)  ************** 

***************   Case 772   ***************

SQL: select * from t1 order by c1,(select c1 from t2 order by c1,(select c1 from t3 order by c1)); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SORT                      |        |500      |1111|
|1 | SUBPLAN FILTER           |        |500      |1008|
|2 |  PX COORDINATOR          |        |500      |528 |
|3 |   EXCHANGE OUT DISTR     |:EX10000|500      |481 |
|4 |    PX PARTITION ITERATOR |        |500      |387 |
|5 |     TABLE SCAN           |t1      |500      |387 |
|6 |  SUBPLAN FILTER          |        |300      |472 |
|7 |   PX COORDINATOR         |        |300      |280 |
|8 |    EXCHANGE OUT DISTR    |:EX20000|300      |263 |
|9 |     PX PARTITION ITERATOR|        |300      |233 |
|10|      TABLE SCAN          |t2      |300      |233 |
|11|   PX COORDINATOR         |        |200      |187 |
|12|    EXCHANGE OUT DISTR    |:EX30000|200      |176 |
|13|     PX PARTITION ITERATOR|        |200      |155 |
|14|      TABLE SCAN          |t3      |200      |155 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule.
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  11 - output([t3.c1]), filter(nil)
  12 - output([t3.c1]), filter(nil), dop=1
  13 - output([t3.c1]), filter(nil), 
      force partition granule.
  14 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 772(end)  ************** 

***************   Case 773   ***************

SQL: (select c1 from t1) intersect (select c1 from t2); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |928 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |912 |
|2 |  HASH INTERSECT DISTINCT    |        |300      |881 |
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |300      |280 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|7 |     PX PARTITION ITERATOR   |        |300      |233 |
|8 |      TABLE SCAN             |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(INTERSECT([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(INTERSECT([1]))]), filter(nil), dop=1
  2 - output([INTERSECT([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  7 - output([t2.c1]), filter(nil), 
      force partition granule.
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 773(end)  ************** 

***************   Case 774   ***************

SQL: (select c1 from t1 order by c1) intersect (select c1 from t2 order by c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |300      |928 |
|1 | EXCHANGE OUT DISTR          |:EX10001|300      |912 |
|2 |  HASH INTERSECT DISTINCT    |        |300      |881 |
|3 |   PX PARTITION ITERATOR     |        |500      |387 |
|4 |    TABLE SCAN               |t1      |500      |387 |
|5 |   EXCHANGE IN DISTR         |        |300      |280 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|7 |     PX PARTITION ITERATOR   |        |300      |233 |
|8 |      TABLE SCAN             |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(INTERSECT([1]))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(INTERSECT([1]))]), filter(nil), dop=1
  2 - output([INTERSECT([1])]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1]), filter(nil)
  6 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  7 - output([t2.c1]), filter(nil), 
      force partition granule.
  8 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 774(end)  ************** 

***************   Case 775   ***************

SQL: (select c1 from t1 order by c2,(select c1 from t3 order by c1)) intersect (select c1 from t2 order by c2,(select c1 from t3 order by c1)); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |MERGE INTERSECT DISTINCT  |        |300      |1311|
|1 | SORT                     |        |500      |763 |
|2 |  SUBPLAN FILTER          |        |500      |661 |
|3 |   PX COORDINATOR         |        |500      |466 |
|4 |    EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|5 |     PX PARTITION ITERATOR|        |500      |387 |
|6 |      TABLE SCAN          |t1      |500      |387 |
|7 |   PX COORDINATOR         |        |200      |187 |
|8 |    EXCHANGE OUT DISTR    |:EX20000|200      |176 |
|9 |     PX PARTITION ITERATOR|        |200      |155 |
|10|      TABLE SCAN          |t3      |200      |155 |
|11| SORT                     |        |300      |532 |
|12|  SUBPLAN FILTER          |        |300      |472 |
|13|   PX COORDINATOR         |        |300      |280 |
|14|    EXCHANGE OUT DISTR    |:EX30000|300      |263 |
|15|     PX PARTITION ITERATOR|        |300      |233 |
|16|      TABLE SCAN          |t2      |300      |233 |
|17|   PX COORDINATOR         |        |200      |187 |
|18|    EXCHANGE OUT DISTR    |:EX40000|200      |176 |
|19|     PX PARTITION ITERATOR|        |200      |155 |
|20|      TABLE SCAN          |t3      |200      |155 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERSECT([1])]), filter(nil)
  1 - output([t1.c1]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  2 - output([t1.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  3 - output([t1.c1]), filter(nil)
  4 - output([t1.c1]), filter(nil), dop=1
  5 - output([t1.c1]), filter(nil), 
      force partition granule.
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t3.c1]), filter(nil)
  8 - output([t3.c1]), filter(nil), dop=1
  9 - output([t3.c1]), filter(nil), 
      force partition granule.
  10 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  11 - output([t2.c1]), filter(nil), sort_keys([t2.c1, ASC]), local merge sort
  12 - output([t2.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  13 - output([t2.c1]), filter(nil)
  14 - output([t2.c1]), filter(nil), dop=1
  15 - output([t2.c1]), filter(nil), 
      force partition granule.
  16 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  17 - output([t3.c1]), filter(nil)
  18 - output([t3.c1]), filter(nil), dop=1
  19 - output([t3.c1]), filter(nil), 
      force partition granule.
  20 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true

*************** Case 775(end)  ************** 

***************   Case 776   ***************

SQL: select * from t1 order by c1,(select c1 from t2 where t1.c1=t2.c1 order by c1,(select c1 from t3 where t1.c1=t3.c1)); 

=========================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST  |
---------------------------------------------------------
|0 |SORT                      |        |500      |313361|
|1 | SUBPLAN FILTER           |        |500      |313251|
|2 |  PX COORDINATOR          |        |500      |528   |
|3 |   EXCHANGE OUT DISTR     |:EX10000|500      |481   |
|4 |    PX PARTITION ITERATOR |        |500      |387   |
|5 |     TABLE SCAN           |t1      |500      |387   |
|6 |  SUBPLAN FILTER          |        |1        |228   |
|7 |   PX COORDINATOR         |        |1        |137   |
|8 |    EXCHANGE OUT DISTR    |:EX20000|1        |137   |
|9 |     PX PARTITION ITERATOR|        |1        |137   |
|10|      TABLE GET           |t2      |1        |137   |
|11|   PX COORDINATOR         |        |1        |91    |
|12|    EXCHANGE OUT DISTR    |:EX30000|1        |91    |
|13|     PX PARTITION ITERATOR|        |1        |91    |
|14|      TABLE GET           |t3      |1        |91    |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC], [subquery(1), ASC]), local merge sort
  1 - output([t1.c1], [subquery(1)], [t1.c2]), filter(nil), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  6 - output([t2.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule.
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([? = t2.c1])
  11 - output([t3.c1]), filter(nil)
  12 - output([t3.c1]), filter(nil), dop=1
  13 - output([t3.c1]), filter(nil), 
      force partition granule.
  14 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true, 
      range_cond([? = t3.c1])

*************** Case 776(end)  ************** 

***************   Case 777   ***************

SQL: select t12.c1 from t1 t12,t2 t22 where t12.c1 in (select c3 from t1 where c1=5 AND c2>=t22.c1); 

======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |HASH JOIN                |        |100      |788 |
|1 | PX COORDINATOR          |        |500      |466 |
|2 |  EXCHANGE OUT DISTR     |:EX10000|500      |439 |
|3 |   PX PARTITION ITERATOR |        |500      |387 |
|4 |    TABLE SCAN           |t12     |500      |387 |
|5 | NESTED-LOOP JOIN        |        |100      |174 |
|6 |  TABLE GET              |t1      |1        |46  |
|7 |  PX COORDINATOR         |        |100      |84  |
|8 |   EXCHANGE OUT DISTR    |:EX20000|100      |64  |
|9 |    PX PARTITION ITERATOR|        |100      |19  |
|10|     TABLE SCAN          |t22     |100      |19  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil), 
      equal_conds([cast(t12.c1, DECIMAL(11, 0)) = cast(t22.c3, DECIMAL(-1, -1))]), other_conds(nil)
  1 - output([t12.c1]), filter(nil)
  2 - output([t12.c1]), filter(nil), dop=1
  3 - output([t12.c1]), filter(nil), 
      force partition granule.
  4 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true
  5 - output([t22.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c2]), batch_join=false
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])
  7 - output([t22.c3]), filter(nil)
  8 - output([t22.c3]), filter(nil), dop=1
  9 - output([t22.c3]), filter(nil), 
      force partition granule.
  10 - output([t22.c3]), filter(nil), 
      access([t22.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX), 
      range_cond([? >= t22.c1])

*************** Case 777(end)  ************** 

***************   Case 778   ***************

SQL: select t12.c1 from t1 t12,t2 t22 where t12.c1 not in (select c3 from t1 where c1=5 AND c2>=t22.c1); 

=========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST |
---------------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN      |        |124950   |28755|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |8631 |
|2 |  PX COORDINATOR           |        |300      |428  |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |366  |
|4 |    PX PARTITION ITERATOR  |        |300      |233  |
|5 |     TABLE SCAN            |t22     |300      |233  |
|6 |  MATERIAL                 |        |500      |468  |
|7 |   PX COORDINATOR          |        |500      |466  |
|8 |    EXCHANGE OUT DISTR     |:EX20000|500      |439  |
|9 |     PX PARTITION ITERATOR |        |500      |387  |
|10|      TABLE SCAN           |t12     |500      |387  |
|11| MATERIAL                  |        |1        |46   |
|12|  SUBPLAN SCAN             |VIEW1   |1        |46   |
|13|   TABLE GET               |t1      |1        |46   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil), 
      conds([VIEW1.t1.c2 >= t22.c1], [cast(t12.c1, DECIMAL(11, 0)) = cast(t22.c3, DECIMAL(-1, -1)) OR (T_OP_IS, cast(t22.c3, DECIMAL(-1, -1)), NULL, 0)]), nl_params_(nil), batch_join=false
  1 - output([t12.c1], [t22.c1], [t22.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t22.c1], [t22.c3]), filter(nil)
  3 - output([t22.c1], [t22.c3]), filter(nil), dop=1
  4 - output([t22.c1], [t22.c3]), filter(nil), 
      force partition granule.
  5 - output([t22.c1], [t22.c3]), filter(nil), 
      access([t22.c1], [t22.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX)always true
  6 - output([t12.c1]), filter(nil)
  7 - output([t12.c1]), filter(nil)
  8 - output([t12.c1]), filter(nil), dop=1
  9 - output([t12.c1]), filter(nil), 
      force partition granule.
  10 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true
  11 - output([VIEW1.t1.c2]), filter(nil)
  12 - output([VIEW1.t1.c2]), filter(nil), 
      access([VIEW1.t1.c2])
  13 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])

*************** Case 778(end)  ************** 

***************   Case 779   ***************

SQL: select t12.c1 from t7 t12,t8 t22 where t12.c1 in (select c3 from t4 where c1=5 AND c2>=t22.c1); 

=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |MERGE SEMI JOIN            |     |334      |3172|
|1 | NESTED-LOOP JOIN CARTESIAN|     |10000    |2736|
|2 |  TABLE SCAN               |t12  |100      |78  |
|3 |  MATERIAL                 |     |100      |78  |
|4 |   TABLE SCAN              |t22  |100      |78  |
|5 | SORT                      |     |100      |135 |
|6 |  SUBPLAN SCAN             |VIEW1|100      |80  |
|7 |   TABLE SCAN              |t4   |100      |78  |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil), 
      equal_conds([t12.c1 = VIEW1.t4.c3]), other_conds([VIEW1.t4.c2 >= t22.c1])
  1 - output([t12.c1], [t22.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true
  3 - output([t22.c1]), filter(nil)
  4 - output([t22.c1]), filter(nil), 
      access([t22.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX)always true
  5 - output([VIEW1.t4.c3], [VIEW1.t4.c2]), filter(nil), sort_keys([VIEW1.t4.c3, ASC])
  6 - output([VIEW1.t4.c2], [VIEW1.t4.c3]), filter(nil), 
      access([VIEW1.t4.c2], [VIEW1.t4.c3])
  7 - output([t4.c2], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t4.c1], [t4.c2]), range(5,MIN ; 5,MAX), 
      range_cond([t4.c1 = ?])

*************** Case 779(end)  ************** 

***************   Case 780   ***************

SQL: select t12.c1 from t1 t12,t2 t22 where t12.c1+t22.c1 in (select c3 from t1 where c1=5); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |750      |3182|
|1 | NESTED-LOOP JOIN         |        |750      |2930|
|2 |  PX COORDINATOR          |        |300      |428 |
|3 |   EXCHANGE OUT DISTR     |:EX10000|300      |366 |
|4 |    PX PARTITION ITERATOR |        |300      |233 |
|5 |     TABLE SCAN           |t22     |300      |233 |
|6 |  MATERIAL                |        |500      |468 |
|7 |   PX COORDINATOR         |        |500      |466 |
|8 |    EXCHANGE OUT DISTR    |:EX20000|500      |439 |
|9 |     PX PARTITION ITERATOR|        |500      |387 |
|10|      TABLE SCAN          |t12     |500      |387 |
|11| MATERIAL                 |        |1        |46  |
|12|  TABLE GET               |t1      |1        |46  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t12.c1]), filter(nil), 
      conds([cast(t12.c1 + t22.c1, DECIMAL(12, 0)) = cast(t22.c3, DECIMAL(-1, -1))]), nl_params_(nil), batch_join=false
  2 - output([t22.c1], [t22.c3]), filter(nil)
  3 - output([t22.c1], [t22.c3]), filter(nil), dop=1
  4 - output([t22.c1], [t22.c3]), filter(nil), 
      force partition granule.
  5 - output([t22.c1], [t22.c3]), filter(nil), 
      access([t22.c1], [t22.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX)always true
  6 - output([t12.c1]), filter(nil)
  7 - output([t12.c1]), filter(nil)
  8 - output([t12.c1]), filter(nil), dop=1
  9 - output([t12.c1]), filter(nil), 
      force partition granule.
  10 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true
  11 - output(nil), filter(nil)
  12 - output(nil), filter(nil), 
      access([t1.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])

*************** Case 780(end)  ************** 

***************   Case 781   ***************

SQL: select t12.c1 from t1 t12,t2 t22 where t12.c1+t22.c1 not in (select c3 from t1 where c1=5); 

=========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST |
---------------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN      |        |74626    |38598|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |8631 |
|2 |  PX COORDINATOR           |        |300      |428  |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |366  |
|4 |    PX PARTITION ITERATOR  |        |300      |233  |
|5 |     TABLE SCAN            |t22     |300      |233  |
|6 |  MATERIAL                 |        |500      |468  |
|7 |   PX COORDINATOR          |        |500      |466  |
|8 |    EXCHANGE OUT DISTR     |:EX20000|500      |439  |
|9 |     PX PARTITION ITERATOR |        |500      |387  |
|10|      TABLE SCAN           |t12     |500      |387  |
|11| MATERIAL                  |        |1        |46   |
|12|  SUBPLAN SCAN             |VIEW1   |1        |46   |
|13|   TABLE GET               |t1      |1        |46   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil), 
      conds([cast(t12.c1 + t22.c1, DECIMAL(12, 0)) = cast(t22.c3, DECIMAL(-1, -1)) OR (T_OP_IS, cast(t22.c3, DECIMAL(-1, -1)), NULL, 0)]), nl_params_(nil), batch_join=false
  1 - output([t12.c1], [t22.c1], [t22.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t22.c1], [t22.c3]), filter(nil)
  3 - output([t22.c1], [t22.c3]), filter(nil), dop=1
  4 - output([t22.c1], [t22.c3]), filter(nil), 
      force partition granule.
  5 - output([t22.c1], [t22.c3]), filter(nil), 
      access([t22.c1], [t22.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX)always true
  6 - output([t12.c1]), filter(nil)
  7 - output([t12.c1]), filter(nil)
  8 - output([t12.c1]), filter(nil), dop=1
  9 - output([t12.c1]), filter(nil), 
      force partition granule.
  10 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true
  11 - output(nil), filter(nil)
  12 - output(nil), filter(nil), 
      access(nil)
  13 - output([1]), filter(nil), 
      access([t1.c1]), partitions(p0), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])

*************** Case 781(end)  ************** 

***************   Case 782   ***************

SQL: select count(t12.c1) from t1 t12,t2 t22 where t12.c1>SOME(select c3 from t1 where c1=5 AND c1=10 AND c2>=t22.c1) AND t22.c2>=5 AND t12.c2<SOME(select c1 from t1 where c2=3 AND c2<10 AND c3<=t12.c1); 

===============================================================
|ID|OPERATOR                    |NAME         |EST. ROWS|COST |
---------------------------------------------------------------
|0 |SCALAR GROUP BY             |             |1        |578  |
|1 | NESTED-LOOP JOIN           |             |13       |577  |
|2 |  TABLE GET                 |t1           |1        |78   |
|3 |  NESTED-LOOP JOIN          |             |3801     |49476|
|4 |   NESTED-LOOP SEMI JOIN    |             |167      |48045|
|5 |    PX COORDINATOR          |             |500      |528  |
|6 |     EXCHANGE OUT DISTR     |:EX10000     |500      |481  |
|7 |      PX PARTITION ITERATOR |             |500      |387  |
|8 |       TABLE SCAN           |t12          |500      |387  |
|9 |    PX COORDINATOR          |             |1        |227  |
|10|     EXCHANGE OUT DISTR     |:EX20000     |1        |227  |
|11|      SUBPLAN SCAN          |VIEW2        |1        |227  |
|12|       PX PARTITION ITERATOR|             |1        |227  |
|13|        TABLE SCAN          |t1(idx_t1_c2)|1        |227  |
|14|   MATERIAL                 |             |206      |399  |
|15|    PX COORDINATOR          |             |206      |395  |
|16|     EXCHANGE OUT DISTR     |:EX30000     |206      |345  |
|17|      PX PARTITION ITERATOR |             |206      |236  |
|18|       TABLE SCAN           |t22          |206      |236  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(t12.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(t12.c1)])
  1 - output([t12.c1]), filter(nil), 
      conds([t1.c2 >= t22.c1]), nl_params_(nil), batch_join=false
  2 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range(MAX ; MIN)always false, 
      range_cond([t1.c1 = ?], [t1.c1 = ?])
  3 - output([t12.c1], [t22.c1]), filter(nil), 
      conds([cast(t12.c1, DECIMAL(11, 0)) > cast(t22.c3, DECIMAL(-1, -1))], [cast(t22.c3, DECIMAL(-1, -1)) <= cast(t12.c1, DECIMAL(11, 0))]), nl_params_(nil), batch_join=false
  4 - output([t12.c1]), filter(nil), 
      conds(nil), nl_params_([t12.c2]), batch_join=false
  5 - output([t12.c1], [t12.c2]), filter(nil)
  6 - output([t12.c1], [t12.c2]), filter(nil), dop=1
  7 - output([t12.c1], [t12.c2]), filter(nil), 
      force partition granule.
  8 - output([t12.c1], [t12.c2]), filter(nil), 
      access([t12.c1], [t12.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX)always true
  9 - output(nil), filter(nil)
  10 - output(nil), filter(nil), dop=1
  11 - output(nil), filter(nil), 
      access(nil)
  12 - output([t1.c1]), filter(nil), 
      force partition granule.
  13 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(3,MIN ; 3,MAX), 
      range_cond([t1.c2 = ?], [? < t1.c1])
  14 - output([t22.c1], [t22.c3]), filter(nil)
  15 - output([t22.c1], [t22.c3]), filter(nil)
  16 - output([t22.c1], [t22.c3]), filter(nil), dop=1
  17 - output([t22.c1], [t22.c3]), filter(nil), 
      force partition granule.
  18 - output([t22.c1], [t22.c3]), filter([t22.c2 >= ?]), 
      access([t22.c1], [t22.c3], [t22.c2]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t22.c1]), range(MIN ; MAX)always true

*************** Case 782(end)  ************** 

***************   Case 783   ***************

SQL: select c1 from t7 group by c1, (select c2 from t7); 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t7  |100      |78  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 783(end)  ************** 

***************   Case 784   ***************

SQL: select c1 from t7 order by c1, (select c2 from t7); 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |100      |157 |
|1 | TABLE SCAN   |t7  |100      |78  |
|2 | TABLE SCAN   |t7  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t7.c2]), filter(nil), 
      access([t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 784(end)  ************** 

***************   Case 785   ***************

SQL: select * from t7 where c2 in (select c2 from (select c2, sum(c1) from t7 group by c2) t); 

=========================================
|ID|OPERATOR       |NAME |EST. ROWS|COST|
-----------------------------------------
|0 |HASH JOIN      |     |90       |208 |
|1 | SUBPLAN SCAN  |VIEW1|10       |104 |
|2 |  HASH GROUP BY|     |10       |104 |
|3 |   TABLE SCAN  |t7   |100      |78  |
|4 | TABLE SCAN    |t7   |100      |78  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2]), filter(nil), 
      equal_conds([t7.c2 = VIEW1.c2]), other_conds(nil)
  1 - output([VIEW1.c2]), filter(nil), 
      access([VIEW1.c2])
  2 - output([t7.c2]), filter(nil), 
      group([t7.c2]), agg_func(nil)
  3 - output([t7.c2]), filter(nil), 
      access([t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  4 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 785(end)  ************** 

***************   Case 786   ***************

SQL: select * from ts where c1 =1 and c2 > '2011-01-10' order by c2; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |2        |92  |
|1 | EXCHANGE OUT DISTR       |:EX10000|2        |92  |
|2 |  PX PARTITION ITERATOR   |        |2        |91  |
|3 |   TABLE SCAN             |ts      |2        |91  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(ts.c1, ts.c2)]), filter(nil), sort_keys([ts.c2, ASC])
  1 - output([ts.c2], [INTERNAL_FUNCTION(ts.c1, ts.c2)]), filter(nil), dop=1
  2 - output([ts.c1], [ts.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([ts.c1], [ts.c2]), filter(nil), 
      access([ts.c1], [ts.c2]), partitions(p1sp[0-1]), 
      is_index_back=false, 
      range_key([ts.c1], [ts.c2]), range(1,2011-01-10 00:00:00.000000 ; 1,MAX), 
      range_cond([ts.c1 = ?], [ts.c2 > ?])

*************** Case 786(end)  ************** 

***************   Case 787   ***************

SQL: select * from tr where c1 > 1 order by c1; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |257      |304 |
|1 | EXCHANGE OUT DISTR       |:EX10000|257      |280 |
|2 |  PX PARTITION ITERATOR   |        |257      |232 |
|3 |   TABLE SCAN             |tr      |257      |232 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(tr.c1, tr.c2)]), filter(nil), sort_keys([tr.c1, ASC])
  1 - output([tr.c1], [INTERNAL_FUNCTION(tr.c1, tr.c2)]), filter(nil), dop=1
  2 - output([tr.c1], [tr.c2]), filter(nil), 
      force partition granule, asc.
  3 - output([tr.c1], [tr.c2]), filter(nil), 
      access([tr.c1], [tr.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([tr.c1], [tr.c2]), range(1,MAX ; MAX,MAX), 
      range_cond([tr.c1 > ?])

*************** Case 787(end)  ************** 

***************   Case 788   ***************

SQL: select/*+index(t_idx_back t_idx_c2)*/ c3 from t_idx_back; 

===================================================
|ID|OPERATOR  |NAME                |EST. ROWS|COST|
---------------------------------------------------
|0 |TABLE SCAN|t_idx_back(t_idx_c2)|100      |78  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t_idx_back.c3]), filter(nil), 
      access([t_idx_back.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([t_idx_back.c2], [t_idx_back.c1]), range(MIN,MIN ; MAX,MAX)always true

*************** Case 788(end)  ************** 

***************   Case 789   ***************

SQL: select /*+no_use_hash_distinct*/ distinct c2 from t0; 

=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |MERGE DISTINCT|    |10       |137 |
|1 | SORT         |    |100      |133 |
|2 |  TABLE SCAN  |t0  |100      |78  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t0.c2]), filter(nil), 
      distinct([t0.c2])
  1 - output([t0.c2]), filter(nil), sort_keys([t0.c2, ASC])
  2 - output([t0.c2]), filter(nil), 
      access([t0.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 789(end)  ************** 

***************   Case 790   ***************

SQL: select * from tidx where c3 = 1; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|tidx|9        |79  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), filter([tidx.c3 = ?]), 
      access([tidx.c1], [tidx.c3], [tidx.c2], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tidx.c1]), range(MIN ; MAX)always true

*************** Case 790(end)  ************** 

***************   Case 791   ***************

SQL: select * from tidx where c2 > 0 and c2 < 1000 order by c2 limit 100; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|tidx(tidx_c2)|100      |118 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), filter(nil), 
      access([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), partitions(p0), 
      limit(100), offset(nil), 
      is_index_back=true, 
      range_key([tidx.c2], [tidx.c3], [tidx.c1]), range(0,MAX,MAX ; 1000,MIN,MIN), 
      range_cond([tidx.c2 > ?], [tidx.c2 < ?])

*************** Case 791(end)  ************** 

***************   Case 792   ***************

SQL: select * from tidx where c2 > 0 and c2 < 1000 limit 100; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|tidx(tidx_c2)|100      |118 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), filter(nil), 
      access([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), partitions(p0), 
      limit(100), offset(nil), 
      is_index_back=true, 
      range_key([tidx.c2], [tidx.c3], [tidx.c1]), range(0,MAX,MAX ; 1000,MIN,MIN), 
      range_cond([tidx.c2 > ?], [tidx.c2 < ?])

*************** Case 792(end)  ************** 

***************   Case 793   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3) from t2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |300      |1145|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1027|
|2 |  WINDOW FUNCTION             |        |300      |766 |
|3 |   PARTITION SORT             |        |300      |587 |
|4 |    EXCHANGE IN DISTR         |        |300      |464 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |391 |
|6 |      PX PARTITION ITERATOR   |        |300      |233 |
|7 |       TABLE SCAN             |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3))]), filter(nil), dop=1
  2 - output([T_FUN_MAX(t2.c3)], [t2.c1]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
  3 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil), sort_keys([HASH(t2.c2), ASC], [t2.c2, ASC], [t2.c3, ASC])
  4 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c3], [t2.c2], [t2.c1]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule.
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 793(end)  ************** 

***************   Case 794   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3), max(c3) over (partition by c2) from t2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |300      |1444|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1280|
|2 |  WINDOW FUNCTION             |        |300      |917 |
|3 |   PARTITION SORT             |        |300      |587 |
|4 |    EXCHANGE IN DISTR         |        |300      |464 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |391 |
|6 |      PX PARTITION ITERATOR   |        |300      |233 |
|7 |       TABLE SCAN             |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3), T_FUN_MAX(t2.c3))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3), T_FUN_MAX(t2.c3))]), filter(nil), dop=1
  2 - output([T_FUN_MAX(t2.c3)], [T_FUN_MAX(t2.c3)], [t2.c1]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(CURRENT ROW)
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by(nil), window_type(RANGE), upper(UNBOUNDED PRECEDING), lower(UNBOUNDED FOLLOWING)
  3 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil), sort_keys([HASH(t2.c2), ASC], [t2.c2, ASC], [t2.c3, ASC])
  4 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c3], [t2.c2], [t2.c1]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule.
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 794(end)  ************** 

***************   Case 795   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3 rows between 1 preceding and 2 following) from t2 order by c2,c3; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT     |        |300      |1246|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1128|
|2 |  WINDOW FUNCTION             |        |300      |867 |
|3 |   SORT                       |        |300      |688 |
|4 |    EXCHANGE IN DISTR         |        |300      |464 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |391 |
|6 |      PX PARTITION ITERATOR   |        |300      |233 |
|7 |       TABLE SCAN             |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3))]), filter(nil), sort_keys([t2.c2, ASC], [t2.c3, ASC])
  1 - output([t2.c2], [t2.c3], [INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3))]), filter(nil), dop=1
  2 - output([t2.c2], [t2.c3], [T_FUN_MAX(t2.c3)], [t2.c1]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(ROWS), upper(? PRECEDING), lower(? FOLLOWING)
  3 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil), sort_keys([t2.c2, ASC], [t2.c3, ASC])
  4 - output([t2.c2], [t2.c3], [t2.c1]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c2], [t2.c3], [t2.c1]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule.
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 795(end)  ************** 

***************   Case 796   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3 rows between 1 preceding and 2 following) from t2 order by c3,c2; 

============================================================
|ID|OPERATOR                       |NAME    |EST. ROWS|COST|
------------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT      |        |300      |1447|
|1 | EXCHANGE OUT DISTR            |:EX10001|300      |1328|
|2 |  SORT                         |        |300      |1068|
|3 |   WINDOW FUNCTION             |        |300      |766 |
|4 |    PARTITION SORT             |        |300      |587 |
|5 |     EXCHANGE IN DISTR         |        |300      |464 |
|6 |      EXCHANGE OUT DISTR (HASH)|:EX10000|300      |391 |
|7 |       PX PARTITION ITERATOR   |        |300      |233 |
|8 |        TABLE SCAN             |t2      |300      |233 |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3))]), filter(nil), sort_keys([t2.c3, ASC], [t2.c2, ASC])
  1 - output([t2.c3], [t2.c2], [INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3))]), filter(nil), dop=1
  2 - output([t2.c3], [t2.c2], [T_FUN_MAX(t2.c3)], [t2.c1]), filter(nil), sort_keys([t2.c3, ASC], [t2.c2, ASC])
  3 - output([t2.c3], [t2.c2], [T_FUN_MAX(t2.c3)], [t2.c1]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(ROWS), upper(? PRECEDING), lower(? FOLLOWING)
  4 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil), sort_keys([HASH(t2.c2), ASC], [t2.c2, ASC], [t2.c3, ASC])
  5 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil)
  6 - (#keys=1, [t2.c2]), output([t2.c3], [t2.c2], [t2.c1]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule.
  8 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 796(end)  ************** 

***************   Case 797   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3 rows between 1 preceding and unbounded following) from t2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |300      |1145|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1027|
|2 |  WINDOW FUNCTION             |        |300      |766 |
|3 |   PARTITION SORT             |        |300      |587 |
|4 |    EXCHANGE IN DISTR         |        |300      |464 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |391 |
|6 |      PX PARTITION ITERATOR   |        |300      |233 |
|7 |       TABLE SCAN             |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3))]), filter(nil), dop=1
  2 - output([T_FUN_MAX(t2.c3)], [t2.c1]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(ROWS), upper(? PRECEDING), lower(UNBOUNDED FOLLOWING)
  3 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil), sort_keys([HASH(t2.c2), ASC], [t2.c2, ASC], [t2.c3, ASC])
  4 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c3], [t2.c2], [t2.c1]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule.
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 797(end)  ************** 

***************   Case 798   ***************

SQL: select c1, max(c3) over (partition by c2 order by c3 rows between 1 preceding and 2 following) from t2; 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |PX COORDINATOR                |        |300      |1145|
|1 | EXCHANGE OUT DISTR           |:EX10001|300      |1027|
|2 |  WINDOW FUNCTION             |        |300      |766 |
|3 |   PARTITION SORT             |        |300      |587 |
|4 |    EXCHANGE IN DISTR         |        |300      |464 |
|5 |     EXCHANGE OUT DISTR (HASH)|:EX10000|300      |391 |
|6 |      PX PARTITION ITERATOR   |        |300      |233 |
|7 |       TABLE SCAN             |t2      |300      |233 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3))]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, T_FUN_MAX(t2.c3))]), filter(nil), dop=1
  2 - output([T_FUN_MAX(t2.c3)], [t2.c1]), filter(nil), 
      win_expr(T_FUN_MAX(t2.c3)), partition_by([t2.c2]), order_by([t2.c3, ASC]), window_type(ROWS), upper(? PRECEDING), lower(? FOLLOWING)
  3 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil), sort_keys([HASH(t2.c2), ASC], [t2.c2, ASC], [t2.c3, ASC])
  4 - output([t2.c3], [t2.c2], [t2.c1]), filter(nil)
  5 - (#keys=1, [t2.c2]), output([t2.c3], [t2.c2], [t2.c1]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      force partition granule.
  7 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 798(end)  ************** 

***************   Case 799   ***************

SQL: select * from tg where c1 = 'bcde'; 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|tg  |1        |46  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([tg.c1], [tg.c2], [tg.c3]), filter(nil), 
      access([tg.c1], [tg.c2], [tg.c3]), partitions(p0), 
      is_index_back=false, 
      range_key([tg.c1]), range[bcde ; bcde], 
      range_cond([tg.c1 = ?])

*************** Case 799(end)  ************** 

***************   Case 800   ***************

SQL: select * from tg where c1 = 'baaaa'; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |EXCHANGE IN REMOTE  |    |1        |46  |
|1 | EXCHANGE OUT REMOTE|    |1        |46  |
|2 |  TABLE GET         |tg  |1        |46  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([tg.c1], [tg.c2], [tg.c3]), filter(nil)
  1 - output([tg.c1], [tg.c2], [tg.c3]), filter(nil)
  2 - output([tg.c1], [tg.c2], [tg.c3]), filter(nil), 
      access([tg.c1], [tg.c2], [tg.c3]), partitions(p2), 
      is_index_back=false, 
      range_key([tg.c1]), range[baaaa ; baaaa], 
      range_cond([tg.c1 = ?])

*************** Case 800(end)  ************** 

***************   Case 801   ***************

SQL: select * from tg where c1 = 'bcde' and (c2 = 'cde' or c2 = 'baaaa'); 

==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|tg  |1        |46  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([tg.c1], [tg.c2], [tg.c3]), filter([tg.c2 = ? OR tg.c2 = ?]), 
      access([tg.c1], [tg.c2], [tg.c3]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([tg.c1]), range[bcde ; bcde], 
      range_cond([tg.c1 = ?])

*************** Case 801(end)  ************** 

***************   Case 802   ***************

SQL: select z1.a, z2.a from z1 full outer join z2 on z1.a = z2.a order by z1.a, z2.a; 

===============================================
|ID|OPERATOR              |NAME|EST. ROWS|COST|
-----------------------------------------------
|0 |SORT                  |    |100      |245 |
|1 | MERGE FULL OUTER JOIN|    |100      |187 |
|2 |  TABLE SCAN          |z1  |100      |78  |
|3 |  TABLE SCAN          |z2  |100      |78  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([z1.a], [z2.a]), filter(nil), sort_keys([z1.a, ASC], [z2.a, ASC])
  1 - output([z1.a], [z2.a]), filter(nil), 
      equal_conds([z1.a = z2.a]), other_conds(nil)
  2 - output([z1.a]), filter(nil), 
      access([z1.a]), partitions(p0), 
      is_index_back=false, 
      range_key([z1.a]), range(MIN ; MAX)always true
  3 - output([z2.a]), filter(nil), 
      access([z2.a]), partitions(p0), 
      is_index_back=false, 
      range_key([z2.a]), range(MIN ; MAX)always true

*************** Case 802(end)  ************** 

***************   Case 803   ***************

SQL: select t7.c1 from t7,t8 where t7.c1 > (select t0.c1 from t0 where t7.c1); 

======================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST  |
------------------------------------------------------
|0 |SUBPLAN FILTER             |    |3334     |794009|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |2736  |
|2 |  TABLE SCAN               |t7  |100      |78    |
|3 |  MATERIAL                 |    |100      |78    |
|4 |   TABLE SCAN              |t8  |100      |78    |
|5 | TABLE SCAN                |t0  |100      |78    |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([t7.c1 > subquery(1)]), 
      exec_params_([BOOL(t7.c1)]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t0.c1]), filter(nil), startup_filter([?]), 
      access([t0.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 803(end)  ************** 

***************   Case 804   ***************

SQL: select t7.c1 from t7,t8 where t7.c1 > (select t0.c1 from t0 where t7.c1 + 1); 

======================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST  |
------------------------------------------------------
|0 |SUBPLAN FILTER             |    |3334     |794009|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |2736  |
|2 |  TABLE SCAN               |t7  |100      |78    |
|3 |  MATERIAL                 |    |100      |78    |
|4 |   TABLE SCAN              |t8  |100      |78    |
|5 | TABLE SCAN                |t0  |100      |78    |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter([t7.c1 > subquery(1)]), 
      exec_params_([BOOL(t7.c1 + ?)]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil)
  4 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  5 - output([t0.c1]), filter(nil), startup_filter([?]), 
      access([t0.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 804(end)  ************** 

***************   Case 805   ***************

SQL: select t7.c1 from t7,t8 where t7.c1 > (select t0.c1 from t0 where 1); 

====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |3334     |1121|
|1 | NESTED-LOOP JOIN CARTESIAN|    |3334     |985 |
|2 |  TABLE SCAN               |t8  |100      |78  |
|3 |  MATERIAL                 |    |34       |47  |
|4 |   TABLE SCAN              |t7  |34       |46  |
|5 | TABLE SCAN                |t0  |100      |78  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t7.c1]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output(nil), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  3 - output([t7.c1]), filter(nil)
  4 - output([t7.c1]), filter(nil), 
      access([t7.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true, 
      range_cond([t7.c1 > ?])
  5 - output([t0.c1]), filter(nil), 
      access([t0.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t0.pk]), range(MIN ; MAX)always true

*************** Case 805(end)  ************** 

***************   Case 806   ***************

SQL: select t12.c1 from t1 t12,t2 t22 where t12.c1 in (select c3 from t1 where c1 = 5 AND c2 = t22.c1); 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |NESTED-LOOP JOIN              |        |1        |109 |
|1 | PX COORDINATOR               |        |1        |54  |
|2 |  EXCHANGE OUT DISTR          |:EX10001|1        |53  |
|3 |   NESTED-LOOP JOIN           |        |1        |53  |
|4 |    EXCHANGE IN DISTR         |        |1        |46  |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |46  |
|6 |      TABLE GET               |t1      |1        |46  |
|7 |    PX PARTITION ITERATOR     |        |1        |18  |
|8 |     TABLE GET                |t22     |1        |18  |
|9 | PX COORDINATOR               |        |1        |29  |
|10|  EXCHANGE OUT DISTR          |:EX20000|1        |29  |
|11|   PX PARTITION ITERATOR      |        |1        |29  |
|12|    TABLE GET                 |t12     |1        |29  |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t12.c1]), filter(nil), 
      conds(nil), nl_params_([cast(t22.c3, DECIMAL(-1, -1))]), batch_join=false
  1 - output([t22.c3]), filter(nil)
  2 - output([t22.c3]), filter(nil), dop=1
  3 - output([t22.c3]), filter(nil), 
      conds(nil), nl_params_([t1.c2]), batch_join=false
  4 - output([PARTITION_ID], [t1.c2]), filter(nil)
  5 - (#keys=1, [t1.c2]), output([PARTITION_ID], [t1.c2]), filter(nil), is_single, dop=1
  6 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t1.c1]), range[5 ; 5], 
      range_cond([t1.c1 = ?])
  7 - output([t22.c3]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t22.c3]), filter(nil), 
      access([t22.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t22.c1]), range(MIN ; MAX), 
      range_cond([? = t22.c1])
  9 - output([t12.c1]), filter(nil)
  10 - output([t12.c1]), filter(nil), dop=1
  11 - output([t12.c1]), filter(nil), 
      force partition granule.
  12 - output([t12.c1]), filter(nil), 
      access([t12.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t12.c1]), range(MIN ; MAX), 
      range_cond([cast(t12.c1, DECIMAL(11, 0)) = ?])

*************** Case 806(end)  ************** 

***************   Case 807   ***************

SQL: select * from t1 join t5 on t1.c1 = t5.c3 where t5.c3 > 0 and t5.c3 < 100 order by t5.c3 limit 100; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |LIMIT                          |             |100      |1086|
|1 | PX COORDINATOR MERGE SORT     |             |100      |1084|
|2 |  EXCHANGE OUT DISTR           |:EX10001     |100      |1064|
|3 |   TOP-N SORT                  |             |100      |1019|
|4 |    HASH JOIN                  |             |270      |966 |
|5 |     EXCHANGE IN DISTR         |             |270      |392 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000     |270      |357 |
|7 |       PX PARTITION ITERATOR   |             |270      |283 |
|8 |        TABLE SCAN             |t5(idx_t5_c3)|270      |283 |
|9 |     PX PARTITION ITERATOR     |             |500      |387 |
|10|      TABLE SCAN               |t1           |500      |387 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), limit(100), offset(nil)
  1 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC])
  2 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC]), topn(100)
  4 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t1.c1 = t5.c3]), other_conds(nil)
  5 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  6 - (#keys=1, [t5.c3]), output([t5.c1], [t5.c2], [t5.c3]), filter(nil), dop=1
  7 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  8 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, 
      range_key([t5.c3], [t5.c2]), range(0,MAX ; 100,MIN), 
      range_cond([t5.c3 > ?], [t5.c3 < ?])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; 100), 
      range_cond([t1.c1 < ?], [t1.c1 > ?])

*************** Case 807(end)  ************** 

***************   Case 808   ***************

SQL: select * from t1 join t5 on t1.c1 = t5.c3 where t5.c3 > 0 and t5.c3 < 100 order by t5.c3 limit 10000; 

=================================================================
|ID|OPERATOR                       |NAME         |EST. ROWS|COST|
-----------------------------------------------------------------
|0 |LIMIT                          |             |270      |1211|
|1 | PX COORDINATOR MERGE SORT     |             |270      |1206|
|2 |  EXCHANGE OUT DISTR           |:EX10001     |270      |1150|
|3 |   TOP-N SORT                  |             |270      |1031|
|4 |    HASH JOIN                  |             |270      |966 |
|5 |     EXCHANGE IN DISTR         |             |270      |392 |
|6 |      EXCHANGE OUT DISTR (PKEY)|:EX10000     |270      |357 |
|7 |       PX PARTITION ITERATOR   |             |270      |283 |
|8 |        TABLE SCAN             |t5(idx_t5_c3)|270      |283 |
|9 |     PX PARTITION ITERATOR     |             |500      |387 |
|10|      TABLE SCAN               |t1           |500      |387 |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), limit(10000), offset(nil)
  1 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC])
  2 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c3, ASC]), topn(10000)
  4 - output([t1.c1], [t1.c2], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t1.c1 = t5.c3]), other_conds(nil)
  5 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil)
  6 - (#keys=1, [t5.c3]), output([t5.c1], [t5.c2], [t5.c3]), filter(nil), dop=1
  7 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      force partition granule.
  8 - output([t5.c2], [t5.c3], [t5.c1]), filter(nil), 
      access([t5.c2], [t5.c3], [t5.c1]), partitions(p[0-2]), 
      is_index_back=true, 
      range_key([t5.c3], [t5.c2]), range(0,MAX ; 100,MIN), 
      range_cond([t5.c3 > ?], [t5.c3 < ?])
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(0 ; 100), 
      range_cond([t1.c1 < ?], [t1.c1 > ?])

*************** Case 808(end)  ************** 

***************   Case 809   ***************

SQL: select * from tidx where c2 > 0 and c2 < 1000 order by c2 limit 10000; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|tidx(tidx_c2)|100      |118 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), filter(nil), 
      access([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), partitions(p0), 
      limit(10000), offset(nil), 
      is_index_back=true, 
      range_key([tidx.c2], [tidx.c3], [tidx.c1]), range(0,MAX,MAX ; 1000,MIN,MIN), 
      range_cond([tidx.c2 > ?], [tidx.c2 < ?])

*************** Case 809(end)  ************** 

***************   Case 810   ***************

SQL: select * from tidx where c2 > 0 and c2 < 1000 limit 10000; 

============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|tidx(tidx_c2)|100      |118 |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), filter(nil), 
      access([tidx.c1], [tidx.c2], [tidx.c3], [tidx.c4], [tidx.c5], [tidx.c6], [tidx.c7]), partitions(p0), 
      limit(10000), offset(nil), 
      is_index_back=true, 
      range_key([tidx.c2], [tidx.c3], [tidx.c1]), range(0,MAX,MAX ; 1000,MIN,MIN), 
      range_cond([tidx.c2 > ?], [tidx.c2 < ?])

*************** Case 810(end)  ************** 

***************   Case 811   ***************

SQL: select c2 from (select c1, c2 from t1 group by 1) a; 

====================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST|
----------------------------------------------------
|0 |PX COORDINATOR         |        |500      |466 |
|1 | EXCHANGE OUT DISTR    |:EX10000|500      |439 |
|2 |  PX PARTITION ITERATOR|        |500      |387 |
|3 |   TABLE SCAN          |t1      |500      |387 |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c2]), filter(nil), 
      force partition granule.
  3 - output([t1.c2]), filter(nil), 
      access([t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 811(end)  ************** 

***************   Case 812   ***************

SQL: select c2 from (select c1, c2 from t1 order by 1) a; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |631 |
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |584 |
|2 |  SORT                    |        |500      |490 |
|3 |   PX PARTITION ITERATOR  |        |500      |387 |
|4 |    TABLE SCAN            |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), sort_keys([t1.c1, ASC])
  1 - output([t1.c1], [INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), sort_keys([t1.c1, ASC]), local merge sort
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 812(end)  ************** 

***************   Case 813   ***************

SQL: select c2 from (select c1 + c2, c2 from t1 order by 1) a; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |PX COORDINATOR MERGE SORT |        |500      |898 |
|1 | EXCHANGE OUT DISTR       |:EX10000|500      |852 |
|2 |  SORT                    |        |500      |758 |
|3 |   PX PARTITION ITERATOR  |        |500      |387 |
|4 |    TABLE SCAN            |t1      |500      |387 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c2)]), filter(nil), sort_keys([t1.c1 + t1.c2, ASC])
  1 - output([t1.c1 + t1.c2], [INTERNAL_FUNCTION(t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1 + t1.c2], [t1.c2]), filter(nil), sort_keys([t1.c1 + t1.c2, ASC])
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 813(end)  ************** 

***************   Case 814   ***************

SQL: select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 = t2.c1); 

================================================================
|ID|OPERATOR                      |NAME         |EST. ROWS|COST|
----------------------------------------------------------------
|0 |UNION ALL                     |             |255      |1145|
|1 | PX COORDINATOR               |             |5        |229 |
|2 |  EXCHANGE OUT DISTR          |:EX10000     |5        |228 |
|3 |   PX PARTITION ITERATOR      |             |5        |227 |
|4 |    TABLE SCAN                |t1(idx_t1_c2)|5        |227 |
|5 | PX COORDINATOR               |             |251      |913 |
|6 |  EXCHANGE OUT DISTR          |:EX20001     |251      |880 |
|7 |   HASH JOIN                  |             |251      |812 |
|8 |    EXCHANGE IN DISTR         |             |300      |280 |
|9 |     EXCHANGE OUT DISTR (PKEY)|:EX20000     |300      |263 |
|10|      PX PARTITION ITERATOR   |             |300      |233 |
|11|       TABLE SCAN             |t2           |300      |233 |
|12|    PX PARTITION ITERATOR     |             |250      |400 |
|13|     TABLE SCAN               |t1           |250      |400 |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t1.c1], [?]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(5,MIN ; 5,MAX), 
      range_cond([t1.c2 = ?])
  5 - output([t1.c1], [t1.c2]), filter(nil)
  6 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  8 - output([t2.c1]), filter(nil)
  9 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  10 - output([t2.c1]), filter(nil), 
      force partition granule.
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1], [t1.c2]), filter([lnnvl(cast(t1.c2 = ?, TINYINT(-1, 0)))]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 814(end)  ************** 

***************   Case 815   ***************

SQL: select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 > t2.c1); 

============================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST |
------------------------------------------------------------
|0 |UNION ALL                |             |88       |14555|
|1 | PX COORDINATOR          |             |5        |229  |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |5        |228  |
|3 |   PX PARTITION ITERATOR |             |5        |227  |
|4 |    TABLE SCAN           |t1(idx_t1_c2)|5        |227  |
|5 | NESTED-LOOP SEMI JOIN   |             |84       |14326|
|6 |  PX COORDINATOR         |             |250      |470  |
|7 |   EXCHANGE OUT DISTR    |:EX20000     |250      |447  |
|8 |    PX PARTITION ITERATOR|             |250      |400  |
|9 |     TABLE SCAN          |t1           |250      |400  |
|10|  PX COORDINATOR         |             |1        |18   |
|11|   EXCHANGE OUT DISTR    |:EX30000     |1        |18   |
|12|    PX PARTITION ITERATOR|             |1        |18   |
|13|     TABLE SCAN          |t2           |1        |18   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t1.c1], [?]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(5,MIN ; 5,MAX), 
      range_cond([t1.c2 = ?])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter([lnnvl(cast(t1.c2 = ?, TINYINT(-1, 0)))]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output(nil), filter(nil)
  11 - output(nil), filter(nil), dop=1
  12 - output(nil), filter(nil), 
      force partition granule.
  13 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? > t2.c1])

*************** Case 815(end)  ************** 

***************   Case 816   ***************

SQL: select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 < t2.c1); 

============================================================
|ID|OPERATOR                 |NAME         |EST. ROWS|COST |
------------------------------------------------------------
|0 |UNION ALL                |             |88       |14555|
|1 | PX COORDINATOR          |             |5        |229  |
|2 |  EXCHANGE OUT DISTR     |:EX10000     |5        |228  |
|3 |   PX PARTITION ITERATOR |             |5        |227  |
|4 |    TABLE SCAN           |t1(idx_t1_c2)|5        |227  |
|5 | NESTED-LOOP SEMI JOIN   |             |84       |14326|
|6 |  PX COORDINATOR         |             |250      |470  |
|7 |   EXCHANGE OUT DISTR    |:EX20000     |250      |447  |
|8 |    PX PARTITION ITERATOR|             |250      |400  |
|9 |     TABLE SCAN          |t1           |250      |400  |
|10|  PX COORDINATOR         |             |1        |18   |
|11|   EXCHANGE OUT DISTR    |:EX30000     |1        |18   |
|12|    PX PARTITION ITERATOR|             |1        |18   |
|13|     TABLE SCAN          |t2           |1        |18   |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])]), filter(nil)
  1 - output([t1.c1], [?]), filter(nil)
  2 - output([t1.c1]), filter(nil), dop=1
  3 - output([t1.c1]), filter(nil), 
      force partition granule.
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(5,MIN ; 5,MAX), 
      range_cond([t1.c2 = ?])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1]), batch_join=false
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  9 - output([t1.c1], [t1.c2]), filter([lnnvl(cast(t1.c2 = ?, TINYINT(-1, 0)))]), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output(nil), filter(nil)
  11 - output(nil), filter(nil), dop=1
  12 - output(nil), filter(nil), 
      force partition granule.
  13 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([? < t2.c1])

*************** Case 816(end)  ************** 

***************   Case 817   ***************

SQL: select * from t1, t2 where t1.c1 > exists(select c1 from t2 where t2.c1 = t1.c1); 

============================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST    |
------------------------------------------------------------
|0 |SUBPLAN FILTER             |        |50000    |80195533|
|1 | NESTED-LOOP JOIN CARTESIAN|        |150000   |8729    |
|2 |  PX COORDINATOR           |        |300      |464     |
|3 |   EXCHANGE OUT DISTR      |:EX10000|300      |391     |
|4 |    PX PARTITION ITERATOR  |        |300      |233     |
|5 |     TABLE SCAN            |t2      |300      |233     |
|6 |  MATERIAL                 |        |500      |531     |
|7 |   PX COORDINATOR          |        |500      |528     |
|8 |    EXCHANGE OUT DISTR     |:EX20000|500      |481     |
|9 |     PX PARTITION ITERATOR |        |500      |387     |
|10|      TABLE SCAN           |t1      |500      |387     |
|11| LIMIT                     |        |1        |137     |
|12|  PX COORDINATOR           |        |1        |137     |
|13|   EXCHANGE OUT DISTR      |:EX30000|1        |137     |
|14|    LIMIT                  |        |1        |137     |
|15|     PX PARTITION ITERATOR |        |1        |137     |
|16|      TABLE GET            |t2      |1        |137     |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([t1.c1 > (T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  6 - output([t1.c1], [t1.c2]), filter(nil)
  7 - output([t1.c1], [t1.c2]), filter(nil)
  8 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  11 - output([1]), filter(nil), limit(1), offset(nil)
  12 - output(nil), filter(nil)
  13 - output(nil), filter(nil), dop=1
  14 - output(nil), filter(nil), limit(1), offset(nil)
  15 - output(nil), filter(nil), 
      force partition granule.
  16 - output(nil), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = ?])

*************** Case 817(end)  ************** 

***************   Case 818   ***************

SQL: select * from t1 where (select c1 from t2 limit 1)+1 in (select 2 from t3 where t1.c1=t3.c1); 

===========================================================
|ID|OPERATOR                      |NAME    |EST. ROWS|COST|
-----------------------------------------------------------
|0 |SUBPLAN FILTER                |        |200      |962 |
|1 | PX COORDINATOR               |        |200      |822 |
|2 |  EXCHANGE OUT DISTR          |:EX10001|200      |796 |
|3 |   HASH JOIN                  |        |200      |741 |
|4 |    EXCHANGE IN DISTR         |        |200      |187 |
|5 |     EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |176 |
|6 |      PX PARTITION ITERATOR   |        |200      |155 |
|7 |       TABLE SCAN             |t3      |200      |155 |
|8 |    PX PARTITION ITERATOR     |        |500      |387 |
|9 |     TABLE SCAN               |t1      |500      |387 |
|10| LIMIT                        |        |1        |137 |
|11|  PX COORDINATOR              |        |1        |137 |
|12|   EXCHANGE OUT DISTR         |:EX20000|1        |137 |
|13|    LIMIT                     |        |1        |137 |
|14|     PX PARTITION ITERATOR    |        |1        |137 |
|15|      TABLE SCAN              |t2      |1        |137 |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1) + ? = ?]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([?]), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t3.c1]), filter(nil)
  5 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  6 - output([t3.c1]), filter(nil), 
      force partition granule.
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  11 - output([t2.c1]), filter(nil)
  12 - output([t2.c1]), filter(nil), dop=1
  13 - output([t2.c1]), filter(nil), limit(1), offset(nil)
  14 - output([t2.c1]), filter(nil), 
      force partition granule.
  15 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      limit(1), offset(nil), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 818(end)  ************** 

***************   Case 819   ***************

SQL: select * from t1 having count(*) > (select c1 from t2 where t1.c1=t2.c1); 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |SUBPLAN FILTER            |        |1        |940 |
|1 | SCALAR GROUP BY          |        |1        |405 |
|2 |  PX COORDINATOR          |        |1        |405 |
|3 |   EXCHANGE OUT DISTR     |:EX10000|1        |405 |
|4 |    MERGE GROUP BY        |        |1        |405 |
|5 |     PX PARTITION ITERATOR|        |500      |387 |
|6 |      TABLE SCAN          |t1      |500      |387 |
|7 | PX COORDINATOR           |        |1        |137 |
|8 |  EXCHANGE OUT DISTR      |:EX20000|1        |137 |
|9 |   PX PARTITION ITERATOR  |        |1        |137 |
|10|    TABLE GET             |t2      |1        |137 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([T_FUN_COUNT_SUM(T_FUN_COUNT(*)) > subquery(1)]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  2 - output([t1.c1], [t1.c2], [T_FUN_COUNT(*)]), filter(nil)
  3 - output([t1.c1], [t1.c2], [T_FUN_COUNT(*)]), filter(nil), dop=1
  4 - output([t1.c1], [t1.c2], [T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  6 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  7 - output([t2.c1]), filter(nil)
  8 - output([t2.c1]), filter(nil), dop=1
  9 - output([t2.c1]), filter(nil), 
      force partition granule.
  10 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([? = t2.c1])

*************** Case 819(end)  ************** 

***************   Case 820   ***************

SQL: select * from t1, t2 where t2.c1 = t1.c1 and t2.c1 = (select c1 from t3 where t3.c1 = t1.c1); 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |120      |1313|
|1 | EXCHANGE OUT DISTR             |:EX10002|120      |1270|
|2 |  HASH JOIN                     |        |120      |1176|
|3 |   EXCHANGE IN DISTR            |        |200      |822 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|200      |796 |
|5 |     HASH JOIN                  |        |200      |741 |
|6 |      EXCHANGE IN DISTR         |        |200      |187 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |176 |
|8 |        PX PARTITION ITERATOR   |        |200      |155 |
|9 |         TABLE SCAN             |t3      |200      |155 |
|10|      PX PARTITION ITERATOR     |        |500      |387 |
|11|       TABLE SCAN               |t1      |500      |387 |
|12|   PX PARTITION ITERATOR        |        |300      |233 |
|13|    TABLE SCAN                  |t2      |300      |233 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2, t2.c1, t2.c2, t2.c3)]), filter(nil), dop=1
  2 - output([t2.c1], [t1.c1], [t1.c2], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - (#keys=1, [t1.c1]), output([t1.c1], [t1.c2]), filter(nil), dop=1
  5 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t3.c1 = t1.c1]), other_conds(nil)
  6 - output([t3.c1]), filter(nil)
  7 - (#keys=1, [t3.c1]), output([t3.c1]), filter(nil), dop=1
  8 - output([t3.c1]), filter(nil), 
      force partition granule.
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  12 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 820(end)  ************** 

***************   Case 821   ***************

SQL: select * from (select c1+1 as a1 from t1 where t1.c2 = 2) a, t2 where a.a1 = t2.c2 or t2.c1 = ANY(select c3 from t3 where t3.c1 > a.a1); 

=============================================================
|ID|OPERATOR                   |NAME         |EST. ROWS|COST|
-------------------------------------------------------------
|0 |UNION ALL                  |             |13       |2016|
|1 | HASH JOIN                 |             |13       |767 |
|2 |  PX COORDINATOR           |             |5        |229 |
|3 |   EXCHANGE OUT DISTR      |:EX10000     |5        |228 |
|4 |    PX PARTITION ITERATOR  |             |5        |227 |
|5 |     TABLE SCAN            |t1(idx_t1_c2)|5        |227 |
|6 |  PX COORDINATOR           |             |300      |464 |
|7 |   EXCHANGE OUT DISTR      |:EX20000     |300      |391 |
|8 |    PX PARTITION ITERATOR  |             |300      |233 |
|9 |     TABLE SCAN            |t2           |300      |233 |
|10| HASH RIGHT SEMI JOIN      |             |1        |1249|
|11|  PX COORDINATOR           |             |200      |285 |
|12|   EXCHANGE OUT DISTR      |:EX30000     |200      |244 |
|13|    PX PARTITION ITERATOR  |             |200      |155 |
|14|     TABLE SCAN            |t3           |200      |155 |
|15|  NESTED-LOOP JOIN         |             |676      |747 |
|16|   PX COORDINATOR          |             |300      |464 |
|17|    EXCHANGE OUT DISTR     |:EX40000     |300      |391 |
|18|     PX PARTITION ITERATOR |             |300      |233 |
|19|      TABLE SCAN           |t2           |300      |233 |
|20|   MATERIAL                |             |5        |229 |
|21|    PX COORDINATOR         |             |5        |229 |
|22|     EXCHANGE OUT DISTR    |:EX50000     |5        |228 |
|23|      PX PARTITION ITERATOR|             |5        |227 |
|24|       TABLE SCAN          |t1(idx_t1_c2)|5        |227 |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])]), filter(nil)
  1 - output([t1.c1 + ?], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c2]), other_conds(nil)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), dop=1
  4 - output([t1.c1]), filter(nil), 
      force partition granule.
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(2,MIN ; 2,MAX), 
      range_cond([t1.c2 = ?])
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  10 - output([t1.c1 + ?], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([cast(t2.c1, DECIMAL(11, 0)) = cast(t3.c3, DECIMAL(-1, -1))]), other_conds([t3.c1 > t1.c1 + ?])
  11 - output([t3.c1], [t3.c3]), filter(nil)
  12 - output([t3.c1], [t3.c3]), filter(nil), dop=1
  13 - output([t3.c1], [t3.c3]), filter(nil), 
      force partition granule.
  14 - output([t3.c1], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  15 - output([t1.c1 + ?], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds([lnnvl(cast(t1.c1 + ? = t2.c2, TINYINT(-1, 0)))]), nl_params_(nil), batch_join=false
  16 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  17 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  18 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  19 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  20 - output([t1.c1]), filter(nil)
  21 - output([t1.c1]), filter(nil)
  22 - output([t1.c1]), filter(nil), dop=1
  23 - output([t1.c1]), filter(nil), 
      force partition granule.
  24 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c2], [t1.c1]), range(2,MIN ; 2,MAX), 
      range_cond([t1.c2 = ?])

*************** Case 821(end)  ************** 

***************   Case 822   ***************

SQL: select * from t1 where t1.c1 > (select sum(c1) from t2 where t2.c1 = t1.c1); 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |100      |899 |
|1 | EXCHANGE OUT DISTR          |:EX10001|100      |886 |
|2 |  HASH JOIN                  |        |100      |859 |
|3 |   EXCHANGE IN DISTR         |        |300      |280 |
|4 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |263 |
|5 |     PX PARTITION ITERATOR   |        |300      |233 |
|6 |      TABLE SCAN             |t2      |300      |233 |
|7 |   PX PARTITION ITERATOR     |        |500      |387 |
|8 |    TABLE SCAN               |t1      |500      |387 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds([cast(t1.c1, DECIMAL(11, 0)) > cast(t2.c1, DECIMAL(11, 0))])
  3 - output([t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      force partition granule.
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  7 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  8 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true

*************** Case 822(end)  ************** 

***************   Case 823   ***************

SQL: select * from t1 where t1.c1 > (select sum(c1) from t2 where t2.c1 = t1.c1 and t2.c2 > (select max(c2) from t3 where t3.c1 = t2.c1)); 

=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |14       |1052|
|1 | EXCHANGE OUT DISTR             |:EX10002|14       |1049|
|2 |  NESTED-LOOP JOIN              |        |14       |1042|
|3 |   EXCHANGE IN DISTR            |        |67       |599 |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|67       |588 |
|5 |     HASH JOIN                  |        |67       |564 |
|6 |      EXCHANGE IN DISTR         |        |200      |211 |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|200      |193 |
|8 |        PX PARTITION ITERATOR   |        |200      |155 |
|9 |         TABLE SCAN             |t3      |200      |155 |
|10|      PX PARTITION ITERATOR     |        |300      |233 |
|11|       TABLE SCAN               |t2      |300      |233 |
|12|   PX PARTITION ITERATOR        |        |1        |29  |
|13|    TABLE GET                   |t1      |1        |29  |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t1.c1, t1.c2)]), filter(nil), dop=1
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [cast(t2.c1, DECIMAL(11, 0))]), batch_join=false
  3 - output([PARTITION_ID], [t2.c1]), filter(nil)
  4 - (#keys=1, [t2.c1]), output([PARTITION_ID], [t2.c1]), filter(nil), dop=1
  5 - output([t2.c1]), filter(nil), 
      equal_conds([t3.c1 = t2.c1]), other_conds([t2.c2 > t3.c2])
  6 - output([t3.c1], [t3.c2]), filter(nil)
  7 - (#keys=1, [t3.c1]), output([t3.c1], [t3.c2]), filter(nil), dop=1
  8 - output([t3.c1], [t3.c2]), filter(nil), 
      force partition granule.
  9 - output([t3.c1], [t3.c2]), filter(nil), 
      access([t3.c1], [t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  10 - output([t2.c1], [t2.c2]), filter(nil), 
      affinitize, force partition granule.
  11 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true
  12 - output([t1.c1], [t1.c2]), filter(nil), 
      affinitize, force partition granule.
  13 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX), 
      range_cond([? = t1.c1], [cast(t1.c1, DECIMAL(11, 0)) > ?])

*************** Case 823(end)  ************** 

***************   Case 824   ***************

SQL: select * from t1 where t1.c2 in (select avg(c1) from t2 where t2.c1 = t1.c1 union select count(1) from t3 where t3.c1 = t1.c1); 

==========================================================
|ID|OPERATOR                   |NAME    |EST. ROWS|COST  |
----------------------------------------------------------
|0 |SUBPLAN FILTER             |        |250      |313565|
|1 | PX COORDINATOR            |        |500      |528   |
|2 |  EXCHANGE OUT DISTR       |:EX10000|500      |481   |
|3 |   PX PARTITION ITERATOR   |        |500      |387   |
|4 |    TABLE SCAN             |t1      |500      |387   |
|5 | MERGE UNION DISTINCT      |        |2        |228   |
|6 |  SCALAR GROUP BY          |        |1        |137   |
|7 |   PX COORDINATOR          |        |1        |137   |
|8 |    EXCHANGE OUT DISTR     |:EX20000|1        |137   |
|9 |     MERGE GROUP BY        |        |1        |137   |
|10|      PX PARTITION ITERATOR|        |1        |137   |
|11|       TABLE GET           |t2      |1        |137   |
|12|  SCALAR GROUP BY          |        |1        |92    |
|13|   PX COORDINATOR          |        |1        |92    |
|14|    EXCHANGE OUT DISTR     |:EX30000|1        |91    |
|15|     MERGE GROUP BY        |        |1        |91    |
|16|      PX PARTITION ITERATOR|        |1        |91    |
|17|       TABLE GET           |t3      |1        |91    |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([cast(t1.c2, DECIMAL(11, 0)) = ANY(subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([UNION([1])]), filter(nil)
  6 - output([T_FUN_SUM(T_FUN_SUM(t2.c1)) / cast(T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1)), DECIMAL(20, 0))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(T_FUN_SUM(t2.c1))], [T_FUN_COUNT_SUM(T_FUN_COUNT(t2.c1))])
  7 - output([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)]), filter(nil)
  8 - output([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)]), filter(nil), dop=1
  9 - output([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)])
  10 - output([t2.c1]), filter(nil), 
      force partition granule.
  11 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true, 
      range_cond([t2.c1 = ?])
  12 - output([cast(T_FUN_COUNT_SUM(T_FUN_COUNT(*)), DECIMAL(24, 4))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  13 - output([T_FUN_COUNT(*)]), filter(nil)
  14 - output([T_FUN_COUNT(*)]), filter(nil), dop=1
  15 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  16 - output(nil), filter(nil), 
      force partition granule.
  17 - output(nil), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true, 
      range_cond([t3.c1 = ?])

*************** Case 824(end)  ************** 

***************   Case 825   ***************

SQL: select * from t1 where t1.c1 != (select c2 from t2 where t2.c1 = (select max(c2) from t3 where t3.c1 = t1.c1) order by t2.c2 limit 1); 

=================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST  |
-----------------------------------------------------------------
|0 |SUBPLAN FILTER                    |        |499      |257535|
|1 | PX COORDINATOR                   |        |500      |528   |
|2 |  EXCHANGE OUT DISTR              |:EX10000|500      |481   |
|3 |   PX PARTITION ITERATOR          |        |500      |387   |
|4 |    TABLE SCAN                    |t1      |500      |387   |
|5 | LIMIT                            |        |1        |116   |
|6 |  PX COORDINATOR MERGE SORT       |        |1        |116   |
|7 |   EXCHANGE OUT DISTR             |:EX20002|1        |116   |
|8 |    LIMIT                         |        |1        |116   |
|9 |     NESTED-LOOP JOIN             |        |1        |116   |
|10|      EXCHANGE IN DISTR           |        |1        |92    |
|11|       EXCHANGE OUT DISTR (PKEY)  |:EX20001|1        |92    |
|12|        SUBPLAN SCAN              |VIEW1   |1        |92    |
|13|         SCALAR GROUP BY          |        |1        |92    |
|14|          EXCHANGE IN DISTR       |        |1        |92    |
|15|           EXCHANGE OUT DISTR     |:EX20000|1        |92    |
|16|            MERGE GROUP BY        |        |1        |91    |
|17|             PX PARTITION ITERATOR|        |1        |91    |
|18|              TABLE GET           |t3      |1        |91    |
|19|      PX PARTITION ITERATOR       |        |1        |18    |
|20|       TABLE GET                  |t2      |1        |18    |
=================================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 != subquery(1)]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), dop=1
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      force partition granule.
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p[0-4]), 
      is_index_back=false, 
      range_key([t1.c1]), range(MIN ; MAX)always true
  5 - output([t2.c2]), filter(nil), limit(1), offset(nil)
  6 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  7 - output([t2.c2]), filter(nil), dop=1
  8 - output([t2.c2]), filter(nil), limit(1), offset(nil)
  9 - output([t2.c2]), filter(nil), 
      conds(nil), nl_params_([VIEW1.max(c2)]), batch_join=false
  10 - output([PARTITION_ID], [VIEW1.max(c2)]), filter(nil)
  11 - (#keys=1, [VIEW1.max(c2)]), output([PARTITION_ID], [VIEW1.max(c2)]), filter(nil), is_single, dop=1
  12 - output([VIEW1.max(c2)]), filter(nil), 
      access([VIEW1.max(c2)])
  13 - output([T_FUN_MAX(T_FUN_MAX(t3.c2))]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(T_FUN_MAX(t3.c2))])
  14 - output([T_FUN_MAX(t3.c2)]), filter(nil)
  15 - output([T_FUN_MAX(t3.c2)]), filter(nil), dop=1
  16 - output([T_FUN_MAX(t3.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(t3.c2)])
  17 - output([t3.c2]), filter(nil), 
      force partition granule.
  18 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true, 
      range_cond([t3.c1 = ?])
  19 - output([t2.c2]), filter(nil), 
      affinitize, force partition granule.
  20 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX), 
      range_cond([t2.c1 = ?])

*************** Case 825(end)  ************** 

***************   Case 826   ***************

SQL: select /*both need not sort*/ * from t7 left join t8 on t7.c2 = t8.c2 where t8.c2 = 5; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |81       |179 |
|1 | TABLE SCAN               |t7  |9        |79  |
|2 | MATERIAL                 |    |9        |79  |
|3 |  TABLE SCAN              |t8  |9        |79  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil)
  3 - output([t8.c1], [t8.c2]), filter([t8.c2 = ?]), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t8.c1]), range(MIN ; MAX)always true

*************** Case 826(end)  ************** 

***************   Case 827   ***************

SQL: select /*both need sort*/ * from t7 left join t8 on t7.c2 = t8.c2 where t8.c2 IS NULL; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |HASH RIGHT ANTI JOIN|    |10       |206 |
|1 | TABLE SCAN         |t8  |100      |78  |
|2 | TABLE SCAN         |t7  |100      |78  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [?], [?]), filter(nil), 
      equal_conds([t7.c2 = t8.c2]), other_conds(nil)
  1 - output([t8.c2]), filter(nil), 
      access([t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 827(end)  ************** 

***************   Case 828   ***************

SQL: select /*both need not sort*/* from t7 left join t8 on t7.c2 = t8.c1 where t8.c1 = 5; 

===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |9        |127 |
|1 | TABLE SCAN               |t7  |9        |79  |
|2 | MATERIAL                 |    |1        |46  |
|3 |  TABLE GET               |t8  |1        |46  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [t8.c1], [t8.c2]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t7.c1], [t7.c2]), filter([t7.c2 = ?]), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t7.c1]), range(MIN ; MAX)always true
  2 - output([t8.c1], [t8.c2]), filter(nil)
  3 - output([t8.c1], [t8.c2]), filter(nil), 
      access([t8.c1], [t8.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range[5 ; 5], 
      range_cond([t8.c1 = ?])

*************** Case 828(end)  ************** 

***************   Case 829   ***************

SQL: select /*left need sort*/ * from t7 left join t8 on t7.c2 = t8.c1 where t8.c1 IS NULL; 

=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |HASH RIGHT ANTI JOIN|    |10       |206 |
|1 | TABLE SCAN         |t8  |100      |78  |
|2 | TABLE SCAN         |t7  |100      |78  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t7.c1], [t7.c2], [?], [?]), filter(nil), 
      equal_conds([t7.c2 = t8.c1]), other_conds(nil)
  1 - output([t8.c1]), filter(nil), 
      access([t8.c1]), partitions(p0), 
      is_index_back=false, 
      range_key([t8.c1]), range(MIN ; MAX)always true
  2 - output([t7.c1], [t7.c2]), filter(nil), 
      access([t7.c1], [t7.c2]), partitions(p0), 
      is_index_back=false, 
      range_key([t7.c1]), range(MIN ; MAX)always true

*************** Case 829(end)  ************** 

***************   Case 830   ***************

SQL: select /*both need not sort*/ * from t2 left join t3 on t2.c2 = t3.c2 where t3.c2 = 5; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |5        |397 |
|1 | PX COORDINATOR           |        |2        |159 |
|2 |  EXCHANGE OUT DISTR      |:EX10000|2        |159 |
|3 |   PX PARTITION ITERATOR  |        |2        |158 |
|4 |    TABLE SCAN            |t3      |2        |158 |
|5 | MATERIAL                 |        |3        |238 |
|6 |  PX COORDINATOR          |        |3        |238 |
|7 |   EXCHANGE OUT DISTR     |:EX20000|3        |238 |
|8 |    PX PARTITION ITERATOR |        |3        |236 |
|9 |     TABLE SCAN           |t2      |3        |236 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), dop=1
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      force partition granule.
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter([t3.c2 = ?]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p[0-1]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 830(end)  ************** 

***************   Case 831   ***************

SQL: select /*both need sort*/ * from t2 left join t3 on t2.c2 = t3.c2 where t3.c2 IS NULL; 

=====================================================
|ID|OPERATOR                |NAME    |EST. ROWS|COST|
-----------------------------------------------------
|0 |HASH RIGHT ANTI JOIN    |        |30       |778 |
|1 | PX COORDINATOR         |        |200      |187 |
|2 |  EXCHANGE OUT DISTR    |:EX10000|200      |176 |
|3 |   PX PARTITION ITERATOR|        |200      |155 |
|4 |    TABLE SCAN          |t3      |200      |155 |
|5 | PX COORDINATOR         |        |300      |464 |
|6 |  EXCHANGE OUT DISTR    |:EX20000|300      |391 |
|7 |   PX PARTITION ITERATOR|        |300      |233 |
|8 |    TABLE SCAN          |t2      |300      |233 |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [?], [?], [?]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2]), filter(nil)
  2 - output([t3.c2]), filter(nil), dop=1
  3 - output([t3.c2]), filter(nil), 
      force partition granule.
  4 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 831(end)  ************** 

***************   Case 832   ***************

SQL: select /*both need not sort*/* from t2 left join t3 on t2.c2 = t3.c1 where t3.c1 = 5; 

=======================================================
|ID|OPERATOR                  |NAME    |EST. ROWS|COST|
-------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|        |3        |177 |
|1 | PX COORDINATOR           |        |1        |47  |
|2 |  EXCHANGE OUT DISTR      |:EX10000|1        |46  |
|3 |   TABLE GET              |t3      |1        |46  |
|4 | PX COORDINATOR           |        |3        |238 |
|5 |  EXCHANGE OUT DISTR      |:EX20000|3        |238 |
|6 |   PX PARTITION ITERATOR  |        |3        |236 |
|7 |    TABLE SCAN            |t2      |3        |236 |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil), batch_join=false
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), is_single, dop=1
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p1), 
      is_index_back=false, 
      range_key([t3.c1]), range[5 ; 5], 
      range_cond([t3.c1 = ?])
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), dop=1
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 = ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 832(end)  ************** 

***************   Case 833   ***************

SQL: select /*left need sort*/ * from t2 left join t3 on t2.c2 = t3.c1 where t3.c1 IS NULL; 

==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |30       |769 |
|1 | EXCHANGE OUT DISTR          |:EX10001|30       |762 |
|2 |  HASH RIGHT ANTI JOIN       |        |30       |746 |
|3 |   PX PARTITION ITERATOR     |        |200      |155 |
|4 |    TABLE SCAN               |t3      |200      |155 |
|5 |   EXCHANGE IN DISTR         |        |300      |464 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|300      |391 |
|7 |     PX PARTITION ITERATOR   |        |300      |233 |
|8 |      TABLE SCAN             |t2      |300      |233 |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, ?, ?, ?)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(t2.c1, t2.c2, t2.c3, ?, ?, ?)]), filter(nil), dop=1
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c1]), other_conds(nil)
  3 - output([t3.c1]), filter(nil), 
      affinitize, force partition granule.
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p[0-1]), 
      is_index_back=false, 
      range_key([t3.c1]), range(MIN ; MAX)always true
  5 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil)
  6 - (#keys=1, [t2.c2]), output([t2.c2], [t2.c1], [t2.c3]), filter(nil), dop=1
  7 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      force partition granule.
  8 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p[0-2]), 
      is_index_back=false, 
      range_key([t2.c1]), range(MIN ; MAX)always true

*************** Case 833(end)  ************** 

***************   Case 834   ***************

SQL: select count(1) from rpt_adgroup_tag_realtime where thedate = '2017-09-25 00:00:00' and custid = '1102225352' and (custid,thedate,productlineid,campaignid,adgroupid,targetingtagid,tagvalue,pid,hour,traffictype,mechanism,productid) > (1102225352,'2017-09-25 00:00:00',-1,16138889,761211164,358940752715,358940752716,'420651_1007',12,1,2,-1); 

============================================================
|ID|OPERATOR       |NAME                    |EST. ROWS|COST|
------------------------------------------------------------
|0 |SCALAR GROUP BY|                        |1        |81  |
|1 | TABLE SCAN    |rpt_adgroup_tag_realtime|0        |81  |
============================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output(nil), filter([(rpt_adgroup_tag_realtime.custid, ?, rpt_adgroup_tag_realtime.productlineid, rpt_adgroup_tag_realtime.campaignid, rpt_adgroup_tag_realtime.adgroupid, rpt_adgroup_tag_realtime.targetingtagid, rpt_adgroup_tag_realtime.tagvalue, rpt_adgroup_tag_realtime.pid, rpt_adgroup_tag_realtime.hour, rpt_adgroup_tag_realtime.traffictype, rpt_adgroup_tag_realtime.mechanism, rpt_adgroup_tag_realtime.productid) > (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)], [rpt_adgroup_tag_realtime.thedate = ?], [cast(rpt_adgroup_tag_realtime.custid, DECIMAL(20, 0)) = ?]), 
      access([rpt_adgroup_tag_realtime.custid], [rpt_adgroup_tag_realtime.thedate], [rpt_adgroup_tag_realtime.productlineid], [rpt_adgroup_tag_realtime.campaignid], [rpt_adgroup_tag_realtime.adgroupid], [rpt_adgroup_tag_realtime.targetingtagid], [rpt_adgroup_tag_realtime.tagvalue], [rpt_adgroup_tag_realtime.pid], [rpt_adgroup_tag_realtime.hour], [rpt_adgroup_tag_realtime.traffictype], [rpt_adgroup_tag_realtime.mechanism], [rpt_adgroup_tag_realtime.productid]), partitions(p4sp2), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([rpt_adgroup_tag_realtime.custid], [rpt_adgroup_tag_realtime.thedate], [rpt_adgroup_tag_realtime.productlineid], [rpt_adgroup_tag_realtime.campaignid], [rpt_adgroup_tag_realtime.adgroupid], [rpt_adgroup_tag_realtime.targetingtagid], [rpt_adgroup_tag_realtime.tagvalue], [rpt_adgroup_tag_realtime.pid], [rpt_adgroup_tag_realtime.hour], [rpt_adgroup_tag_realtime.traffictype], [rpt_adgroup_tag_realtime.mechanism], [rpt_adgroup_tag_realtime.productid]), range(1102225352,MIN,MIN,MIN,MIN,MIN,MIN,MIN,MIN,MIN,MIN,MIN ; 1102225352,MAX,MAX,MAX,MAX,MAX,MAX,MAX,MAX,MAX,MAX,MAX)

*************** Case 834(end)  ************** 

***************   Case 835   ***************

SQL: select * from query_range where c1=3 and (c1, c2, c3)>(1, 2, 3) and (c1, c2, c3)>(2, 1, 2); 

==========================================
|ID|OPERATOR  |NAME       |EST. ROWS|COST|
------------------------------------------
|0 |TABLE SCAN|query_range|12       |81  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), filter([(?, query_range.c2, query_range.c3) > (?, ?, ?)], [(?, query_range.c2, query_range.c3) > (?, ?, ?)]), 
      access([query_range.c1], [query_range.c2], [query_range.c3], [query_range.c4], [query_range.c5]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([query_range.c1], [query_range.c2], [query_range.c3]), range(3,MIN,MIN ; 3,MAX,MAX), 
      range_cond([query_range.c1 = ?])

*************** Case 835(end)  ************** 

***************   Case 836   ***************

SQL: select * from cb_loan_acctbal_01 a where (a.balcatcd, a.baltypcd) in (('NOTE', 'BAL'), ('NOTE', 'GINT'), ('ODP', 'GINT'), ('RCVB', 'INT'), ('RCVB', 'ODPI')) and a.preeffdate and '2017-10-16' < a.effdate; 

===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |250 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.acctnbr], [a.balcatcd], [a.baltypcd], [a.preeffdate], [a.preamt], [a.effdate], [a.amt], [a.mainttellerid], [a.maintbranchnbr], [a.gmt_create], [a.gmt_modified], [a.oddfreqnextduedate], [a.nextrcvbnbr], [a.nextratechangedate]), filter([(a.balcatcd, a.baltypcd) IN ((?, ?), (?, ?), (?, ?), (?, ?), (?, ?))], [cast(a.preeffdate, DOUBLE(-1, -1))], [? < cast(a.effdate, DATETIME(-1, -1))]), 
      access([a.balcatcd], [a.baltypcd], [a.effdate], [a.acctnbr], [a.preeffdate], [a.preamt], [a.amt], [a.mainttellerid], [a.maintbranchnbr], [a.gmt_create], [a.gmt_modified], [a.oddfreqnextduedate], [a.nextrcvbnbr], [a.nextratechangedate]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([a.balcatcd], [a.baltypcd], [a.effdate], [a.acctnbr]), range(NOTE,BAL,2017-10-16,MAX ; NOTE,BAL,MAX,MAX), (NOTE,GINT,2017-10-16,MAX ; NOTE,GINT,MAX,MAX), (ODP,GINT,2017-10-16,MAX ; ODP,GINT,MAX,MAX), (RCVB,INT,2017-10-16,MAX ; RCVB,INT,MAX,MAX), (RCVB,ODPI,2017-10-16,MAX ; RCVB,ODPI,MAX,MAX)

*************** Case 836(end)  ************** 

***************   Case 837   ***************

SQL: use query_range; 
***************   Case 838   ***************

SQL: select * from range_t1 where (a, b)>(1, 1) and (a, b)=(1, 2); 

======================================
|ID|OPERATOR |NAME    |EST. ROWS|COST|
--------------------------------------
|0 |TABLE GET|range_t1|1        |46  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([range_t1.a], [range_t1.b]), filter(nil), 
      access([range_t1.a], [range_t1.b]), partitions(p0), 
      is_index_back=false, 
      range_key([range_t1.a], [range_t1.b]), range[1,2 ; 1,2], 
      range_cond([range_t1.a = ?], [range_t1.b = ?])

*************** Case 838(end)  ************** 

***************   Case 839   ***************

SQL: select * from range_t1 where (a, b)>(1, 1) and a=1; 

=======================================
|ID|OPERATOR  |NAME    |EST. ROWS|COST|
---------------------------------------
|0 |TABLE SCAN|range_t1|34       |80  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([range_t1.a], [range_t1.b]), filter([(?, range_t1.b) > (?, ?)]), 
      access([range_t1.a], [range_t1.b]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false], 
      range_key([range_t1.a], [range_t1.b]), range(1,MIN ; 1,MAX), 
      range_cond([range_t1.a = ?])

*************** Case 839(end)  ************** 

***************   Case 840   ***************

SQL: select * from range_t1 where (a, b)>(1, 1) and b=2; 

=======================================
|ID|OPERATOR  |NAME    |EST. ROWS|COST|
---------------------------------------
|0 |TABLE SCAN|range_t1|9        |79  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([range_t1.a], [range_t1.b]), filter([range_t1.b = ?], [(range_t1.a, ?) > (?, ?)]), 
      access([range_t1.a], [range_t1.b]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([range_t1.a], [range_t1.b]), range(1,MIN ; MAX,MAX)

*************** Case 840(end)  ************** 

***************   Case 841   ***************

SQL: select * from test1 where (id, dt) > (0, '2017-01-02') and (id, dt) <= (1, '2017-01-03'); 

====================================
|ID|OPERATOR  |NAME |EST. ROWS|COST|
------------------------------------
|0 |TABLE SCAN|test1|13       |81  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([test1.id], [test1.dt]), filter([(test1.id, test1.dt) <= (?, ?)], [(test1.id, test1.dt) > (?, ?)]), 
      access([test1.id], [test1.dt]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([test1.id], [test1.dt]), range(0,2017-01-02 00:00:00.000000 ; 1,2017-01-03 00:00:00.000000]

*************** Case 841(end)  ************** 

***************   Case 842   ***************

SQL: select * from test1 where (id, dt) > (0, '2017-01-02') and (id, dt) <= (1, '2017-01-03') and dt < '2017-01-02'; 

====================================
|ID|OPERATOR  |NAME |EST. ROWS|COST|
------------------------------------
|0 |TABLE SCAN|test1|3        |81  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([test1.id], [test1.dt]), filter([(test1.id, test1.dt) <= (?, ?)], [test1.dt < ?], [(test1.id, test1.dt) > (?, ?)]), 
      access([test1.id], [test1.dt]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([test1.id], [test1.dt]), range(0,2017-01-02 00:00:00.000000 ; 1,2017-01-03 00:00:00.000000]

*************** Case 842(end)  ************** 

***************   Case 843   ***************

SQL: select * from test1 where (id, dt) > (0, '2017-01-01') and (id, dt) <= (1, '2017-01-03') and dt = '2017-01-02'; 

====================================
|ID|OPERATOR  |NAME |EST. ROWS|COST|
------------------------------------
|0 |TABLE SCAN|test1|2        |81  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([test1.id], [test1.dt]), filter([test1.dt = ?], [(test1.id, ?) <= (?, ?)], [(test1.id, ?) > (?, ?)]), 
      access([test1.id], [test1.dt]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([test1.id], [test1.dt]), range(0,MIN ; 1,MAX)

*************** Case 843(end)  ************** 

***************   Case 844   ***************

SQL: select * from test1 where (id, dt) > (0, '2017-01-02') and (id, dt) <= (1, '2017-01-03') and dt = '2017-01-02'; 

====================================
|ID|OPERATOR  |NAME |EST. ROWS|COST|
------------------------------------
|0 |TABLE SCAN|test1|2        |81  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([test1.id], [test1.dt]), filter([test1.dt = ?], [(test1.id, ?) <= (?, ?)], [(test1.id, ?) > (?, ?)]), 
      access([test1.id], [test1.dt]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false], 
      range_key([test1.id], [test1.dt]), range(0,MIN ; 1,MAX)

*************** Case 844(end)  ************** 

