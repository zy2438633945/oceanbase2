***************   Case 0   ***************
SQL: select * from t1, t2 where t1.c1 > 10 and t1.c1 in (select c2 from t2); 
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |5000     |4144|
|1 | TABLE SCAN               |t2   |100      |92  |
|2 | MATERIAL                 |     |50       |410 |
|3 |  MERGE JOIN              |     |50       |382 |
|4 |   TABLE SCAN             |t1   |100      |90  |
|5 |   SUBPLAN SCAN           |VIEW1|50       |242 |
|6 |    MERGE DISTINCT        |     |100      |220 |
|7 |     SORT                 |     |100      |198 |
|8 |      TABLE SCAN          |t2   |100      |90  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = VIEW1.c2]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([VIEW1.c2]), filter([VIEW1.c2 > ?]), 
      access([VIEW1.c2])
  6 - output([t2.c2]), filter(nil), 
      distinct([t2.c2])
  7 - output([t2.c2]), filter(nil), sort_keys([t2.c2, ASC])
  8 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" )))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      USE_MERGE(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 1   ***************
SQL: select * from t1 where c1 >ANY (select c2 from t2); 
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|    |34       |3035|
|1 | TABLE SCAN          |t1  |100      |90  |
|2 | MATERIAL            |    |100      |109 |
|3 |  TABLE SCAN         |t2  |100      |90  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > t2.c2]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c2]), filter(nil)
  3 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 2   ***************
SQL: select * from t1, t2 where t1.c1 In (select c1 from t2); 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7697|
|1 | TABLE SCAN               |t2  |100      |92  |
|2 | MATERIAL                 |    |100      |320 |
|3 |  MERGE JOIN              |    |100      |265 |
|4 |   TABLE SCAN             |t1  |100      |90  |
|5 |   TABLE SCAN             |t2  |100      |88  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" )))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 3   ***************
SQL: select * from t1 where Exists (select c1 from t2); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 4   ***************
SQL: select * from t1 where c1 In (select c1 from t2); 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 5   ***************
SQL: select * from t1 where c1 =ANY (select c1 from t2); 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 6   ***************
SQL: select * from t1 where c1 >ANY (select c1 from t2); 
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|     |34       |172 |
|1 | TABLE SCAN          |t1   |100      |90  |
|2 | MATERIAL            |     |1        |37  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |37  |
|4 |   SCALAR GROUP BY   |     |1        |37  |
|5 |    SUBPLAN SCAN     |VIEW2|1        |37  |
|6 |     TABLE SCAN      |t2   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > VIEW1.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([T_FUN_MIN(VIEW2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.c1)])
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("VIEW1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 7   ***************
SQL: select * from t1 where c1 <ALL (select c1 from t2); 
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |67       |145 |
|1 | TABLE SCAN          |t1   |100      |90  |
|2 | MATERIAL            |     |1        |37  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |37  |
|4 |   SCALAR GROUP BY   |     |1        |37  |
|5 |    SUBPLAN SCAN     |VIEW2|1        |37  |
|6 |     TABLE SCAN      |t2   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 >= VIEW1.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([T_FUN_MIN(VIEW2.c1)]), filter([(T_OP_IS_NOT, T_FUN_MIN(VIEW2.c1), NULL, 0)]), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.c1)])
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("VIEW1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 8   ***************
SQL: select * from t1 where c1 <ALL (select c1 from t2 limit 1); 
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |67       |172 |
|1 | TABLE SCAN          |t1   |100      |90  |
|2 | MATERIAL            |     |1        |37  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |37  |
|4 |   TABLE SCAN        |t2   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 >= VIEW1.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("VIEW1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 9   ***************
SQL: select * from t1 where 1 < ANY(select c1 from t2); 
===============================================================
|ID|OPERATOR                       |NAME       |EST. ROWS|COST|
---------------------------------------------------------------
|0 |NESTED-LOOP SEMI JOIN CARTESIAN|           |50       |137 |
|1 | TABLE SCAN                    |t1         |100      |90  |
|2 | MATERIAL                      |           |1        |37  |
|3 |  SUBPLAN SCAN                 |VIEW1      |1        |37  |
|4 |   SCALAR GROUP BY             |           |1        |37  |
|5 |    SUBPLAN SCAN               |VIEW2      |1        |37  |
|6 |     TABLE SCAN                |t2(Reverse)|1        |36  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil)
  3 - output([1]), filter([VIEW1.c1 > ?]), 
      access([VIEW1.c1])
  4 - output([T_FUN_MAX(VIEW2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW2.c1)])
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("VIEW1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 10   ***************
SQL: select * from t1 where 1 < ANY(select c1 from t2 limit 1); 
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |50       |114 |
|1 | SUBPLAN SCAN             |VIEW1|1        |37  |
|2 |  TABLE SCAN              |t2   |1        |36  |
|3 | TABLE SCAN               |t1   |100      |90  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([1]), filter([VIEW1.c1 > ?]), 
      access([VIEW1.c1])
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 11   ***************
SQL: select * from t1 where Exists (select c1 from t2 where c2 >ALL (select c1 from t3)); 
=======================================================
|ID|OPERATOR               |NAME       |EST. ROWS|COST|
-------------------------------------------------------
|0 |SUBPLAN FILTER         |           |50       |177 |
|1 | TABLE SCAN            |t1         |100      |90  |
|2 | LIMIT                 |           |1        |73  |
|3 |  NESTED-LOOP ANTI JOIN|           |1        |73  |
|4 |   TABLE SCAN          |t2         |2        |37  |
|5 |   MATERIAL            |           |1        |37  |
|6 |    SUBPLAN SCAN       |VIEW1      |1        |37  |
|7 |     SCALAR GROUP BY   |           |1        |37  |
|8 |      SUBPLAN SCAN     |VIEW2      |1        |37  |
|9 |       TABLE SCAN      |t3(Reverse)|1        |36  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil), 
      conds([t2.c2 <= VIEW1.c1 OR (T_OP_IS, t2.c2, NULL, 0)]), nl_params_(nil)
  4 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  5 - output([VIEW1.c1]), filter(nil)
  6 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  7 - output([T_FUN_MAX(VIEW2.c1)]), filter([(T_OP_IS_NOT, T_FUN_MAX(VIEW2.c1), NULL, 0)]), 
      group(nil), agg_func([T_FUN_MAX(VIEW2.c1)])
  8 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      LEADING(@"SEL$2" ("opt.t2"@"SEL$2" "VIEW1"@"SEL$2" ))
      USE_NL(@"SEL$2" ("VIEW1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("VIEW1"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$3" "opt.t3"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 12   ***************
SQL: select * from t1 where Exists (select c1 from t2 where t1.c2=t2.c2); 
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |HASH RIGHT SEMI JOIN|    |100      |382 |
|1 | TABLE SCAN         |t2  |100      |90  |
|2 | TABLE SCAN         |t1  |100      |90  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$2" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 13   ***************
SQL: select * from t1 where c1 <ALL (select c1 from t2 where t1.c2=t2.c2); 
==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER  |     |50       |9945|
|1 | TABLE SCAN     |t1   |100      |90  |
|2 | SCALAR GROUP BY|     |1        |99  |
|3 |  SUBPLAN SCAN  |VIEW1|1        |99  |
|4 |   TABLE SCAN   |t2   |1        |99  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 < ALL(subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  2 - output([T_FUN_MIN(VIEW1.c1)]), filter([(T_OP_IS_NOT, T_FUN_MIN(VIEW1.c1), NULL, 0)]), 
      group(nil), agg_func([T_FUN_MIN(VIEW1.c1)])
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t2.c1]), filter([? = t2.c2]), 
      access([t2.c2], [t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 14   ***************
SQL: select * from t1 where c1 !=ANY (select c1 from t2 where t1.c2=t2.c2 limit 1); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |9926|
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |99  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c1 != ANY(subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  2 - output([t2.c1]), filter([? = t2.c2]), 
      access([t2.c2], [t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 15   ***************
SQL: select * from t1 where c1 < (select c1 from t2); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |192 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |100      |88  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 16   ***************
SQL: select * from t1 where exists (select c1 from t2 where t1.c1 = t2.c1); 
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE SEMI JOIN|    |100      |265 |
|1 | TABLE SCAN    |t1  |100      |90  |
|2 | TABLE SCAN    |t2  |100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 17   ***************
SQL: select * from t1 where exists (select c1 from t2); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 18   ***************
SQL: select * from t1 where exists (select c1 from t2 limit 10, 2); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |142 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |2        |38  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(2), offset(?)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 19   ***************
SQL: select * from t1 where exists (select c1 from t2 group by c1); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 20   ***************
SQL: select * from t1 where (t1.c1, t1.c2) in (select c1,c2 from t2 where c3 = 1); 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |145 |
|1 | TABLE SCAN     |t2  |1        |109 |
|2 | TABLE GET      |t1  |1        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  1 - output([t2.c1], [t2.c2]), filter([t2.c3 = ?]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$2" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 21   ***************
SQL: select * from t1 where (t1.c1, t1.c2) not in (select c1,c2 from t2 where c3 = 1); 
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE ANTI JOIN|    |100      |213 |
|1 | TABLE SCAN    |t1  |100      |90  |
|2 | TABLE SCAN    |t2  |1        |109 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([(T_OP_OR, t1.c2 = t2.c2, (T_OP_IS, t1.c2, NULL, 0), (T_OP_IS, t2.c2, NULL, 0))])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter([t2.c3 = ?]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 22   ***************
SQL: select * from t1 where (t1.c1, t1.c2) = ANY(select c1,c2 from t2 where c3 = 1); 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |145 |
|1 | TABLE SCAN     |t2  |1        |109 |
|2 | TABLE GET      |t1  |1        |37  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1], [t2.c2])
  1 - output([t2.c1], [t2.c2]), filter([t2.c3 = ?]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter([t1.c2 = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$2" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 23   ***************
SQL: select * from t1 where (t1.c1, t1.c2) != ANY(select c1,c2 from t2 where c3 = 1); 
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|    |50       |259 |
|1 | TABLE SCAN          |t1  |100      |90  |
|2 | MATERIAL            |    |1        |110 |
|3 |  TABLE SCAN         |t2  |1        |109 |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([(t1.c1, t1.c2) != (t2.c1, t2.c2)]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil)
  3 - output([t2.c1], [t2.c2]), filter([t2.c3 = ?]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 24   ***************
SQL: select * from t1 where (t1.c1, t1.c2) = ALL(select c1,c2 from t2 where c3 = 1); 
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|    |50       |259 |
|1 | TABLE SCAN          |t1  |100      |90  |
|2 | MATERIAL            |    |1        |110 |
|3 |  TABLE SCAN         |t2  |1        |109 |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([lnnvl((t1.c1, t1.c2) = (t2.c1, t2.c2))]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil)
  3 - output([t2.c1], [t2.c2]), filter([t2.c3 = ?]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 25   ***************
SQL: select * from t1 where (t1.c1, t1.c2) != ALL(select c1,c2 from t2 where c3 = 1); 
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |MERGE ANTI JOIN|    |100      |213 |
|1 | TABLE SCAN    |t1  |100      |90  |
|2 | TABLE SCAN    |t2  |1        |109 |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([(T_OP_OR, t1.c2 = t2.c2, (T_OP_IS, t1.c2, NULL, 0), (T_OP_IS, t2.c2, NULL, 0))])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter([t2.c3 = ?]), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 26   ***************
SQL: select * from t1 where (t1.c1, t1.c2) != ANY(select c1,c2 from t2 where t1.c2 = t2.c2); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |HASH SEMI JOIN|    |50       |383 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t2.c2]), other_conds([(t1.c1, t1.c2) != (t2.c1, t2.c2)])
  1 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  2 - output([t2.c2], [t2.c1]), filter(nil), 
      access([t2.c2], [t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 27   ***************
SQL: select * from t1 where (t1.c1, t1.c2) = ALL(select c1,c2 from t2 where t1.c1 > t2.c1); 
==============================================
|ID|OPERATOR             |NAME|EST. ROWS|COST|
----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|    |84       |4803|
|1 | TABLE SCAN          |t1  |100      |90  |
|2 | TABLE SCAN          |t2  |17       |45  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1], [t1.c2])
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter([lnnvl((?, ?) = (t2.c1, t2.c2))]), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$2" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 28   ***************
SQL: select * from t3 where (t3.c1, t3.c2, t3.c3) in (select c1,c2,c3 from t2 where t3.c3 <> t2.c3); 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |50       |348 |
|1 | TABLE SCAN|t3  |100      |92  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t3.c1 = t2.c1], [t3.c2 = t2.c2], [t3.c3 = t2.c3]), other_conds([t3.c3 != t2.c3])
  1 - output([t3.c3], [t3.c1], [t3.c2]), filter(nil), 
      access([t3.c3], [t3.c1], [t3.c2]), partitions(p0)
  2 - output([t2.c3], [t2.c1], [t2.c2]), filter(nil), 
      access([t2.c3], [t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 29   ***************
SQL: select * from t1 where exists (select 1, round(1.1) from dual); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |104 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | LIMIT        |    |1        |1   |
|3 |  EXPRESSION  |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([?], [?]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil)
      values({1})

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 30   ***************
SQL: select * from t1 where not exists (select 1, round(1.1) from dual); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |104 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | LIMIT        |    |1        |1   |
|3 |  EXPRESSION  |    |1        |1   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([?], [?]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil)
      values({1})

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 31   ***************
SQL: select * from t1 where exists (select max(c1) from t2); 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([1]), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 32   ***************
SQL: select * from t1 where not exists (select max(c1) from t2); 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |0        |99  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([0]), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 33   ***************
SQL: select * from t1 where exists (select max(c1), sum(c1), count(c1)  from t2); 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), startup_filter([1]), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 34   ***************
SQL: select * from t1 where not exists (select max(c1), sum(c1), count(c1)  from t2); 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |0        |99  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([0]), startup_filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 35   ***************
SQL: select * from t1, (select * from t2 where exists(select sum(c1) from t3)) tx where t1.c1 = tx.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 36   ***************
SQL: select * from t1 where t1.c1 in (select c1 from t2 where exists(select count(c1) from t3)); 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 37   ***************
SQL: select * from t1 where exists (select group_concat(c1, c2) from t2 group by c1) ; 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 38   ***************
SQL: select * from t1 where exists (select max(c1), sum(c1), count(c1) from t2 group by c1) ; 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 39   ***************
SQL: select * from t1 where exists (select max(c1), sum(c1), count(c1) from t2 group by c1 having c1 > 1); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 40   ***************
SQL: select * from t1 where exists (select max(c1), sum(c1), count(c1) from t2 group by c1 having sum(c1) > 1); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 41   ***************
SQL: select * from t1 where exists (select max(c1), sum(c1), count(c1) from t2 group by c1 having sum(c1) > 1 and count(c1) > 0);  select * from t1 where not exists (select group_concat(c1, c2) from t2 group by c1) ; 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter([CASE WHEN (T_OP_IS_NOT, t2.c1, NULL, 0) THEN 1 ELSE 0 END > ?]), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 42   ***************
SQL: select * from t1 where not exists (select max(c1), sum(c1), count(c1) from t2 group by c1) ; 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 43   ***************
SQL: select * from t1 where not exists (select max(c1), sum(c1), count(c1) from t2 group by c1 having c1 > 1); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 44   ***************
SQL: select * from t1 where not exists (select max(c1), sum(c1), count(c1) from t2 group by c1 having sum(c1) > 1); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 45   ***************
SQL: select * from t1 where not exists (select max(c1), sum(c1), count(c1) from t2 group by c1 having sum(c1) > 1 and count(c1) > 0); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter([CASE WHEN (T_OP_IS_NOT, t2.c1, NULL, 0) THEN 1 ELSE 0 END > ?]), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 46   ***************
SQL: select * from t1 where exists(select max(c1) from t2 group by c1 having max(c1) > 1); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 47   ***************
SQL: select * from t1, (select * from t2 having c1 > 1) as tx where t1.c1 = tx.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 48   ***************
SQL: select * from t1, (select * from t2 where exists(select sum(c1)  from t3 group by c1 having c1 > 1)) as tx where t1.c1 = tx.c1; 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |319 |
|1 | MERGE JOIN   |    |100      |269 |
|2 |  TABLE SCAN  |t1  |100      |90  |
|3 |  TABLE SCAN  |t2  |100      |92  |
|4 | TABLE SCAN   |t3  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$3" "opt.t3"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 49   ***************
SQL: select * from t1 where exists (select max(c1) from t2 group by c1 having exists (select * from t3 where t3.c1 > max(t2.c1))); 
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |SUBPLAN FILTER         |    |50       |278 |
|1 | TABLE SCAN            |t1  |100      |90  |
|2 | LIMIT                 |    |1        |175 |
|3 |  NESTED-LOOP SEMI JOIN|    |1        |175 |
|4 |   TABLE SCAN          |t2  |4        |37  |
|5 |   TABLE SCAN          |t3  |34       |42  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      LEADING(@"SEL$2" ("opt.t2"@"SEL$2" "opt.t3"@"SEL$3" ))
      USE_NL(@"SEL$2" ("opt.t3"@"SEL$3" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$2" ("opt.t3"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$3" "opt.t3"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 50   ***************
SQL: select * from t1 where exists (select sum(c1) from t2 group by c1 having exists (select * from t3 where t3.c1 > sum(t2.c1))); 
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |SUBPLAN FILTER         |    |50       |278 |
|1 | TABLE SCAN            |t1  |100      |90  |
|2 | LIMIT                 |    |1        |175 |
|3 |  NESTED-LOOP SEMI JOIN|    |1        |175 |
|4 |   TABLE SCAN          |t2  |4        |37  |
|5 |   TABLE SCAN          |t3  |34       |42  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      LEADING(@"SEL$2" ("opt.t2"@"SEL$2" "opt.t3"@"SEL$3" ))
      USE_NL(@"SEL$2" ("opt.t3"@"SEL$3" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$2" ("opt.t3"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$3" "opt.t3"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 51   ***************
SQL: select * from t1 where c2 > exists(select c2 from t2 where c2 > exists(select c2 from t3)); 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |34       |177 |
|1 | TABLE SCAN     |t1  |100      |90  |
|2 | LIMIT          |    |1        |73  |
|3 |  SUBPLAN FILTER|    |1        |73  |
|4 |   TABLE SCAN   |t2  |4        |37  |
|5 |   TABLE SCAN   |t3  |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c2], [t1.c1]), filter([t1.c2 > ?]), 
      access([t1.c2], [t1.c1]), partitions(p0)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  4 - output([t2.c2]), filter([t2.c2 > ?]), 
      access([t2.c2]), partitions(p0)
  5 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$3" "opt.t3"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 52   ***************
SQL: select * from t1 where c2 > exists(select c1 from t2 where c2 > exists(select sum(c1) from t3)); 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |140 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |37  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c2], [t1.c1]), filter([t1.c2 > ?]), 
      access([t1.c2], [t1.c1]), partitions(p0)
  2 - output([1]), filter([t2.c2 > 1]), 
      access([t2.c2]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 53   ***************
SQL: select * from t1 where c2 > exists(select sum(c1) from t2 where c2 > exists(select sum(c1) from t3)); 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |96       |107 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c2 > 1]), 
      access([t1.c2], [t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 54   ***************
SQL: SELECT c1 FROM pullup1 WHERE EXISTS(SELECT DISTINCT c1 FROM pullup2); 
==========================================
|ID|OPERATOR      |NAME   |EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER|       |50       |140 |
|1 | TABLE SCAN   |pullup1|100      |90  |
|2 | TABLE SCAN   |pullup2|1        |36  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([pullup2.pk]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 55   ***************
SQL: SELECT c1 FROM pullup1 WHERE EXISTS(SELECT DISTINCT c1 FROM pullup2 LIMIT 1); 
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |SUBPLAN FILTER |       |50       |141 |
|1 | TABLE SCAN    |pullup1|100      |90  |
|2 | LIMIT         |       |1        |38  |
|3 |  HASH DISTINCT|       |1        |37  |
|4 |   TABLE SCAN  |pullup2|1        |36  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  2 - output([pullup2.c1]), filter(nil), limit(1), offset(nil)
  3 - output([pullup2.c1]), filter(nil), 
      distinct([pullup2.c1])
  4 - output([pullup2.c1]), filter(nil), 
      access([pullup2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 56   ***************
SQL: SELECT c1 FROM pullup1 WHERE EXISTS(SELECT DISTINCT c1 FROM pullup2 LIMIT 1 OFFSET 2); 
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |SUBPLAN FILTER |       |50       |144 |
|1 | TABLE SCAN    |pullup1|100      |90  |
|2 | LIMIT         |       |1        |40  |
|3 |  HASH DISTINCT|       |3        |40  |
|4 |   TABLE SCAN  |pullup2|3        |37  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  2 - output([pullup2.c1]), filter(nil), limit(1), offset(?)
  3 - output([pullup2.c1]), filter(nil), 
      distinct([pullup2.c1])
  4 - output([pullup2.c1]), filter(nil), 
      access([pullup2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 57   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT pk FROM pullup2); 
========================================
|ID|OPERATOR    |NAME   |EST. ROWS|COST|
----------------------------------------
|0 |MERGE JOIN  |       |100      |372 |
|1 | SORT       |       |100      |198 |
|2 |  TABLE SCAN|pullup1|100      |90  |
|3 | TABLE SCAN |pullup2|100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.pk]), other_conds(nil)
  1 - output([pullup1.c1]), filter(nil), sort_keys([pullup1.c1, ASC])
  2 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  3 - output([pullup2.pk]), filter(nil), 
      access([pullup2.pk]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "opt.pullup2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.pullup2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 58   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT pk FROM pullup2 WHERE pullup2.c3 = pullup1.c3); 
========================================
|ID|OPERATOR    |NAME   |EST. ROWS|COST|
----------------------------------------
|0 |MERGE JOIN  |       |100      |405 |
|1 | SORT       |       |100      |220 |
|2 |  TABLE SCAN|pullup1|100      |92  |
|3 | TABLE SCAN |pullup2|100      |90  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.pk], [pullup2.c3 = pullup1.c3]), other_conds(nil)
  1 - output([pullup1.c1], [pullup1.c3]), filter(nil), sort_keys([pullup1.c1, ASC], [pullup1.c3, ASC])
  2 - output([pullup1.c3], [pullup1.c1]), filter(nil), 
      access([pullup1.c3], [pullup1.c1]), partitions(p0)
  3 - output([pullup2.c3], [pullup2.pk]), filter(nil), 
      access([pullup2.c3], [pullup2.pk]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "opt.pullup2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.pullup2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 59   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT pk FROM pullup2 WHERE pullup2.c1 = pullup2.c3); 
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |HASH JOIN  |       |1        |224 |
|1 | TABLE SCAN|pullup2|1        |101 |
|2 | TABLE SCAN|pullup1|100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.pk]), other_conds(nil)
  1 - output([pullup2.pk]), filter([pullup2.c1 = pullup2.c3]), 
      access([pullup2.c1], [pullup2.c3], [pullup2.pk]), partitions(p0)
  2 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup2"@"SEL$2" "opt.pullup1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 60   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT pk FROM pullup2 WHERE pullup2.c1 = pullup1.c3 AND pullup2.c1 = pullup2.c3); 
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |HASH JOIN  |       |1        |232 |
|1 | TABLE SCAN|pullup2|1        |101 |
|2 | TABLE SCAN|pullup1|100      |92  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.pk], [pullup2.c1 = pullup1.c3]), other_conds(nil)
  1 - output([pullup2.c1], [pullup2.pk]), filter([pullup2.c1 = pullup2.c3]), 
      access([pullup2.c1], [pullup2.c3], [pullup2.pk]), partitions(p0)
  2 - output([pullup1.c3], [pullup1.c1]), filter(nil), 
      access([pullup1.c3], [pullup1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup2"@"SEL$2" "opt.pullup1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 61   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT pk FROM pullup2 ORDER BY pullup2.c3); 
========================================
|ID|OPERATOR    |NAME   |EST. ROWS|COST|
----------------------------------------
|0 |MERGE JOIN  |       |100      |372 |
|1 | SORT       |       |100      |198 |
|2 |  TABLE SCAN|pullup1|100      |90  |
|3 | TABLE SCAN |pullup2|100      |88  |
========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.pk]), other_conds(nil)
  1 - output([pullup1.c1]), filter(nil), sort_keys([pullup1.c1, ASC])
  2 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  3 - output([pullup2.pk]), filter(nil), 
      access([pullup2.pk]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "opt.pullup2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.pullup2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 62   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT uniq_c2 FROM pullup2); 
==============================================
|ID|OPERATOR    |NAME         |EST. ROWS|COST|
----------------------------------------------
|0 |MERGE JOIN  |             |100      |339 |
|1 | TABLE SCAN |pullup2(uniq)|100      |54  |
|2 | SORT       |             |100      |198 |
|3 |  TABLE SCAN|pullup1      |100      |90  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.uniq_c2]), other_conds(nil)
  1 - output([pullup2.uniq_c2]), filter(nil), 
      access([pullup2.uniq_c2]), partitions(p0)
  2 - output([pullup1.c1]), filter(nil), sort_keys([pullup1.c1, ASC])
  3 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup2"@"SEL$2" "opt.pullup1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      INDEX(@"SEL$2" "opt.pullup2"@"SEL$2" "uniq")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 63   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT uniq_c2 FROM pullup2 WHERE pullup2.c3 = pullup1.c3); 
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |HASH JOIN  |       |100      |424 |
|1 | TABLE SCAN|pullup1|100      |92  |
|2 | TABLE SCAN|pullup2|100      |92  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.uniq_c2], [pullup2.c3 = pullup1.c3]), other_conds(nil)
  1 - output([pullup1.c3], [pullup1.c1]), filter(nil), 
      access([pullup1.c3], [pullup1.c1]), partitions(p0)
  2 - output([pullup2.c3], [pullup2.uniq_c2]), filter(nil), 
      access([pullup2.c3], [pullup2.uniq_c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "opt.pullup2"@"SEL$2" ))
      USE_HASH(@"SEL$1" ("opt.pullup2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 64   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT uniq_c2 FROM pullup2 WHERE pullup2.c1 = pullup2.c3); 
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |HASH JOIN  |       |1        |227 |
|1 | TABLE SCAN|pullup2|1        |103 |
|2 | TABLE SCAN|pullup1|100      |90  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.uniq_c2]), other_conds(nil)
  1 - output([pullup2.uniq_c2]), filter([pullup2.c1 = pullup2.c3]), 
      access([pullup2.c1], [pullup2.c3], [pullup2.uniq_c2]), partitions(p0)
  2 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup2"@"SEL$2" "opt.pullup1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 65   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT uniq_c2 FROM pullup2 WHERE pullup2.c1 = pullup1.c3 AND pullup2.c1 = pullup2.c3); 
=======================================
|ID|OPERATOR   |NAME   |EST. ROWS|COST|
---------------------------------------
|0 |HASH JOIN  |       |1        |235 |
|1 | TABLE SCAN|pullup2|1        |103 |
|2 | TABLE SCAN|pullup1|100      |92  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.uniq_c2], [pullup2.c1 = pullup1.c3]), other_conds(nil)
  1 - output([pullup2.c1], [pullup2.uniq_c2]), filter([pullup2.c1 = pullup2.c3]), 
      access([pullup2.c1], [pullup2.c3], [pullup2.uniq_c2]), partitions(p0)
  2 - output([pullup1.c3], [pullup1.c1]), filter(nil), 
      access([pullup1.c3], [pullup1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup2"@"SEL$2" "opt.pullup1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 66   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT uniq_c2 FROM pullup2 ORDER BY pullup2.c3); 
==============================================
|ID|OPERATOR    |NAME         |EST. ROWS|COST|
----------------------------------------------
|0 |MERGE JOIN  |             |100      |339 |
|1 | TABLE SCAN |pullup2(uniq)|100      |54  |
|2 | SORT       |             |100      |198 |
|3 |  TABLE SCAN|pullup1      |100      |90  |
==============================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.uniq_c2]), other_conds(nil)
  1 - output([pullup2.uniq_c2]), filter(nil), 
      access([pullup2.uniq_c2]), partitions(p0)
  2 - output([pullup1.c1]), filter(nil), sort_keys([pullup1.c1, ASC])
  3 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup2"@"SEL$2" "opt.pullup1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      INDEX(@"SEL$2" "opt.pullup2"@"SEL$2" "uniq")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 67   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT DISTINCT c1 FROM pullup2); 
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |HASH JOIN      |       |100      |500 |
|1 | TABLE SCAN    |pullup1|100      |90  |
|2 | SUBPLAN SCAN  |VIEW1  |100      |208 |
|3 |  HASH DISTINCT|       |100      |195 |
|4 |   TABLE SCAN  |pullup2|100      |90  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([pullup2.c1]), filter(nil), 
      distinct([pullup2.c1])
  4 - output([pullup2.c1]), filter(nil), 
      access([pullup2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 68   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT DISTINCT c1 FROM pullup2 WHERE pullup2.c1 = pullup2.c3); 
============================================
|ID|OPERATOR        |NAME   |EST. ROWS|COST|
--------------------------------------------
|0 |HASH JOIN       |       |1        |225 |
|1 | SUBPLAN SCAN   |VIEW1  |1        |101 |
|2 |  MERGE DISTINCT|       |1        |101 |
|3 |   SORT         |       |1        |101 |
|4 |    TABLE SCAN  |pullup2|1        |101 |
|5 | TABLE SCAN     |pullup1|100      |90  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  2 - output([pullup2.c1]), filter(nil), 
      distinct([pullup2.c1])
  3 - output([pullup2.c1]), filter(nil), sort_keys([pullup2.c1, ASC])
  4 - output([pullup2.c1]), filter([pullup2.c1 = pullup2.c3]), 
      access([pullup2.c1], [pullup2.c3]), partitions(p0)
  5 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "opt.pullup1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 69   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT DISTINCT c1 FROM pullup2 WHERE pullup2.c3 = pullup1.c3); 
==========================================
|ID|OPERATOR      |NAME   |EST. ROWS|COST|
------------------------------------------
|0 |HASH SEMI JOIN|       |100      |424 |
|1 | TABLE SCAN   |pullup1|100      |92  |
|2 | TABLE SCAN   |pullup2|100      |92  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.c1], [pullup2.c3 = pullup1.c3]), other_conds(nil)
  1 - output([pullup1.c3], [pullup1.c1]), filter(nil), 
      access([pullup1.c3], [pullup1.c1]), partitions(p0)
  2 - output([pullup2.c3], [pullup2.c1]), filter(nil), 
      access([pullup2.c3], [pullup2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "opt.pullup2"@"SEL$2" ))
      USE_HASH(@"SEL$1" ("opt.pullup2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 70   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT pk FROM pullup2 LIMIT 1); 
=========================================
|ID|OPERATOR     |NAME   |EST. ROWS|COST|
-----------------------------------------
|0 |HASH JOIN    |       |1        |161 |
|1 | SUBPLAN SCAN|VIEW1  |1        |37  |
|2 |  TABLE SCAN |pullup2|1        |36  |
|3 | TABLE SCAN  |pullup1|100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.pk]), other_conds(nil)
  1 - output([VIEW1.pk]), filter(nil), 
      access([VIEW1.pk])
  2 - output([pullup2.pk]), filter(nil), 
      access([pullup2.pk]), partitions(p0), 
      limit(1), offset(nil)
  3 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "opt.pullup1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 71   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT pk FROM pullup2 GROUP BY pullup2.c1); 
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |HASH JOIN      |       |100      |500 |
|1 | TABLE SCAN    |pullup1|100      |90  |
|2 | SUBPLAN SCAN  |VIEW1  |100      |208 |
|3 |  HASH GROUP BY|       |100      |195 |
|4 |   TABLE SCAN  |pullup2|100      |90  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.pk]), other_conds(nil)
  1 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  2 - output([VIEW1.pk]), filter(nil), 
      access([VIEW1.pk])
  3 - output([pullup2.pk]), filter(nil), 
      group([pullup2.c1]), agg_func(nil)
  4 - output([pullup2.pk], [pullup2.c1]), filter(nil), 
      access([pullup2.pk], [pullup2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      USE_HASH_AGGREGATION(@"SEL$2")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 72   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT pk FROM pullup2 UNION ALL SELECT pk FROM pullup3); 
==================================================
|ID|OPERATOR              |NAME   |EST. ROWS|COST|
--------------------------------------------------
|0 |MERGE JOIN            |       |198      |625 |
|1 | SORT                 |       |100      |198 |
|2 |  TABLE SCAN          |pullup1|100      |90  |
|3 | SUBPLAN SCAN         |VIEW1  |200      |269 |
|4 |  MERGE UNION DISTINCT|       |200      |241 |
|5 |   TABLE SCAN         |pullup2|100      |88  |
|6 |   TABLE SCAN         |pullup3|100      |88  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.pk]), other_conds(nil)
  1 - output([pullup1.c1]), filter(nil), sort_keys([pullup1.c1, ASC])
  2 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  3 - output([VIEW1.pk]), filter(nil), 
      access([VIEW1.pk])
  4 - output([UNION(pullup2.pk, pullup3.pk)]), filter(nil)
  5 - output([pullup2.pk]), filter(nil), 
      access([pullup2.pk]), partitions(p0)
  6 - output([pullup3.pk]), filter(nil), 
      access([pullup3.pk]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      FULL(@"SEL$3" "opt.pullup3"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 73   ***************
SQL: SELECT c1 FROM pullup1 WHERE 1 IN (SELECT c1 FROM pullup2); 
======================================================
|ID|OPERATOR                  |NAME   |EST. ROWS|COST|
------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|       |100      |371 |
|1 | SUBPLAN SCAN             |VIEW1  |1        |217 |
|2 |  HASH DISTINCT           |       |100      |195 |
|3 |   TABLE SCAN             |pullup2|100      |90  |
|4 | TABLE SCAN               |pullup1|100      |90  |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([1]), filter([VIEW1.c1 = ?]), 
      access([VIEW1.c1])
  2 - output([pullup2.c1]), filter(nil), 
      distinct([pullup2.c1])
  3 - output([pullup2.c1]), filter(nil), 
      access([pullup2.c1]), partitions(p0)
  4 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "opt.pullup1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 74   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT 1 FROM pullup2); 
=========================================
|ID|OPERATOR     |NAME   |EST. ROWS|COST|
-----------------------------------------
|0 |HASH JOIN    |       |1        |163 |
|1 | SUBPLAN SCAN|VIEW1  |1        |37  |
|2 |  TABLE SCAN |pullup2|1        |36  |
|3 | TABLE SCAN  |pullup1|100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.1]), other_conds(nil)
  1 - output([VIEW1.1]), filter(nil), 
      access([VIEW1.1])
  2 - output([?]), filter(nil), 
      access([pullup2.pk]), partitions(p0), 
      limit(1), offset(nil)
  3 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "opt.pullup1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 75   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT floor(pk) FROM pullup2); 
=================================================
|ID|OPERATOR       |NAME         |EST. ROWS|COST|
-------------------------------------------------
|0 |HASH JOIN      |             |100      |475 |
|1 | TABLE SCAN    |pullup1      |100      |90  |
|2 | SUBPLAN SCAN  |VIEW1        |100      |170 |
|3 |  HASH DISTINCT|             |100      |157 |
|4 |   TABLE SCAN  |pullup2(uniq)|100      |52  |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.floor(pk)]), other_conds(nil)
  1 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  2 - output([VIEW1.floor(pk)]), filter(nil), 
      access([VIEW1.floor(pk)])
  3 - output([floor(pullup2.pk)]), filter(nil), 
      distinct([floor(pullup2.pk)])
  4 - output([floor(pullup2.pk)]), filter(nil), 
      access([pullup2.pk]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      INDEX(@"SEL$2" "opt.pullup2"@"SEL$2" "uniq")
      END_OUTLINE_DATA
  */

***************   Case 76   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT c1 FROM pullup2); 
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |HASH JOIN      |       |100      |500 |
|1 | TABLE SCAN    |pullup1|100      |90  |
|2 | SUBPLAN SCAN  |VIEW1  |100      |208 |
|3 |  HASH DISTINCT|       |100      |195 |
|4 |   TABLE SCAN  |pullup2|100      |90  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.c1]), other_conds(nil)
  1 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([pullup2.c1]), filter(nil), 
      distinct([pullup2.c1])
  4 - output([pullup2.c1]), filter(nil), 
      access([pullup2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 77   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT pullup2.pk FROM pullup2, pullup3); 
===============================================================
|ID|OPERATOR                     |NAME         |EST. ROWS|COST|
---------------------------------------------------------------
|0 |MERGE JOIN                   |             |100      |9749|
|1 | SORT                        |             |100      |198 |
|2 |  TABLE SCAN                 |pullup1      |100      |90  |
|3 | SUBPLAN SCAN                |VIEW1        |100      |9466|
|4 |  MERGE DISTINCT             |             |100      |9452|
|5 |   NESTED-LOOP JOIN CARTESIAN|             |10000    |7235|
|6 |    TABLE SCAN               |pullup2      |100      |88  |
|7 |    MATERIAL                 |             |100      |71  |
|8 |     TABLE SCAN              |pullup3(uniq)|100      |52  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.pk]), other_conds(nil)
  1 - output([pullup1.c1]), filter(nil), sort_keys([pullup1.c1, ASC])
  2 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  3 - output([VIEW1.pk]), filter(nil), 
      access([VIEW1.pk])
  4 - output([pullup2.pk]), filter(nil), 
      distinct([pullup2.pk])
  5 - output([pullup2.pk]), filter(nil), 
      conds(nil), nl_params_(nil)
  6 - output([pullup2.pk]), filter(nil), 
      access([pullup2.pk]), partitions(p0)
  7 - output([1]), filter(nil)
  8 - output([pullup3.uniq_c2]), filter(nil), 
      access([pullup3.uniq_c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      LEADING(@"SEL$2" ("opt.pullup2"@"SEL$2" "opt.pullup3"@"SEL$2" ))
      USE_NL(@"SEL$2" ("opt.pullup3"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("opt.pullup3"@"SEL$2" ))
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      INDEX(@"SEL$2" "opt.pullup3"@"SEL$2" "uniq")
      END_OUTLINE_DATA
  */

***************   Case 78   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT pk FROM (select * from pullup2 limit 1)); 
=========================================
|ID|OPERATOR     |NAME   |EST. ROWS|COST|
-----------------------------------------
|0 |HASH JOIN    |       |1        |161 |
|1 | SUBPLAN SCAN|VIEW1  |1        |37  |
|2 |  TABLE SCAN |pullup2|1        |36  |
|3 | TABLE SCAN  |pullup1|100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.pk]), other_conds(nil)
  1 - output([VIEW1.pk]), filter(nil), 
      access([VIEW1.pk])
  2 - output([pullup2.pk]), filter(nil), 
      access([pullup2.pk]), partitions(p0), 
      limit(1), offset(nil)
  3 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "opt.pullup1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      FULL(@"SEL$3" "opt.pullup2"@"SEL$3")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 79   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT pullup2.pk FROM pullup2 JOIN pullup3 on pullup2.c3 = pullup3.c3); 
===========================================
|ID|OPERATOR       |NAME   |EST. ROWS|COST|
-------------------------------------------
|0 |HASH JOIN      |       |100      |791 |
|1 | TABLE SCAN    |pullup1|100      |90  |
|2 | SUBPLAN SCAN  |VIEW1  |100      |500 |
|3 |  HASH DISTINCT|       |100      |486 |
|4 |   HASH JOIN   |       |100      |382 |
|5 |    TABLE SCAN |pullup3|100      |90  |
|6 |    TABLE SCAN |pullup2|100      |90  |
===========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.pk]), other_conds(nil)
  1 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  2 - output([VIEW1.pk]), filter(nil), 
      access([VIEW1.pk])
  3 - output([pullup2.pk]), filter(nil), 
      distinct([pullup2.pk])
  4 - output([pullup2.pk]), filter(nil), 
      equal_conds([pullup2.c3 = pullup3.c3]), other_conds(nil)
  5 - output([pullup3.c3]), filter(nil), 
      access([pullup3.c3]), partitions(p0)
  6 - output([pullup2.c3], [pullup2.pk]), filter(nil), 
      access([pullup2.c3], [pullup2.pk]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      LEADING(@"SEL$2" ("opt.pullup3"@"SEL$2" "opt.pullup2"@"SEL$2" ))
      USE_HASH(@"SEL$2" ("opt.pullup2"@"SEL$2" ))
      FULL(@"SEL$2" "opt.pullup3"@"SEL$2")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 80   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT DISTINCT pullup2.c1 FROM pullup2 WHERE pullup1.c3 = pullup2.c3); 
==========================================
|ID|OPERATOR      |NAME   |EST. ROWS|COST|
------------------------------------------
|0 |HASH SEMI JOIN|       |100      |424 |
|1 | TABLE SCAN   |pullup1|100      |92  |
|2 | TABLE SCAN   |pullup2|100      |92  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = pullup2.c1], [pullup1.c3 = pullup2.c3]), other_conds(nil)
  1 - output([pullup1.c3], [pullup1.c1]), filter(nil), 
      access([pullup1.c3], [pullup1.c1]), partitions(p0)
  2 - output([pullup2.c3], [pullup2.c1]), filter(nil), 
      access([pullup2.c3], [pullup2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "opt.pullup2"@"SEL$2" ))
      USE_HASH(@"SEL$1" ("opt.pullup2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 81   ***************
SQL: SELECT c1 FROM pullup1 WHERE c1 IN (SELECT c1 FROM pullup2) ORDER BY c3; 
============================================
|ID|OPERATOR        |NAME   |EST. ROWS|COST|
--------------------------------------------
|0 |SORT            |       |100      |648 |
|1 | HASH JOIN      |       |100      |502 |
|2 |  SUBPLAN SCAN  |VIEW1  |100      |208 |
|3 |   HASH DISTINCT|       |100      |195 |
|4 |    TABLE SCAN  |pullup2|100      |90  |
|5 |  TABLE SCAN    |pullup1|100      |92  |
============================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), sort_keys([pullup1.c3, ASC])
  1 - output([pullup1.c1], [pullup1.c3]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.c1]), other_conds(nil)
  2 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  3 - output([pullup2.c1]), filter(nil), 
      distinct([pullup2.c1])
  4 - output([pullup2.c1]), filter(nil), 
      access([pullup2.c1]), partitions(p0)
  5 - output([pullup1.c1], [pullup1.c3]), filter(nil), 
      access([pullup1.c1], [pullup1.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "opt.pullup1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.pullup1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 82   ***************
SQL: SELECT c1 FROM pullup1 GROUP BY c1 HAVING c1 IN (SELECT c1 FROM pullup2); 
=============================================
|ID|OPERATOR         |NAME   |EST. ROWS|COST|
---------------------------------------------
|0 |MERGE GROUP BY   |       |100      |540 |
|1 | MERGE JOIN      |       |100      |518 |
|2 |  SORT           |       |100      |198 |
|3 |   TABLE SCAN    |pullup1|100      |90  |
|4 |  SUBPLAN SCAN   |VIEW1  |100      |234 |
|5 |   MERGE DISTINCT|       |100      |220 |
|6 |    SORT         |       |100      |198 |
|7 |     TABLE SCAN  |pullup2|100      |90  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup1.c1]), filter(nil), 
      group([pullup1.c1]), agg_func(nil)
  1 - output([pullup1.c1]), filter(nil), 
      equal_conds([pullup1.c1 = VIEW1.c1]), other_conds(nil)
  2 - output([pullup1.c1]), filter(nil), sort_keys([pullup1.c1, ASC])
  3 - output([pullup1.c1]), filter(nil), 
      access([pullup1.c1]), partitions(p0)
  4 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  5 - output([pullup2.c1]), filter(nil), 
      distinct([pullup2.c1])
  6 - output([pullup2.c1]), filter(nil), sort_keys([pullup2.c1, ASC])
  7 - output([pullup2.c1]), filter(nil), 
      access([pullup2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      NO_USE_HASH_AGGREGATION(@"SEL$1")
      LEADING(@"SEL$1" ("opt.pullup1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.pullup1"@"SEL$1")
      FULL(@"SEL$2" "opt.pullup2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 83   ***************
SQL: SELECT * FROM pullup2 WHERE pk IN (SELECT pullup2.pk FROM pullup2 GROUP BY pullup2.pk DESC); 
======================================
|ID|OPERATOR  |NAME   |EST. ROWS|COST|
--------------------------------------
|0 |TABLE SCAN|pullup2|100      |95  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([pullup2.pk], [pullup2.c1], [pullup2.uniq_c2], [pullup2.c3]), filter(nil), 
      access([pullup2.pk], [pullup2.c1], [pullup2.uniq_c2], [pullup2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.pullup2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 84   ***************
SQL: select * from (select * from t1 where c1 > ANY(select c1 from t2 where c1 > 0 group by c2)) as v where v.c1 in (select c1 from t2); 
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |MERGE JOIN            |     |34       |3279|
|1 | NESTED-LOOP SEMI JOIN|     |34       |3154|
|2 |  TABLE SCAN          |t1   |100      |90  |
|3 |  MATERIAL            |     |100      |227 |
|4 |   SUBPLAN SCAN       |VIEW1|100      |208 |
|5 |    HASH GROUP BY     |     |100      |195 |
|6 |     TABLE SCAN       |t2   |100      |90  |
|7 | TABLE SCAN           |t2   |100      |88  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > VIEW1.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.c1]), filter(nil)
  4 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  5 - output([t2.c1]), filter(nil), 
      group([t2.c2]), agg_func(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" (("opt.t1"@"SEL$2" "VIEW1"@"SEL$2" )"opt.t2"@"SEL$4" ))
      USE_MERGE(@"SEL$2" ("opt.t2"@"SEL$4" ))
      USE_NL(@"SEL$2" ("VIEW1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("VIEW1"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      USE_HASH_AGGREGATION(@"SEL$3")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      FULL(@"SEL$4" "opt.t2"@"SEL$4")
      END_OUTLINE_DATA
  */

***************   Case 85   ***************
SQL: select * from (select * from t1 where c1 > ANY(select c1 from t2 where c1 > 0 group by c2)) as v where v.c1 in (select c1 from t2); 
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |MERGE JOIN            |     |34       |3279|
|1 | NESTED-LOOP SEMI JOIN|     |34       |3154|
|2 |  TABLE SCAN          |t1   |100      |90  |
|3 |  MATERIAL            |     |100      |227 |
|4 |   SUBPLAN SCAN       |VIEW1|100      |208 |
|5 |    HASH GROUP BY     |     |100      |195 |
|6 |     TABLE SCAN       |t2   |100      |90  |
|7 | TABLE SCAN           |t2   |100      |88  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > VIEW1.c1]), nl_params_(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([VIEW1.c1]), filter(nil)
  4 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  5 - output([t2.c1]), filter(nil), 
      group([t2.c2]), agg_func(nil)
  6 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" (("opt.t1"@"SEL$2" "VIEW1"@"SEL$2" )"opt.t2"@"SEL$4" ))
      USE_MERGE(@"SEL$2" ("opt.t2"@"SEL$4" ))
      USE_NL(@"SEL$2" ("VIEW1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("VIEW1"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      USE_HASH_AGGREGATION(@"SEL$3")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      FULL(@"SEL$4" "opt.t2"@"SEL$4")
      END_OUTLINE_DATA
  */

***************   Case 86   ***************
SQL: select * from t1 left join t2 on t1.c1 = t2.c1, (select * from t3) as v3; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |8070|
|1 | MERGE OUTER JOIN         |    |100      |269 |
|2 |  TABLE SCAN              |t1  |100      |90  |
|3 |  TABLE SCAN              |t2  |100      |92  |
|4 | MATERIAL                 |    |100      |203 |
|5 |  TABLE SCAN              |t3  |100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"opt.t3"@"SEL$2" ))
      USE_NL(@"SEL$1" ("opt.t3"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t3"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t3"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 87   ***************
SQL: select * from t1 left join t2 on t1.c1 = t2.c1, t3; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |8070|
|1 | MERGE OUTER JOIN         |    |100      |269 |
|2 |  TABLE SCAN              |t1  |100      |90  |
|3 |  TABLE SCAN              |t2  |100      |92  |
|4 | MATERIAL                 |    |100      |203 |
|5 |  TABLE SCAN              |t3  |100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"opt.t3"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t3"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t3"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 88   ***************
SQL: select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2, (select * from t3) as v3; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |8455|
|1 | HASH RIGHT OUTER JOIN    |    |100      |655 |
|2 |  TABLE SCAN              |t3  |100      |92  |
|3 |  MERGE OUTER JOIN        |    |100      |269 |
|4 |   TABLE SCAN             |t1  |100      |90  |
|5 |   TABLE SCAN             |t2  |100      |92  |
|6 | MATERIAL                 |    |100      |203 |
|7 |  TABLE SCAN              |t3  |100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  2 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t3"@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))"opt.t3"@"SEL$2" ))
      USE_NL(@"SEL$1" ("opt.t3"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t3"@"SEL$2" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t3"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 89   ***************
SQL: select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2, t3 as v3; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |8455|
|1 | HASH RIGHT OUTER JOIN    |    |100      |655 |
|2 |  TABLE SCAN              |t3  |100      |92  |
|3 |  MERGE OUTER JOIN        |    |100      |269 |
|4 |   TABLE SCAN             |t1  |100      |90  |
|5 |   TABLE SCAN             |t2  |100      |92  |
|6 | MATERIAL                 |    |100      |203 |
|7 |  TABLE SCAN              |v3  |100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [v3.c1], [v3.c2], [v3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  2 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  6 - output([v3.c1], [v3.c2], [v3.c3]), filter(nil)
  7 - output([v3.c1], [v3.c2], [v3.c3]), filter(nil), 
      access([v3.c1], [v3.c2], [v3.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t3"@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))"opt.v3"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.v3"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.v3"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.v3"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 90   ***************
SQL: select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t1.c1 = t3.c1 join t4 on t4.c1=t3.c1 join t5 on t3.c1 = t5.c2, (select * from t3) as v3, (select * from t2) as v2; 
======================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST  |
------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |1000000  |768876|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |8811  |
|2 |  MERGE JOIN               |    |100      |1010  |
|3 |   MERGE JOIN              |    |100      |831   |
|4 |    MERGE JOIN             |    |100      |653   |
|5 |     MERGE JOIN            |    |100      |476   |
|6 |      TABLE SCAN           |t3  |100      |92    |
|7 |      SORT                 |    |100      |297   |
|8 |       TABLE SCAN          |t5  |100      |92    |
|9 |     TABLE SCAN            |t1  |100      |90    |
|10|    TABLE SCAN             |t2  |100      |92    |
|11|   TABLE SCAN              |t4  |100      |92    |
|12|  MATERIAL                 |    |100      |203   |
|13|   TABLE SCAN              |t3  |100      |92    |
|14| MATERIAL                  |    |100      |203   |
|15|  TABLE SCAN               |t2  |100      |92    |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t3.c1], [t3.c2], [t3.c3], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t3.c1 = t5.c2]), other_conds(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  7 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c2, ASC])
  8 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  14 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  15 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (((((("opt.t3"@"SEL$1" "opt.t5"@"SEL$1" )"opt.t1"@"SEL$1" )"opt.t2"@"SEL$1" )"opt.t4"@"SEL$1" )"opt.t3"@"SEL$2" )"opt.t2"@"SEL$3" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$3" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$3" ))
      USE_NL(@"SEL$1" ("opt.t3"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t3"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t4"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t5"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$1" "opt.t5"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$2" "opt.t3"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 91   ***************
SQL: select * from t1 left join t2 on t1.c1 = t2.c1 left join t3 on t1.c2 = t3.c2 join t4 on t3.c2 = t4.c2 join t5 on t4.c1=t5.c1, t3 as v3; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |9056|
|1 | HASH JOIN                |    |100      |1256|
|2 |  MERGE OUTER JOIN        |    |100      |269 |
|3 |   TABLE SCAN             |t1  |100      |90  |
|4 |   TABLE SCAN             |t2  |100      |92  |
|5 |  HASH JOIN               |    |100      |657 |
|6 |   TABLE SCAN             |t3  |100      |92  |
|7 |   MERGE JOIN             |    |100      |271 |
|8 |    TABLE SCAN            |t4  |100      |92  |
|9 |    TABLE SCAN            |t5  |100      |92  |
|10| MATERIAL                 |    |100      |203 |
|11|  TABLE SCAN              |v3  |100      |92  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [v3.c1], [v3.c2], [v3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t1.c2 = t3.c2]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t3.c2 = t4.c2]), other_conds(nil)
  6 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  7 - output([t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t4.c1 = t5.c1]), other_conds(nil)
  8 - output([t4.c2], [t4.c1], [t4.c3]), filter(nil), 
      access([t4.c2], [t4.c1], [t4.c3]), partitions(p0)
  9 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      access([t5.c1], [t5.c2], [t5.c3]), partitions(p0)
  10 - output([v3.c1], [v3.c2], [v3.c3]), filter(nil)
  11 - output([v3.c1], [v3.c2], [v3.c3]), filter(nil), 
      access([v3.c1], [v3.c2], [v3.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ((("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )("opt.t3"@"SEL$1" ("opt.t4"@"SEL$1" "opt.t5"@"SEL$1" )))"opt.v3"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.v3"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.v3"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t3"@"SEL$1" "opt.t4"@"SEL$1" "opt.t5"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      USE_HASH(@"SEL$1" ("opt.t4"@"SEL$1" "opt.t5"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.t5"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$1" "opt.t5"@"SEL$1")
      FULL(@"SEL$1" "opt.v3"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 92   ***************
SQL: select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t1.c1 = t3.c1, (select * from t3) as v3, (select * from t2) as v2; 
======================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST  |
------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |1000000  |768314|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |8249  |
|2 |  MERGE JOIN               |    |100      |448   |
|3 |   MERGE JOIN              |    |100      |269   |
|4 |    TABLE SCAN             |t1  |100      |90    |
|5 |    TABLE SCAN             |t3  |100      |92    |
|6 |   TABLE SCAN              |t2  |100      |92    |
|7 |  MATERIAL                 |    |100      |203   |
|8 |   TABLE SCAN              |t3  |100      |92    |
|9 | MATERIAL                  |    |100      |203   |
|10|  TABLE SCAN               |t2  |100      |92    |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t3.c1], [t3.c2], [t3.c3], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  7 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  8 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  9 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (((("opt.t1"@"SEL$1" "opt.t3"@"SEL$1" )"opt.t2"@"SEL$1" )"opt.t3"@"SEL$2" )"opt.t2"@"SEL$3" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$3" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$3" ))
      USE_NL(@"SEL$1" ("opt.t3"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t3"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t3"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t3"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 93   ***************
SQL: select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t1.c1 = t3.c1, t3 as v3, t2 as v2; 
======================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST  |
------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |1000000  |768314|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |8249  |
|2 |  MERGE JOIN               |    |100      |448   |
|3 |   MERGE JOIN              |    |100      |269   |
|4 |    TABLE SCAN             |t1  |100      |90    |
|5 |    TABLE SCAN             |t3  |100      |92    |
|6 |   TABLE SCAN              |t2  |100      |92    |
|7 |  MATERIAL                 |    |100      |203   |
|8 |   TABLE SCAN              |v3  |100      |92    |
|9 | MATERIAL                  |    |100      |203   |
|10|  TABLE SCAN               |v2  |100      |92    |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [v3.c1], [v3.c2], [v3.c3], [v2.c1], [v2.c2], [v2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [v3.c1], [v3.c2], [v3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  7 - output([v3.c1], [v3.c2], [v3.c3]), filter(nil)
  8 - output([v3.c1], [v3.c2], [v3.c3]), filter(nil), 
      access([v3.c1], [v3.c2], [v3.c3]), partitions(p0)
  9 - output([v2.c1], [v2.c2], [v2.c3]), filter(nil)
  10 - output([v2.c1], [v2.c2], [v2.c3]), filter(nil), 
      access([v2.c1], [v2.c2], [v2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (((("opt.t1"@"SEL$1" "opt.t3"@"SEL$1" )"opt.t2"@"SEL$1" )"opt.v3"@"SEL$1" )"opt.v2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.v2"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.v2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.v3"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.v3"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t3"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.v3"@"SEL$1")
      FULL(@"SEL$1" "opt.v2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 94   ***************
SQL: select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t1.c1 = t3.c1 join t4 on t4.c1=t3.c1 join t5 on t3.c1 = t5.c2, (select * from t3) as v3, (select * from t2) as v2; 
======================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST  |
------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |1000000  |768876|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |8811  |
|2 |  MERGE JOIN               |    |100      |1010  |
|3 |   MERGE JOIN              |    |100      |831   |
|4 |    MERGE JOIN             |    |100      |653   |
|5 |     MERGE JOIN            |    |100      |476   |
|6 |      TABLE SCAN           |t3  |100      |92    |
|7 |      SORT                 |    |100      |297   |
|8 |       TABLE SCAN          |t5  |100      |92    |
|9 |     TABLE SCAN            |t1  |100      |90    |
|10|    TABLE SCAN             |t2  |100      |92    |
|11|   TABLE SCAN              |t4  |100      |92    |
|12|  MATERIAL                 |    |100      |203   |
|13|   TABLE SCAN              |t3  |100      |92    |
|14| MATERIAL                  |    |100      |203   |
|15|  TABLE SCAN               |t2  |100      |92    |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t3.c1], [t3.c2], [t3.c3], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t4.c1], [t4.c2], [t4.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t4.c1 = t3.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  5 - output([t3.c1], [t3.c2], [t3.c3], [t5.c1], [t5.c2], [t5.c3]), filter(nil), 
      equal_conds([t3.c1 = t5.c2]), other_conds(nil)
  6 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  7 - output([t5.c1], [t5.c2], [t5.c3]), filter(nil), sort_keys([t5.c2, ASC])
  8 - output([t5.c2], [t5.c1], [t5.c3]), filter(nil), 
      access([t5.c2], [t5.c1], [t5.c3]), partitions(p0)
  9 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  10 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  11 - output([t4.c1], [t4.c2], [t4.c3]), filter(nil), 
      access([t4.c1], [t4.c2], [t4.c3]), partitions(p0)
  12 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil)
  13 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  14 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  15 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (((((("opt.t3"@"SEL$1" "opt.t5"@"SEL$1" )"opt.t1"@"SEL$1" )"opt.t2"@"SEL$1" )"opt.t4"@"SEL$1" )"opt.t3"@"SEL$2" )"opt.t2"@"SEL$3" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$3" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$3" ))
      USE_NL(@"SEL$1" ("opt.t3"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t3"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t4"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t5"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$1" "opt.t5"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t4"@"SEL$1")
      FULL(@"SEL$2" "opt.t3"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 95   ***************
SQL: select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t1.c1 = t3.c1, t3 as v3, t2 as v2; 
======================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST  |
------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |1000000  |768314|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |8249  |
|2 |  MERGE JOIN               |    |100      |448   |
|3 |   MERGE JOIN              |    |100      |269   |
|4 |    TABLE SCAN             |t1  |100      |90    |
|5 |    TABLE SCAN             |t3  |100      |92    |
|6 |   TABLE SCAN              |t2  |100      |92    |
|7 |  MATERIAL                 |    |100      |203   |
|8 |   TABLE SCAN              |v3  |100      |92    |
|9 | MATERIAL                  |    |100      |203   |
|10|  TABLE SCAN               |v2  |100      |92    |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [v3.c1], [v3.c2], [v3.c3], [v2.c1], [v2.c2], [v2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3], [v3.c1], [v3.c2], [v3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  6 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  7 - output([v3.c1], [v3.c2], [v3.c3]), filter(nil)
  8 - output([v3.c1], [v3.c2], [v3.c3]), filter(nil), 
      access([v3.c1], [v3.c2], [v3.c3]), partitions(p0)
  9 - output([v2.c1], [v2.c2], [v2.c3]), filter(nil)
  10 - output([v2.c1], [v2.c2], [v2.c3]), filter(nil), 
      access([v2.c1], [v2.c2], [v2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (((("opt.t1"@"SEL$1" "opt.t3"@"SEL$1" )"opt.t2"@"SEL$1" )"opt.v3"@"SEL$1" )"opt.v2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.v2"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.v2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.v3"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.v3"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t3"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.v3"@"SEL$1")
      FULL(@"SEL$1" "opt.v2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 96   ***************
SQL: select t1.c1 from t1 join t2 on t1.c1 = t2.c1, (select t2.c1 from (t2 join t3 on t2.c1 = t3.c1)) as v; 
=====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST |
-----------------------------------------------------
|0 |MERGE JOIN                 |    |10000    |14980|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7568 |
|2 |  TABLE SCAN               |t2  |100      |88   |
|3 |  MATERIAL                 |    |100      |299  |
|4 |   MERGE JOIN              |    |100      |262  |
|5 |    TABLE SCAN             |t1  |100      |88   |
|6 |    TABLE SCAN             |t2  |100      |88   |
|7 | TABLE SCAN                |t3  |100      |88   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil)
  4 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  7 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t2"@"SEL$2" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))"opt.t3"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t3"@"SEL$2" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t3"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 97   ***************
SQL: select t1.c1 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |437 |
|1 | MERGE JOIN |    |100      |262 |
|2 |  TABLE SCAN|t1  |100      |88  |
|3 |  TABLE SCAN|t2  |100      |88  |
|4 | TABLE SCAN |t3  |100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  1 - output([t1.c1], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"opt.t3"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t3"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 98   ***************
SQL: select * from (select t1.c1 from t1 join t2 on t1.c1 = t2.c1) as v; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |262 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$2" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 99   ***************
SQL: select t1.c1 from t1, t2 where t1.c1 = t2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |262 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 100   ***************
SQL: select * from (select * from t1 where c1 > 0 group by c2) as v; 
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |100      |195 |
|1 | TABLE SCAN  |t1  |100      |90  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      group([t1.c2]), agg_func(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      USE_HASH_AGGREGATION(@"SEL$2")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 101   ***************
SQL: select * from (select t2.c1 from t1, t2 join t3 on t2.c1 = t3.c1 where t1.c1 > 0) as v; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7445|
|1 | MERGE JOIN               |    |100      |262 |
|2 |  TABLE SCAN              |t2  |100      |88  |
|3 |  TABLE SCAN              |t3  |100      |88  |
|4 | MATERIAL                 |    |100      |106 |
|5 |  TABLE SCAN              |t1  |100      |88  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([1]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" (("opt.t2"@"SEL$2" "opt.t3"@"SEL$2" )"opt.t1"@"SEL$2" ))
      USE_NL(@"SEL$2" ("opt.t1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("opt.t1"@"SEL$2" ))
      USE_MERGE(@"SEL$2" ("opt.t3"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$2" "opt.t3"@"SEL$2")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 102   ***************
SQL: select t2.c1 from t1, t2 join t3 on t2.c1 = t3.c1 where t1.c1 > 0; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7445|
|1 | MERGE JOIN               |    |100      |262 |
|2 |  TABLE SCAN              |t2  |100      |88  |
|3 |  TABLE SCAN              |t3  |100      |88  |
|4 | MATERIAL                 |    |100      |106 |
|5 |  TABLE SCAN              |t1  |100      |88  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([1]), filter(nil)
  5 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t2"@"SEL$1" "opt.t3"@"SEL$1" )"opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t3"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 103   ***************
SQL: select * from t1 left join (select * from t2) as v on v.c1 = t1.c1; 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |100      |283 |
|1 | TABLE SCAN     |t1  |100      |90  |
|2 | SUBPLAN SCAN   |v   |100      |106 |
|3 |  TABLE SCAN    |t2  |100      |92  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [v.c1], [v.c2], [v.c3]), filter(nil), 
      equal_conds([v.c1 = t1.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([v.c1], [v.c2], [v.c3]), filter(nil), 
      access([v.c1], [v.c2], [v.c3])
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "v"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("v"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 104   ***************
SQL: select * from t1 left join (select * from t2) as v on v.c2 = t1.c2 where v.c2 is not null; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |419 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |109 |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c2 = t1.c2]), other_conds(nil)
  1 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 105   ***************
SQL: select * from t1 left join (select * from t2) as v on v.c2 = t1.c2 where v.c2 is not null; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |419 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |109 |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c2 = t1.c2]), other_conds(nil)
  1 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([(T_OP_IS_NOT, t2.c2, NULL, 0)]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 106   ***************
SQL: select * from t1 as v where v.c1 > 0; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|v   |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([v.c1], [v.c2]), filter(nil), 
      access([v.c1], [v.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.v"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 107   ***************
SQL: select * from (select * from t1) as v; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |90  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 108   ***************
SQL: select * from (select * from t1) as v left join t3 on v.c1=t3.c1 where t3.c2 is not null; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |286 |
|1 | TABLE SCAN|t3  |100      |109 |
|2 | TABLE SCAN|t1  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  1 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$1" "opt.t1"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 109   ***************
SQL: select * from t1 join (select * from t2) as v on t1.c1 = v.c1 left join t3 on t1.c1 = t3.c1 where t3.c2 is not null; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |465 |
|1 | MERGE JOIN |    |100      |286 |
|2 |  TABLE SCAN|t1  |100      |90  |
|3 |  TABLE SCAN|t3  |100      |109 |
|4 | TABLE SCAN |t2  |100      |92  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t1"@"SEL$1" "opt.t3"@"SEL$1" )"opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t3"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 110   ***************
SQL: select * from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t3.c2 is not null; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |465 |
|1 | MERGE JOIN |    |100      |286 |
|2 |  TABLE SCAN|t1  |100      |90  |
|3 |  TABLE SCAN|t3  |100      |109 |
|4 | TABLE SCAN |t2  |100      |92  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t3.c1], [t3.c2], [t3.c3]), filter([(T_OP_IS_NOT, t3.c2, NULL, 0)]), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t1"@"SEL$1" "opt.t3"@"SEL$1" )"opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t3"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 111   ***************
SQL: select * from t1 join (select * from t2) as v2 on t1.c1 = v2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 112   ***************
SQL: select * from t1, t2 where t1.c1 = t2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 113   ***************
SQL: select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |100      |655 |
|1 | TABLE SCAN |t3  |100      |92  |
|2 | MERGE JOIN |    |100      |269 |
|3 |  TABLE SCAN|t1  |100      |90  |
|4 |  TABLE SCAN|t2  |100      |92  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 114   ***************
SQL: select * from t1 inner join t2 on t1.c1 = t2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 115   ***************
SQL: select * from (select * from t1 where c1 > 1 + (select avg(c2) from t2)) as v; 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |34       |218 |
|1 | TABLE SCAN     |t1  |100      |90  |
|2 | SCALAR GROUP BY|    |1        |115 |
|3 |  TABLE SCAN    |t2  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? + subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([T_FUN_SUM(t2.c2) / T_FUN_COUNT(t2.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2.c2)], [T_FUN_COUNT(t2.c2)])
  3 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 116   ***************
SQL: select * from t1 where c1 > 1 + (select avg(c2) from t2); 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |34       |218 |
|1 | TABLE SCAN     |t1  |100      |90  |
|2 | SCALAR GROUP BY|    |1        |115 |
|3 |  TABLE SCAN    |t2  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? + subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([T_FUN_SUM(t2.c2) / T_FUN_COUNT(t2.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2.c2)], [T_FUN_COUNT(t2.c2)])
  3 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 117   ***************
SQL: select * from (select * from t1 where c1 > 1 + (select avg(c2) from t2)) as v, t3; 
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |3334     |8894|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7400|
|2 |  TABLE SCAN               |t3  |100      |92  |
|3 |  MATERIAL                 |    |100      |127 |
|4 |   TABLE SCAN              |t1  |100      |90  |
|5 | SCALAR GROUP BY           |    |1        |115 |
|6 |  TABLE SCAN               |t2  |100      |90  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? + subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([T_FUN_SUM(t2.c2) / T_FUN_COUNT(t2.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2.c2)], [T_FUN_COUNT(t2.c2)])
  6 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$1" "opt.t1"@"SEL$2" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 118   ***************
SQL: select * from t1, t3 where t1.c1 > 1 + (select avg(c2) from t2); 
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |3334     |8894|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7400|
|2 |  TABLE SCAN               |t3  |100      |92  |
|3 |  MATERIAL                 |    |100      |127 |
|4 |   TABLE SCAN              |t1  |100      |90  |
|5 | SCALAR GROUP BY           |    |1        |115 |
|6 |  TABLE SCAN               |t2  |100      |90  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? + subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([T_FUN_SUM(t2.c2) / T_FUN_COUNT(t2.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2.c2)], [T_FUN_COUNT(t2.c2)])
  6 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 119   ***************
SQL: select * from (select * from t1 where c1 > 1 + (select avg(c2) from t2)) as v join t3 on v.c1=t3.c1; 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |SUBPLAN FILTER  |    |34       |397 |
|1 | MERGE JOIN     |    |100      |269 |
|2 |  TABLE SCAN    |t3  |100      |92  |
|3 |  TABLE SCAN    |t1  |100      |90  |
|4 | SCALAR GROUP BY|    |1        |115 |
|5 |  TABLE SCAN    |t2  |100      |90  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? + subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([T_FUN_SUM(t2.c2) / T_FUN_COUNT(t2.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2.c2)], [T_FUN_COUNT(t2.c2)])
  5 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$1" "opt.t1"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 120   ***************
SQL: select * from t1, t3 where t1.c1 > 1 + (select avg(c2) from t2); 
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |SUBPLAN FILTER             |    |3334     |8894|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7400|
|2 |  TABLE SCAN               |t3  |100      |92  |
|3 |  MATERIAL                 |    |100      |127 |
|4 |   TABLE SCAN              |t1  |100      |90  |
|5 | SCALAR GROUP BY           |    |1        |115 |
|6 |  TABLE SCAN               |t2  |100      |90  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      exec_params_(nil), onetime_exprs_([? + subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)
  3 - output([t1.c1], [t1.c2]), filter(nil)
  4 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  5 - output([T_FUN_SUM(t2.c2) / T_FUN_COUNT(t2.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2.c2)], [T_FUN_COUNT(t2.c2)])
  6 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 121   ***************
SQL: select * from (select * from t1 where c1 in (select c1 from t2 where t1.c1=t2.c1)) as v where v.c1 > 0; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_MERGE(@"SEL$2" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 122   ***************
SQL: select * from t1 where c1 in (select c1 from t2 where t1.c1=t2.c1) and c1 > 0; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 123   ***************
SQL: select * from (select * from t1 where c1 in (select c1 from t2 where t1.c1=t2.c1)) as v where v.c1 in (select c1 from t2); 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_MERGE(@"SEL$2" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 124   ***************
SQL: select * from t1 where c1 in (select c1 from t2 where t1.c1=t2.c1) and c1 in (select c1 from t2); 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 125   ***************
SQL: select * from (select * from t1 where Exists (select c1 from t2)) as v where v.c1 = 1; 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |88  |
|1 | TABLE GET    |t1  |1        |52  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 126   ***************
SQL: select * from t1 where Exists (select c1 from t2) and t1.c1 = 1; 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |88  |
|1 | TABLE GET    |t1  |1        |52  |
|2 | TABLE SCAN   |t2  |1        |36  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 127   ***************
SQL: select * from (select * from t1 where c1 In (select c1 from t2)) as v where v.c1 = 1; 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |99  |
|1 | TABLE GET      |t2  |1        |52  |
|2 | TABLE GET      |t1  |1        |47  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  1 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("opt.t2"@"SEL$3" "opt.t1"@"SEL$2" ))
      USE_NL(@"SEL$2" ("opt.t1"@"SEL$2" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$2" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 128   ***************
SQL: select * from t1 where c1 In (select c1 from t2) and t1.c1 = 1; 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |99  |
|1 | TABLE GET      |t2  |1        |52  |
|2 | TABLE GET      |t1  |1        |47  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t2.c1])
  1 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$2" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 129   ***************
SQL: select * from (select * from t1 where c1 =ANY (select c1 from t2)) as v where v.c1 + 1 = 2; 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |135 |
|1 | TABLE SCAN     |t1  |1        |99  |
|2 | TABLE GET      |t2  |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  1 - output([t1.c1], [t1.c2]), filter([t1.c1 + ? = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_NL(@"SEL$2" ("opt.t2"@"SEL$3" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$2" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 130   ***************
SQL: select * from t1 where c1 =ANY (select c1 from t2) and c1 + 1 = 2; 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |NESTED-LOOP JOIN|    |1        |135 |
|1 | TABLE SCAN     |t1  |1        |99  |
|2 | TABLE GET      |t2  |1        |36  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_([t1.c1])
  1 - output([t1.c1], [t1.c2]), filter([t1.c1 + ? = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$2" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 131   ***************
SQL: select * from (select * from t1 where c1 >ANY (select c1 from t2)) as v where v.c1 - 10 < 5; 
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|     |12       |150 |
|1 | TABLE SCAN          |t1   |34       |99  |
|2 | MATERIAL            |     |1        |37  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |37  |
|4 |   SCALAR GROUP BY   |     |1        |37  |
|5 |    SUBPLAN SCAN     |VIEW2|1        |37  |
|6 |     TABLE SCAN      |t2   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > VIEW1.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter([t1.c1 + ? < ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([T_FUN_MIN(VIEW2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.c1)])
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("opt.t1"@"SEL$2" "VIEW1"@"SEL$2" ))
      USE_NL(@"SEL$2" ("VIEW1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("VIEW1"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 132   ***************
SQL: select * from t1 where c1 >ANY (select c1 from t2) and t1.c1 - 10 < 5; 
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|     |12       |150 |
|1 | TABLE SCAN          |t1   |34       |99  |
|2 | MATERIAL            |     |1        |37  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |37  |
|4 |   SCALAR GROUP BY   |     |1        |37  |
|5 |    SUBPLAN SCAN     |VIEW2|1        |37  |
|6 |     TABLE SCAN      |t2   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > VIEW1.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter([t1.c1 + ? < ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([T_FUN_MIN(VIEW2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.c1)])
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("VIEW1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 133   ***************
SQL: select * from (select * from t1 where c1 >ANY (select c1 from t2)) as v where v.c1 < 10; 
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|     |34       |172 |
|1 | TABLE SCAN          |t1   |100      |90  |
|2 | MATERIAL            |     |1        |37  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |37  |
|4 |   SCALAR GROUP BY   |     |1        |37  |
|5 |    SUBPLAN SCAN     |VIEW2|1        |37  |
|6 |     TABLE SCAN      |t2   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > VIEW1.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([T_FUN_MIN(VIEW2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.c1)])
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("opt.t1"@"SEL$2" "VIEW1"@"SEL$2" ))
      USE_NL(@"SEL$2" ("VIEW1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("VIEW1"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 134   ***************
SQL: select * from t1 where c1 >ANY (select c1 from t2) and t1.c1 < 10; 
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP SEMI JOIN|     |34       |172 |
|1 | TABLE SCAN          |t1   |100      |90  |
|2 | MATERIAL            |     |1        |37  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |37  |
|4 |   SCALAR GROUP BY   |     |1        |37  |
|5 |    SUBPLAN SCAN     |VIEW2|1        |37  |
|6 |     TABLE SCAN      |t2   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 > VIEW1.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([T_FUN_MIN(VIEW2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.c1)])
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("VIEW1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 135   ***************
SQL: select * from (select * from t1 where c1 <ALL (select c1 from t2)) as v where v.c1 > 10; 
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |67       |145 |
|1 | TABLE SCAN          |t1   |100      |90  |
|2 | MATERIAL            |     |1        |37  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |37  |
|4 |   SCALAR GROUP BY   |     |1        |37  |
|5 |    SUBPLAN SCAN     |VIEW2|1        |37  |
|6 |     TABLE SCAN      |t2   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 >= VIEW1.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([T_FUN_MIN(VIEW2.c1)]), filter([(T_OP_IS_NOT, T_FUN_MIN(VIEW2.c1), NULL, 0)]), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.c1)])
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("opt.t1"@"SEL$2" "VIEW1"@"SEL$2" ))
      USE_NL(@"SEL$2" ("VIEW1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("VIEW1"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 136   ***************
SQL: select * from t1 where c1 <ALL (select c1 from t2) and t1.c1 > 10; 
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |67       |145 |
|1 | TABLE SCAN          |t1   |100      |90  |
|2 | MATERIAL            |     |1        |37  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |37  |
|4 |   SCALAR GROUP BY   |     |1        |37  |
|5 |    SUBPLAN SCAN     |VIEW2|1        |37  |
|6 |     TABLE SCAN      |t2   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 >= VIEW1.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([T_FUN_MIN(VIEW2.c1)]), filter([(T_OP_IS_NOT, T_FUN_MIN(VIEW2.c1), NULL, 0)]), 
      group(nil), agg_func([T_FUN_MIN(VIEW2.c1)])
  5 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  6 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("VIEW1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 137   ***************
SQL: select * from (select * from t1 where c1 <ALL (select c1 from t2 limit 1)) as v where v.c1 > 10; 
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |67       |172 |
|1 | TABLE SCAN          |t1   |100      |90  |
|2 | MATERIAL            |     |1        |37  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |37  |
|4 |   TABLE SCAN        |t2   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 >= VIEW1.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("opt.t1"@"SEL$2" "VIEW1"@"SEL$2" ))
      USE_NL(@"SEL$2" ("VIEW1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("VIEW1"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 138   ***************
SQL: select * from t1 where c1 <ALL (select c1 from t2 limit 1) and t1.c1 > 10; 
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |67       |172 |
|1 | TABLE SCAN          |t1   |100      |90  |
|2 | MATERIAL            |     |1        |37  |
|3 |  SUBPLAN SCAN       |VIEW1|1        |37  |
|4 |   TABLE SCAN        |t2   |1        |36  |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds([t1.c1 >= VIEW1.c1]), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([VIEW1.c1]), filter(nil)
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("VIEW1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 139   ***************
SQL: select * from (select * from t1 where 1 < ANY(select c1 from t2)) as v where v.c1 - 10 = 10; 
===============================================================
|ID|OPERATOR                       |NAME       |EST. ROWS|COST|
---------------------------------------------------------------
|0 |NESTED-LOOP SEMI JOIN CARTESIAN|           |1        |135 |
|1 | TABLE SCAN                    |t1         |1        |99  |
|2 | SUBPLAN SCAN                  |VIEW1      |1        |37  |
|3 |  SCALAR GROUP BY              |           |1        |37  |
|4 |   SUBPLAN SCAN                |VIEW2      |1        |37  |
|5 |    TABLE SCAN                 |t2(Reverse)|1        |36  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter([t1.c1 + ? = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter([VIEW1.c1 > ?]), 
      access([VIEW1.c1])
  3 - output([T_FUN_MAX(VIEW2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW2.c1)])
  4 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("opt.t1"@"SEL$2" "VIEW1"@"SEL$2" ))
      USE_NL(@"SEL$2" ("VIEW1"@"SEL$2" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$2" ("VIEW1"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 140   ***************
SQL: select * from t1 where 1 < ANY(select c1 from t2) and t1.c1 - 10 = 10; 
===============================================================
|ID|OPERATOR                       |NAME       |EST. ROWS|COST|
---------------------------------------------------------------
|0 |NESTED-LOOP SEMI JOIN CARTESIAN|           |1        |135 |
|1 | TABLE SCAN                    |t1         |1        |99  |
|2 | SUBPLAN SCAN                  |VIEW1      |1        |37  |
|3 |  SCALAR GROUP BY              |           |1        |37  |
|4 |   SUBPLAN SCAN                |VIEW2      |1        |37  |
|5 |    TABLE SCAN                 |t2(Reverse)|1        |36  |
===============================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter([t1.c1 + ? = ?]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter([VIEW1.c1 > ?]), 
      access([VIEW1.c1])
  3 - output([T_FUN_MAX(VIEW2.c1)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(VIEW2.c1)])
  4 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  5 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "VIEW1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("VIEW1"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("VIEW1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 141   ***************
SQL: select * from (select * from t1 where 1 < ANY(select c1 from t2 limit 1)) as v where v.c1 = 1; 
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |1        |63  |
|1 | SUBPLAN SCAN             |VIEW1|1        |37  |
|2 |  TABLE SCAN              |t2   |1        |36  |
|3 | TABLE GET                |t1   |1        |52  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([1]), filter([VIEW1.c1 > ?]), 
      access([VIEW1.c1])
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("VIEW1"@"SEL$2" "opt.t1"@"SEL$2" ))
      USE_NL(@"SEL$2" ("opt.t1"@"SEL$2" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$2" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 142   ***************
SQL: select * from t1 where 1 < ANY(select c1 from t2 limit 1) and t1.c1 = 1; 
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |1        |63  |
|1 | SUBPLAN SCAN             |VIEW1|1        |37  |
|2 |  TABLE SCAN              |t2   |1        |36  |
|3 | TABLE GET                |t1   |1        |52  |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([1]), filter([VIEW1.c1 > ?]), 
      access([VIEW1.c1])
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("VIEW1"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 143   ***************
SQL: select * from (select * from t1 where Exists (select c1 from t2 where c2 >ALL (select c1 from t3))) as v where v.c1 > 0; 
=======================================================
|ID|OPERATOR               |NAME       |EST. ROWS|COST|
-------------------------------------------------------
|0 |SUBPLAN FILTER         |           |50       |177 |
|1 | TABLE SCAN            |t1         |100      |90  |
|2 | LIMIT                 |           |1        |73  |
|3 |  NESTED-LOOP ANTI JOIN|           |1        |73  |
|4 |   TABLE SCAN          |t2         |2        |37  |
|5 |   MATERIAL            |           |1        |37  |
|6 |    SUBPLAN SCAN       |VIEW1      |1        |37  |
|7 |     SCALAR GROUP BY   |           |1        |37  |
|8 |      SUBPLAN SCAN     |VIEW2      |1        |37  |
|9 |       TABLE SCAN      |t3(Reverse)|1        |36  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil), 
      conds([t2.c2 <= VIEW1.c1 OR (T_OP_IS, t2.c2, NULL, 0)]), nl_params_(nil)
  4 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  5 - output([VIEW1.c1]), filter(nil)
  6 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  7 - output([T_FUN_MAX(VIEW2.c1)]), filter([(T_OP_IS_NOT, T_FUN_MAX(VIEW2.c1), NULL, 0)]), 
      group(nil), agg_func([T_FUN_MAX(VIEW2.c1)])
  8 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      LEADING(@"SEL$3" ("opt.t2"@"SEL$3" "VIEW1"@"SEL$3" ))
      USE_NL(@"SEL$3" ("VIEW1"@"SEL$3" ))
      USE_NL_MATERIALIZATION(@"SEL$3" ("VIEW1"@"SEL$3" ))
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      FULL(@"SEL$4" "opt.t3"@"SEL$4")
      END_OUTLINE_DATA
  */

***************   Case 144   ***************
SQL: select * from t1 where Exists (select c1 from t2 where c2 >ALL (select c1 from t3)) and t1.c1 > 0; 
=======================================================
|ID|OPERATOR               |NAME       |EST. ROWS|COST|
-------------------------------------------------------
|0 |SUBPLAN FILTER         |           |50       |177 |
|1 | TABLE SCAN            |t1         |100      |90  |
|2 | LIMIT                 |           |1        |73  |
|3 |  NESTED-LOOP ANTI JOIN|           |1        |73  |
|4 |   TABLE SCAN          |t2         |2        |37  |
|5 |   MATERIAL            |           |1        |37  |
|6 |    SUBPLAN SCAN       |VIEW1      |1        |37  |
|7 |     SCALAR GROUP BY   |           |1        |37  |
|8 |      SUBPLAN SCAN     |VIEW2      |1        |37  |
|9 |       TABLE SCAN      |t3(Reverse)|1        |36  |
=======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil), 
      conds([t2.c2 <= VIEW1.c1 OR (T_OP_IS, t2.c2, NULL, 0)]), nl_params_(nil)
  4 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  5 - output([VIEW1.c1]), filter(nil)
  6 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  7 - output([T_FUN_MAX(VIEW2.c1)]), filter([(T_OP_IS_NOT, T_FUN_MAX(VIEW2.c1), NULL, 0)]), 
      group(nil), agg_func([T_FUN_MAX(VIEW2.c1)])
  8 - output([VIEW2.c1]), filter(nil), 
      access([VIEW2.c1])
  9 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      LEADING(@"SEL$2" ("opt.t2"@"SEL$2" "VIEW1"@"SEL$2" ))
      USE_NL(@"SEL$2" ("VIEW1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("VIEW1"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$3" "opt.t3"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 145   ***************
SQL: select * from (select * from t1 where Exists (select c1 from t2 where t1.c2=t2.c2)) as v where v.c1 > 0; 
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |HASH RIGHT SEMI JOIN|    |100      |382 |
|1 | TABLE SCAN         |t2  |100      |90  |
|2 | TABLE SCAN         |t1  |100      |90  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ("opt.t2"@"SEL$3" "opt.t1"@"SEL$2" ))
      USE_HASH(@"SEL$2" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 146   ***************
SQL: select * from t1 where Exists (select c1 from t2 where t1.c2=t2.c2) and t1.c1 > 0; 
=============================================
|ID|OPERATOR            |NAME|EST. ROWS|COST|
---------------------------------------------
|0 |HASH RIGHT SEMI JOIN|    |100      |382 |
|1 | TABLE SCAN         |t2  |100      |90  |
|2 | TABLE SCAN         |t1  |100      |90  |
=============================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      equal_conds([t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  2 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$2" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 147   ***************
SQL: select * from (select (c1 + 1) as k from t1 where c1 <ALL (select c1 from t2 where t1.c2=t2.c2)) as v where v.k > 0; 
==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER  |     |17       |3384|
|1 | TABLE SCAN     |t1   |34       |99  |
|2 | SCALAR GROUP BY|     |1        |99  |
|3 |  SUBPLAN SCAN  |VIEW1|1        |99  |
|4 |   TABLE SCAN   |t2   |1        |99  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?]), filter([t1.c1 < ALL(subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c2], [t1.c1]), filter([t1.c1 + ? > ?]), 
      access([t1.c2], [t1.c1]), partitions(p0)
  2 - output([T_FUN_MIN(VIEW1.c1)]), filter([(T_OP_IS_NOT, T_FUN_MIN(VIEW1.c1), NULL, 0)]), 
      group(nil), agg_func([T_FUN_MIN(VIEW1.c1)])
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t2.c1]), filter([? = t2.c2]), 
      access([t2.c2], [t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 148   ***************
SQL: select (c1 + 1) as k from t1 where c1 <ALL (select c1 from t2 where t1.c2=t2.c2) and t1.c1 > 0; 
==========================================
|ID|OPERATOR        |NAME |EST. ROWS|COST|
------------------------------------------
|0 |SUBPLAN FILTER  |     |50       |9945|
|1 | TABLE SCAN     |t1   |100      |90  |
|2 | SCALAR GROUP BY|     |1        |99  |
|3 |  SUBPLAN SCAN  |VIEW1|1        |99  |
|4 |   TABLE SCAN   |t2   |1        |99  |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?]), filter([t1.c1 < ALL(subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  2 - output([T_FUN_MIN(VIEW1.c1)]), filter([(T_OP_IS_NOT, T_FUN_MIN(VIEW1.c1), NULL, 0)]), 
      group(nil), agg_func([T_FUN_MIN(VIEW1.c1)])
  3 - output([VIEW1.c1]), filter(nil), 
      access([VIEW1.c1])
  4 - output([t2.c1]), filter([? = t2.c2]), 
      access([t2.c2], [t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 149   ***************
SQL: select * from (select (c1 + 1) as k from t1 where c1 !=ANY (select c1 from t2 where t1.c2=t2.c2 limit 1)) as v where v.k > 0; 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |17       |3377|
|1 | TABLE SCAN   |t1  |34       |99  |
|2 | TABLE SCAN   |t2  |1        |99  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?]), filter([t1.c1 != ANY(subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c2], [t1.c1]), filter([t1.c1 + ? > ?]), 
      access([t1.c2], [t1.c1]), partitions(p0)
  2 - output([t2.c1]), filter([? = t2.c2]), 
      access([t2.c2], [t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 150   ***************
SQL: select (c1 + 1) as k from t1 where c1 !=ANY (select c1 from t2 where t1.c2=t2.c2 limit 1) and t1.c1 > 0; 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |50       |9926|
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |1        |99  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?]), filter([t1.c1 != ANY(subquery(1))]), 
      exec_params_([t1.c2]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c2], [t1.c1]), filter(nil), 
      access([t1.c2], [t1.c1]), partitions(p0)
  2 - output([t2.c1]), filter([? = t2.c2]), 
      access([t2.c2], [t2.c1]), partitions(p0), 
      limit(1), offset(nil)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 151   ***************
SQL: select * from (select * from t1 where c1 < (select c1 from t2)) as v where v.c1 > 0; 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |192 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |100      |88  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 152   ***************
SQL: select * from t1 where c1 < (select c1 from t2) and t1.c1 > 0; 
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |34       |192 |
|1 | TABLE SCAN   |t1  |100      |90  |
|2 | TABLE SCAN   |t2  |100      |88  |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 153   ***************
SQL: select * from t1 join t2 on t1.c1 = t2.c1 join t3 on t2.c2 = t3.c2; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |100      |655 |
|1 | TABLE SCAN |t3  |100      |92  |
|2 | MERGE JOIN |    |100      |269 |
|3 |  TABLE SCAN|t1  |100      |90  |
|4 |  TABLE SCAN|t2  |100      |92  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t3.c2], [t3.c1], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c1], [t3.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 154   ***************
SQL: select c1 from (select c1 from t1) as s1 ; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |88  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 155   ***************
SQL: select c1 from t1; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |88  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 156   ***************
SQL: select * from (select * from (select * from t1) as s1) as s2, t2; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7400|
|1 | TABLE SCAN               |t2  |100      |92  |
|2 | MATERIAL                 |    |100      |127 |
|3 |  TABLE SCAN              |t1  |100      |90  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$3" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$3" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$3" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$3" "opt.t1"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 157   ***************
SQL: select * from t1, t2; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7400|
|1 | TABLE SCAN               |t2  |100      |92  |
|2 | MATERIAL                 |    |100      |127 |
|3 |  TABLE SCAN              |t1  |100      |90  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 158   ***************
SQL: select * from (select * from (select * from t1) as s1) as s2, t2 where s2.c1=t2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|t2  |100      |92  |
|2 | TABLE SCAN|t1  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$3" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$3" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$3" "opt.t1"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 159   ***************
SQL: select * from t1, t2 where t1.c1=t2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 160   ***************
SQL: select * from (select * from (select * from t1) as s1) as s2, (select c1 from (select * from t2) as k1 ) as k2 where s2.c1=k2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$3" "opt.t2"@"SEL$5" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$5" ))
      FULL(@"SEL$3" "opt.t1"@"SEL$3")
      FULL(@"SEL$5" "opt.t2"@"SEL$5")
      END_OUTLINE_DATA
  */

***************   Case 161   ***************
SQL: select t1.c1, t1.c2, t2.c1 from t1, t2 where t1.c1=t2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 162   ***************
SQL: select * from (select (k + 1) as kk from (select (c1+1) as k from t1) as s1) as s2, (select (m + 1) as mm from (select (c2+1) as m from t2) as v1) as v2 where s2.kk+1=v2.mm; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |379 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?], [t2.c2 + ? + ?]), filter(nil), 
      equal_conds([t1.c1 + ? + ? + ? = t2.c2 + ? + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ? + ? + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c2 + ? + ?]), filter(nil), 
      access([t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$3" "opt.t2"@"SEL$5" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$5" ))
      FULL(@"SEL$3" "opt.t1"@"SEL$3")
      FULL(@"SEL$5" "opt.t2"@"SEL$5")
      END_OUTLINE_DATA
  */

***************   Case 163   ***************
SQL: select t1.c1+1+1, t2.c2+1+1 from t1, t2 where t1.c1+1+1+1=t2.c2+1+1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |379 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?], [t2.c2 + ? + ?]), filter(nil), 
      equal_conds([t1.c1 + ? + ? + ? = t2.c2 + ? + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ? + ? + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c2], [t2.c2 + ? + ?]), filter(nil), 
      access([t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 164   ***************
SQL: select * from t1, t2 left join t3 on t2.c1=t3.c1 where t1.c1=t3.c2; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |100      |581 |
|1 | TABLE SCAN |t1  |100      |90  |
|2 | MERGE JOIN |    |100      |271 |
|3 |  TABLE SCAN|t2  |100      |92  |
|4 |  TABLE SCAN|t3  |100      |92  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3], [t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c1], [t3.c2], [t3.c3]), filter(nil), 
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" ("opt.t2"@"SEL$1" "opt.t3"@"SEL$1" )))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t3"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.t3"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 165   ***************
SQL: select c1 from t1 where c1=1; 
==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t1  |1        |52  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 166   ***************
SQL: select k + 1, t2.c2 from (select (c1 + 2) as k from t1) as s1, t2 where s1.k = t2.c1; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |381 |
|1 | TABLE SCAN |t2  |100      |90  |
|2 | SORT       |    |100      |196 |
|3 |  TABLE SCAN|t1  |100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1 + ?]), filter(nil), sort_keys([t1.c1 + ?, ASC])
  3 - output([t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 167   ***************
SQL: select t1.c1 +2+1, t2.c2 from t1, t2 where t1.c1+2 = t2.c1; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |381 |
|1 | SORT       |    |100      |196 |
|2 |  TABLE SCAN|t1  |100      |88  |
|3 | TABLE SCAN |t2  |100      |90  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ?]), filter(nil), sort_keys([t1.c1 + ?, ASC])
  2 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 168   ***************
SQL: select k + 1, t2.c2 from t2, (select (c1 + 2) as k from t1) as s1 where k = t2.c1; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |381 |
|1 | TABLE SCAN |t2  |100      |90  |
|2 | SORT       |    |100      |196 |
|3 |  TABLE SCAN|t1  |100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1 + ?]), filter(nil), sort_keys([t1.c1 + ?, ASC])
  3 - output([t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 169   ***************
SQL: select t1.c1 +2+1, t2.c2 from t2, t1 where t1.c1+2 = t2.c1; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |381 |
|1 | TABLE SCAN |t2  |100      |90  |
|2 | SORT       |    |100      |196 |
|3 |  TABLE SCAN|t1  |100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c1 + ?]), filter(nil), sort_keys([t1.c1 + ?, ASC])
  3 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 170   ***************
SQL: select * from t1, (select * from t2) as t where t1.c1=t.c1 group by t.c2; 
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |100      |373 |
|1 | MERGE JOIN  |    |100      |269 |
|2 |  TABLE SCAN |t1  |100      |90  |
|3 |  TABLE SCAN |t2  |100      |92  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      group([t2.c2]), agg_func(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      USE_HASH_AGGREGATION(@"SEL$1")
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 171   ***************
SQL: select * from t1, t2 where t1.c1=t2.c1 group by t2.c2; 
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |100      |373 |
|1 | MERGE JOIN  |    |100      |269 |
|2 |  TABLE SCAN |t1  |100      |90  |
|3 |  TABLE SCAN |t2  |100      |92  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      group([t2.c2]), agg_func(nil)
  1 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      USE_HASH_AGGREGATION(@"SEL$1")
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 172   ***************
SQL: select c1 as alias_name from t1 where c1 = 7; 
==================================
|ID|OPERATOR |NAME|EST. ROWS|COST|
----------------------------------
|0 |TABLE GET|t1  |1        |52  |
==================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 173   ***************
SQL: select distinct c1 as ali_name from t1; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |88  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 174   ***************
SQL: select * from t1 inner join t2 on t1.c1=t2.c1 where false; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |0        |99  |
|1 | TABLE SCAN               |t1  |0        |99  |
|2 | TABLE SCAN               |t2  |0        |101 |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([0]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 175   ***************
SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is not null and t2.c2>1; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |9600     |7129|
|1 | TABLE SCAN               |t2  |96       |109 |
|2 | MATERIAL                 |    |100      |127 |
|3 |  TABLE SCAN              |t1  |100      |90  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter([t2.c2 > ?]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  2 - output([t1.c1], [t1.c2]), filter(nil)
  3 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 176   ***************
SQL: select c1, c1+c2 from t1 where c1 > 100 limit 1, 10; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |10       |38  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0), 
      limit(10), offset(?)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 177   ***************
SQL: select * from t1 left join t2 on t1.c1>1 where t2.c1 is null and t2.c2>1; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |0        |99  |
|1 | TABLE SCAN               |t1  |0        |99  |
|2 | TABLE SCAN               |t2  |0        |101 |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), startup_filter([0]), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1], [t1.c2]), filter([0]), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter([0]), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 178   ***************
SQL: select c1, c1+c2 from t1 where c1 > 100 order by c2 + c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |SORT       |    |100      |217 |
|1 | TABLE SCAN|t1  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c1 + t1.c2]), filter(nil), sort_keys([t1.c2 + t1.c1, ASC])
  1 - output([t1.c1], [t1.c2], [t1.c2 + t1.c1]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 179   ***************
SQL: select t1.c1 from t1, t2, t3 where t1.c1=t2.c1 and t1.c2>t2.c2 and t2.c3=t3.c3 and t3.c1>10; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |34       |531 |
|1 | MERGE JOIN |    |34       |243 |
|2 |  TABLE SCAN|t1  |100      |90  |
|3 |  TABLE SCAN|t2  |100      |92  |
|4 | TABLE SCAN |t3  |100      |90  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds([t1.c2 > t2.c2])
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  4 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"opt.t3"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t3"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 180   ***************
SQL: select t1.c1, t2.c2, t2.c3 from t1,t2 where t1.c1 = t2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |267 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 181   ***************
SQL: select * from t1, (select c1, c2, c3 from t2) as ss where ss.c1 = t1.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 182   ***************
SQL: select t1.c1, t1.c2, t2.c1, t2.c2, t2.c3 from t1, t2 where t2.c1 = t1.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |269 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 183   ***************
SQL: select t1.c1 from t1 right join t2 on t1.c1 = t2.c1; 
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |100      |262 |
|1 | TABLE SCAN     |t2  |100      |88  |
|2 | TABLE SCAN     |t1  |100      |88  |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 184   ***************
SQL: select s1.c1, s2.c3 from (select c1 from t1) as s1, (select * from t2) as s2; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7272|
|1 | TABLE SCAN               |t2  |100      |90  |
|2 | MATERIAL                 |    |100      |106 |
|3 |  TABLE SCAN              |t1  |100      |88  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p0)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$3" "opt.t1"@"SEL$2" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 185   ***************
SQL: select t1.c1, t2.c3 from t1, t2; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7272|
|1 | TABLE SCAN               |t2  |100      |90  |
|2 | MATERIAL                 |    |100      |106 |
|3 |  TABLE SCAN              |t1  |100      |88  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p0)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 186   ***************
SQL: select t1.c1, t1.c2, ss.c1, ss.c2 from t1, (select * from t2)as ss where t1.c1 = ss.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |267 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 187   ***************
SQL: select t1.c1, t1.c2, t2.c1, t2.c2 from t1, t2 where t1.c1 = t2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |267 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 188   ***************
SQL: select t1.c1, ss.c3 from t1, (select c1, c2, c3 from t2) as ss; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7272|
|1 | TABLE SCAN               |t2  |100      |90  |
|2 | MATERIAL                 |    |100      |106 |
|3 |  TABLE SCAN              |t1  |100      |88  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p0)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$2" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 189   ***************
SQL: select t1.c1, t2.c3 from t1, t2; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7272|
|1 | TABLE SCAN               |t2  |100      |90  |
|2 | MATERIAL                 |    |100      |106 |
|3 |  TABLE SCAN              |t1  |100      |88  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c3]), filter(nil), 
      access([t2.c3]), partitions(p0)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$1" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 190   ***************
SQL: select t1.c2, ss.c3, ss.c2 from t1, (select c3, c2 from t2)as ss where t1.c1 = ss.c3; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |416 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t2.c3], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c3]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c3], [t2.c2]), filter(nil), 
      access([t2.c3], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 191   ***************
SQL: select t1.c2, t2.c3, t2.c2 from t1, t2 where t1.c1 = t2.c3; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |416 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t2.c3], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c3]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c3], [t2.c2]), filter(nil), 
      access([t2.c3], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 192   ***************
SQL: select tt.c1, tt.c2, t1.c2 from t1, (select * from t2) as tt where tt.c1 = t1.c1 ; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |267 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t1.c2]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 193   ***************
SQL: select t2.c1, t2.c2, t1.c2 from t1, t2 where t1.c1 = t2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |267 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1], [t2.c2], [t1.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 194   ***************
SQL: select s1.c1, s2.c2  from (select * from t1) as s1, (select c1, c2, c3 from t2) as s2 where s1.c1 = s2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 195   ***************
SQL: select t1.c1, t2.c2  from t1, t2 where t1.c1 = t2.c1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |MERGE JOIN |    |100      |265 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  1 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 196   ***************
SQL: select s1.c2, s2.c1, s3.c3 from (select * from t1) as s1, (select c1, c2 from t2) as s2, (select c2, c3 from t3) as s3 where s1.c1 = s2.c1 and s2.c2 = s3.c2; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |100      |616 |
|1 | MERGE JOIN |    |100      |267 |
|2 |  TABLE SCAN|t1  |100      |90  |
|3 |  TABLE SCAN|t2  |100      |90  |
|4 | TABLE SCAN |t3  |100      |92  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t2.c1], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t3.c2], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" )"opt.t3"@"SEL$4" ))
      USE_HASH(@"SEL$1" ("opt.t3"@"SEL$4" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      FULL(@"SEL$4" "opt.t3"@"SEL$4")
      END_OUTLINE_DATA
  */

***************   Case 197   ***************
SQL: select t1.c2, t2.c1, t3.c3 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c2 = t3.c2; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |100      |616 |
|1 | MERGE JOIN |    |100      |267 |
|2 |  TABLE SCAN|t1  |100      |90  |
|3 |  TABLE SCAN|t2  |100      |90  |
|4 | TABLE SCAN |t3  |100      |92  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c2], [t2.c1], [t3.c3]), filter(nil), 
      equal_conds([t2.c2 = t3.c2]), other_conds(nil)
  1 - output([t1.c2], [t2.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([t3.c2], [t3.c3]), filter(nil), 
      access([t3.c2], [t3.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" (("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )"opt.t3"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t3"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 198   ***************
SQL: select t1.c1, s2.c3, t3.c2 from t1, (select * from t2) as s2, t3 where t1.c1 = s2.c1 and s2.c3 = t3.c3; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |100      |749 |
|1 | TABLE SCAN |t3  |100      |92  |
|2 | MERGE JOIN |    |100      |265 |
|3 |  TABLE SCAN|t1  |100      |88  |
|4 |  TABLE SCAN|t2  |100      |90  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c3], [t3.c2]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t3.c3], [t3.c2]), filter(nil), 
      access([t3.c3], [t3.c2]), partitions(p0)
  2 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" )))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 199   ***************
SQL: select t1.c1, t2.c3, t3.c2 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c3 = t3.c3; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |100      |749 |
|1 | TABLE SCAN |t3  |100      |92  |
|2 | MERGE JOIN |    |100      |265 |
|3 |  TABLE SCAN|t1  |100      |88  |
|4 |  TABLE SCAN|t2  |100      |90  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c3], [t3.c2]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t3.c3], [t3.c2]), filter(nil), 
      access([t3.c3], [t3.c2]), partitions(p0)
  2 - output([t1.c1], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 200   ***************
SQL: select s1.c1, t2.c2, s3.c3 from (select c1 from t1) as s1, t2, (select * from t3) as s3 where s1.c1 = t2.c1 and t2.c3 = s3.c3; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |100      |731 |
|1 | TABLE SCAN |t3  |100      |90  |
|2 | MERGE JOIN |    |100      |267 |
|3 |  TABLE SCAN|t2  |100      |92  |
|4 |  TABLE SCAN|t1  |100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)
  2 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p0)
  4 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$3" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$2" )))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$2" ))
      FULL(@"SEL$3" "opt.t3"@"SEL$3")
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 201   ***************
SQL: select t1.c1, t2.c2, t3.c3 from t1, t2, t3 where t1.c1 = t2.c1 and t2.c3 = t3.c3; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |HASH JOIN   |    |100      |731 |
|1 | TABLE SCAN |t3  |100      |90  |
|2 | MERGE JOIN |    |100      |267 |
|3 |  TABLE SCAN|t1  |100      |88  |
|4 |  TABLE SCAN|t2  |100      |92  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2], [t3.c3]), filter(nil), 
      equal_conds([t2.c3 = t3.c3]), other_conds(nil)
  1 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)
  2 - output([t1.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1], [t2.c3], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c3], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t3"@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" )))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t3"@"SEL$1")
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 202   ***************
SQL: select ss.c1, ss.c2 from (select * from t1 where c2 > 0) as ss; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |107 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c2 > ?]), 
      access([t1.c2], [t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 203   ***************
SQL: select t1.c1, t1.c2 from t1 where t1.c2 > 0; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |107 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2]), filter([t1.c2 > ?]), 
      access([t1.c2], [t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 204   ***************
SQL: select s1.c1, s2.c2 from (select * from t1 where c2 > 0)as s1, (select * from t2 where c2 > 0)as s2 where s1.c2 = s2.c2; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |449 |
|1 | TABLE SCAN|t2  |100      |124 |
|2 | TABLE SCAN|t1  |100      |124 |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t2.c2]), filter([t2.c2 > ?], [t2.c2 > ?]), 
      access([t2.c2]), partitions(p0)
  2 - output([t1.c2], [t1.c1]), filter([t1.c2 > ?], [t1.c2 > ?]), 
      access([t1.c2], [t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$3" "opt.t1"@"SEL$2" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 205   ***************
SQL: select t1.c1, t2.c2 from t1, t2 where t1.c2 > 0 and t2.c2 > 0 and t1.c2 = t2.c2; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |449 |
|1 | TABLE SCAN|t2  |100      |124 |
|2 | TABLE SCAN|t1  |100      |124 |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t2.c2]), filter(nil), 
      equal_conds([t1.c2 = t2.c2]), other_conds(nil)
  1 - output([t2.c2]), filter([t2.c2 > ?], [t2.c2 > ?]), 
      access([t2.c2]), partitions(p0)
  2 - output([t1.c2], [t1.c1]), filter([t1.c2 > ?], [t1.c2 > ?]), 
      access([t1.c2], [t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 206   ***************
SQL: select s2.c1 from (select * from t2 where c2 > 0) as s2; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t2  |100      |107 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 207   ***************
SQL: select c1 from t2 where c2 > 0; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t2  |100      |107 |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t2.c1]), filter([t2.c2 > ?]), 
      access([t2.c2], [t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 208   ***************
SQL: select * from (select * from t1 where c1 > 0) as s1, t2 where s1.c1 = t2.c2; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |419 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |109 |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter([t2.c2 > ?]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 209   ***************
SQL: select * from t1, t2 where t1.c1 > 0 and t1.c1 = t2.c2; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |419 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |109 |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c2]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter([t2.c2 > ?]), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 210   ***************
SQL: select * from (select (c1+1) as k from t1) as s1; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |88  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 211   ***************
SQL: select c1 +1 from t1; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |88  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 212   ***************
SQL: select k+1 from (select (c1+1) as k from t1) as s1; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |88  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 213   ***************
SQL: select c1+1 from t1; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |88  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 214   ***************
SQL: select * from (select (c1+2) as k from t1) as s1 where k=3; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |96  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?]), filter([t1.c1 + ? = ?]), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 215   ***************
SQL: select c1+2 from t1 where c1+2=3; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |1        |96  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?]), filter([t1.c1 + ? = ?]), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 216   ***************
SQL: select * from (select (c1+2) as k from t1) as s1, t2 where k=c2; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |395 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c2]), other_conds(nil)
  1 - output([t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 217   ***************
SQL: select t1.c1+2, t2.c1, t2.c2, t2.c3 from t1, t2 where t1.c1+2=t2.c2; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |395 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 218   ***************
SQL: select * from (select (c1+2) as k from t1) as s1, t2 where k+3=c2; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |395 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 + ? + ? = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ? + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 219   ***************
SQL: select t1.c1+2, t2.c1, t2.c2, t2.c3 from t1, t2 where t1.c1+2+3=t2.c2; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |395 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |92  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t1.c1 + ? + ? = t2.c2]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ? + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 220   ***************
SQL: select k + 1, t2.c2 from (select (c1 + 2) as k from t1) as s1, t2 where k  = t2.c1; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |381 |
|1 | TABLE SCAN |t2  |100      |90  |
|2 | SORT       |    |100      |196 |
|3 |  TABLE SCAN|t1  |100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1 + ?]), filter(nil), sort_keys([t1.c1 + ?, ASC])
  3 - output([t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 221   ***************
SQL: select t1.c1 + 3, t2.c2 from t1, t2 where t1.c1 + 4 = t2.c1; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |381 |
|1 | SORT       |    |100      |196 |
|2 |  TABLE SCAN|t1  |100      |88  |
|3 | TABLE SCAN |t2  |100      |90  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ?]), filter(nil), sort_keys([t1.c1 + ?, ASC])
  2 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 222   ***************
SQL: select k + 1, t2.c2 from t2, (select (c1 + 2) as k from t1) as s1 where k + 2 = t2.c1; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |381 |
|1 | TABLE SCAN |t2  |100      |90  |
|2 | SORT       |    |100      |196 |
|3 |  TABLE SCAN|t1  |100      |88  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 + ? + ? = t2.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c1 + ? + ?]), filter(nil), sort_keys([t1.c1 + ? + ?, ASC])
  3 - output([t1.c1], [t1.c1 + ? + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$2" ))
      USE_MERGE(@"SEL$1" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 223   ***************
SQL: select t1.c1 + 3, t2.c2 from t1, t2 where t1.c1 + 4 = t2.c1; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |381 |
|1 | SORT       |    |100      |196 |
|2 |  TABLE SCAN|t1  |100      |88  |
|3 | TABLE SCAN |t2  |100      |90  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ?]), filter(nil), sort_keys([t1.c1 + ?, ASC])
  2 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 224   ***************
SQL: select * from (select (c1 + 1) as k1 from t1) as s1, (select (c1 - 1) as k2 from t2) as s2 where k1 = k2; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |377 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c1 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1 + ?]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 225   ***************
SQL: select t1.c1 + 1, t2.c1 - 1 from t1, t2 where t1.c1+1=t2.c1 -1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |377 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c1 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c1 + ?]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 226   ***************
SQL: select * from (select (c1 + 1) as k1 from t1 where c1 > 1) as s1, (select (c1 - 1) as k2 from t2) as s2 where k1 = k2; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |377 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c1 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1 + ?]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 227   ***************
SQL: select t1.c1 + 1, t2.c1 - 1 from t1, t2 where t1.c1 > 1 and t1.c1 + 1= t2.c1 - 1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |377 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c1 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1], [t2.c1 + ?]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 228   ***************
SQL: select * from (select (c1 + 1) as k1, (c2 + 1) as k2  from t1 where c1  > 0) as s1, (select (c1 - 1) as d1, (c2 - 1) as d2  from t2) as s2 where k1 = d1 and k2=d2; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |353 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t1.c2 + ?], [t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?], [t1.c2 + ? = t2.c2 + ?]), other_conds(nil)
  1 - output([t1.c1 + ?], [t1.c2 + ?]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 229   ***************
SQL: select t1.c1 + 1, t2.c2 + 1, t2.c1 - 1, t2.c2 - 1 from t1, t2 where t1.c1 + 1 = t2.c1 - 1 and t1.c2 + 1 = t2.c2 - 1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |353 |
|1 | TABLE SCAN|t1  |100      |90  |
|2 | TABLE SCAN|t2  |100      |90  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c2 + ?], [t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?], [t1.c2 + ? = t2.c2 + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ?], [t1.c2 + ?]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  2 - output([t2.c1], [t2.c2], [t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 230   ***************
SQL: select k from (select (c1+1) as k from t1) as s1, t2 where k + 10 = 2; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |100      |249 |
|1 | TABLE SCAN               |t1  |1        |96  |
|2 | TABLE SCAN               |t2  |100      |88  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1]), filter([t1.c1 + ? + ? = ?]), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$1" ))
      USE_NL(@"SEL$1" ("opt.t2"@"SEL$1" ))
      NO_USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 231   ***************
SQL: select k + 1, t2.c2 from (select (c1 + 2) as k from t1) as s1, t2 ; 
===================================================
|ID|OPERATOR                  |NAME|EST. ROWS|COST|
---------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|    |10000    |7272|
|1 | TABLE SCAN               |t2  |100      |90  |
|2 | MATERIAL                 |    |100      |106 |
|3 |  TABLE SCAN              |t1  |100      |88  |
===================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?], [t2.c2]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  2 - output([t1.c1]), filter(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$2" ))
      USE_NL(@"SEL$1" ("opt.t1"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$1" ("opt.t1"@"SEL$2" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 232   ***************
SQL: select t1.c1 + 3, t2.c2 from t1, t2 where t1.c1 +2+2 =t2.c1; 
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |100      |381 |
|1 | SORT       |    |100      |196 |
|2 |  TABLE SCAN|t1  |100      |88  |
|3 | TABLE SCAN |t2  |100      |90  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c2]), filter(nil), 
      equal_conds([t1.c1 + ? + ? = t2.c1]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ? + ?]), filter(nil), sort_keys([t1.c1 + ? + ?, ASC])
  2 - output([t1.c1], [t1.c1 + ? + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_MERGE(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 233   ***************
SQL: select (k + 1) as mmm from (select (c1 + 1) as k from t1 where c1 < 1) as s1, (select (c1 + 1) as d from t2 ) as s2 where k+2=d; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |377 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?]), filter(nil), 
      equal_conds([t1.c1 + ? + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ? + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1 + ?]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 234   ***************
SQL: select t1.c1 + 1 + 1 from t1, t2 where t1.c1 + 1 + 2 = t2.c1 + 1 and t1.c1 < 1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |377 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?]), filter(nil), 
      equal_conds([t1.c1 + ? + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ? + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1 + ?]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 235   ***************
SQL: select (k + 1) as mmm from (select (c1 + 1) as d from t2 ) as s2, (select (c1 + 1) as k from t1 where c1 < 1) as s1 where k+2=d; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |377 |
|1 | TABLE SCAN|t2  |100      |88  |
|2 | TABLE SCAN|t1  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?]), filter(nil), 
      equal_conds([t1.c1 + ? + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t2.c1 + ?]), filter(nil), 
      access([t2.c1]), partitions(p0)
  2 - output([t1.c1], [t1.c1 + ? + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$2" "opt.t1"@"SEL$3" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$3" "opt.t1"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 236   ***************
SQL: select t1.c1 + 1 + 1 from t1, t2 where t1.c1 + 1 + 2 = t2.c1 + 1 and t1.c1 < 1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |100      |377 |
|1 | TABLE SCAN|t1  |100      |88  |
|2 | TABLE SCAN|t2  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ? + ?]), filter(nil), 
      equal_conds([t1.c1 + ? + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t1.c1], [t1.c1 + ? + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)
  2 - output([t2.c1 + ?]), filter(nil), 
      access([t2.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t1"@"SEL$1" "opt.t2"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 237   ***************
SQL: select case t1.c1 when 1 then (2) else (3) end from t1; 
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |100      |88  |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE t1.c1 WHEN ? THEN ? ELSE ? END]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 238   ***************
SQL: select case k1 when 1 then (2) else (3) end from (select (c1 + 1) as k1, (c2 + 1) as k2  from t1 where c1  > 0) as s1, (select (c1 - 1) as d1, (c2 - 1) as d2  from t2) as s2 where k1 = d1 and k2=d2 group by k1; 
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |1        |354 |
|1 | HASH JOIN   |    |1        |353 |
|2 |  TABLE SCAN |t1  |100      |90  |
|3 |  TABLE SCAN |t2  |100      |90  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([CASE t1.c1 + ? WHEN ? THEN ? ELSE ? END]), filter(nil), 
      group([t1.c1 + ?]), agg_func(nil)
  1 - output([t1.c1 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?], [t1.c2 + ? = t2.c2 + ?]), other_conds(nil)
  2 - output([t1.c1 + ?], [t1.c2 + ?]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      USE_HASH_AGGREGATION(@"SEL$1")
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 239   ***************
SQL: select t1.c1 + 1, t2.c2 + 1, t2.c1 - 1, t2.c2 - 1 from t1, t2 where t1.c1 + 1 = t2.c1 - 1 and t2.c2 + 1 = t2.c2 - 1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |220 |
|1 | TABLE SCAN|t2  |1        |99  |
|2 | TABLE SCAN|t1  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c2 + ?], [t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c1 + ?]), filter([t2.c2 + ? = t2.c2 + ?]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 240   ***************
SQL: select * from (select (c1 + 1) as k1, (c2 + 1) as k2  from t1 where c1  > 0) as s1, (select (c1 - 1) as d1, (c2 - 1) as d2  from t2) as s2 where k1 = d1 and k2=d2 group by k1; 
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |1        |354 |
|1 | HASH JOIN   |    |1        |353 |
|2 |  TABLE SCAN |t1  |100      |90  |
|3 |  TABLE SCAN |t2  |100      |90  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t1.c2 + ?], [t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      group([t1.c1 + ?]), agg_func(nil)
  1 - output([t1.c1 + ?], [t1.c2 + ?], [t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?], [t1.c2 + ? = t2.c2 + ?]), other_conds(nil)
  2 - output([t1.c1 + ?], [t1.c2 + ?]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      USE_HASH_AGGREGATION(@"SEL$1")
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 241   ***************
SQL: select t1.c1 + 1, t2.c2 + 1, t2.c1 - 1, t2.c2 - 1 from t1, t2 where t1.c1 + 1 = t2.c1 - 1 and t2.c2 + 1 = t2.c2 - 1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |220 |
|1 | TABLE SCAN|t2  |1        |99  |
|2 | TABLE SCAN|t1  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c2 + ?], [t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c1 + ?]), filter([t2.c2 + ? = t2.c2 + ?]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 242   ***************
SQL: select max(k1) from (select (c1 + 1) as k1, (c2 + 1) as k2  from t1 where c1  > 0) as s1, (select (c1 - 1) as d1, (c2 - 1) as d2  from t2) as s2 where k1 = d1 and k2=d2 group by k1; 
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |1        |354 |
|1 | HASH JOIN   |    |1        |353 |
|2 |  TABLE SCAN |t1  |100      |90  |
|3 |  TABLE SCAN |t2  |100      |90  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_MAX(t1.c1 + ?)]), filter(nil), 
      group([t1.c1 + ?]), agg_func([T_FUN_MAX(t1.c1 + ?)])
  1 - output([t1.c1 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?], [t1.c2 + ? = t2.c2 + ?]), other_conds(nil)
  2 - output([t1.c1 + ?], [t1.c2 + ?]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      USE_HASH_AGGREGATION(@"SEL$1")
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 243   ***************
SQL: select t1.c1 + 1, t2.c2 + 1, t2.c1 - 1, t2.c2 - 1 from t1, t2 where t1.c1 + 1 = t2.c1 - 1 and t2.c2 + 1 = t2.c2 - 1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |220 |
|1 | TABLE SCAN|t2  |1        |99  |
|2 | TABLE SCAN|t1  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c2 + ?], [t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c1 + ?]), filter([t2.c2 + ? = t2.c2 + ?]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 244   ***************
SQL: select lnnvl(k1) from (select (c1 + 1) as k1, (c2 + 1) as k2  from t1 where c1  > 0) as s1, (select (c1 - 1) as d1, (c2 - 1) as d2  from t2) as s2 where k1 = d1 and k2=d2 group by k1; 
======================================
|ID|OPERATOR     |NAME|EST. ROWS|COST|
--------------------------------------
|0 |HASH GROUP BY|    |1        |354 |
|1 | HASH JOIN   |    |1        |353 |
|2 |  TABLE SCAN |t1  |100      |90  |
|3 |  TABLE SCAN |t2  |100      |90  |
======================================

Outputs & filters: 
-------------------------------------
  0 - output([lnnvl(t1.c1 + ?)]), filter(nil), 
      group([t1.c1 + ?]), agg_func(nil)
  1 - output([t1.c1 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?], [t1.c2 + ? = t2.c2 + ?]), other_conds(nil)
  2 - output([t1.c1 + ?], [t1.c2 + ?]), filter(nil), 
      access([t1.c1], [t1.c2]), partitions(p0)
  3 - output([t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      USE_HASH_AGGREGATION(@"SEL$1")
      LEADING(@"SEL$1" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$3" ))
      USE_HASH(@"SEL$1" ("opt.t2"@"SEL$3" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$3" "opt.t2"@"SEL$3")
      END_OUTLINE_DATA
  */

***************   Case 245   ***************
SQL: select t1.c1 + 1, t2.c2 + 1, t2.c1 - 1, t2.c2 - 1 from t1, t2 where t1.c1 + 1 = t2.c1 - 1 and t2.c2 + 1 = t2.c2 - 1; 
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |220 |
|1 | TABLE SCAN|t2  |1        |99  |
|2 | TABLE SCAN|t1  |100      |88  |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + ?], [t2.c2 + ?], [t2.c1 + ?], [t2.c2 + ?]), filter(nil), 
      equal_conds([t1.c1 + ? = t2.c1 + ?]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c1 + ?]), filter([t2.c2 + ? = t2.c2 + ?]), 
      access([t2.c1], [t2.c2]), partitions(p0)
  2 - output([t1.c1], [t1.c1 + ?]), filter(nil), 
      access([t1.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$1" ("opt.t2"@"SEL$1" "opt.t1"@"SEL$1" ))
      USE_HASH(@"SEL$1" ("opt.t1"@"SEL$1" ))
      FULL(@"SEL$1" "opt.t2"@"SEL$1")
      FULL(@"SEL$1" "opt.t1"@"SEL$1")
      END_OUTLINE_DATA
  */

***************   Case 246   ***************
SQL: select * from (select t1.c1 from t1 join t2 on t1.c1 = t2.c1, t3, t1 as tt) as view; 
======================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST  |
------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |1000000  |715190|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7445  |
|2 |  MERGE JOIN               |    |100      |262   |
|3 |   TABLE SCAN              |t1  |100      |88    |
|4 |   TABLE SCAN              |t2  |100      |88    |
|5 |  MATERIAL                 |    |100      |106   |
|6 |   TABLE SCAN              |t3  |100      |88    |
|7 | MATERIAL                  |    |100      |106   |
|8 |  TABLE SCAN               |tt  |100      |88    |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  3 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([1]), filter(nil)
  6 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  7 - output([1]), filter(nil)
  8 - output([tt.c1]), filter(nil), 
      access([tt.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" ((("opt.t1"@"SEL$2" "opt.t2"@"SEL$2" )"opt.t3"@"SEL$2" )"opt.tt"@"SEL$2" ))
      USE_NL(@"SEL$2" ("opt.tt"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("opt.tt"@"SEL$2" ))
      USE_NL(@"SEL$2" ("opt.t3"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("opt.t3"@"SEL$2" ))
      USE_MERGE(@"SEL$2" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$2" "opt.t3"@"SEL$2")
      FULL(@"SEL$2" "opt.tt"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 247   ***************
SQL: select * from (select t1.c1 from t1 left join t2 on t1.c1 = t2.c1, t3, t1 as tt) as view; 
======================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST  |
------------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |1000000  |715015|
|1 | NESTED-LOOP JOIN CARTESIAN|    |10000    |7270  |
|2 |  TABLE SCAN               |t1  |100      |88    |
|3 |  MATERIAL                 |    |100      |106   |
|4 |   TABLE SCAN              |t3  |100      |88    |
|5 | MATERIAL                  |    |100      |106   |
|6 |  TABLE SCAN               |tt  |100      |88    |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  1 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  3 - output([1]), filter(nil)
  4 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  5 - output([1]), filter(nil)
  6 - output([tt.c1]), filter(nil), 
      access([tt.c1]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" (("opt.t1"@"SEL$2" "opt.t3"@"SEL$2" )"opt.tt"@"SEL$2" ))
      USE_NL(@"SEL$2" ("opt.tt"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("opt.tt"@"SEL$2" ))
      USE_NL(@"SEL$2" ("opt.t3"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("opt.t3"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$2" "opt.t3"@"SEL$2")
      FULL(@"SEL$2" "opt.tt"@"SEL$2")
      END_OUTLINE_DATA
  */

***************   Case 248   ***************
SQL: select * from (select t1.c1 from t1 join t2 on t1.c1 = t2.c1, t1 as tt, t1 as tt2 join t3 as tt3 on tt2.c1 = tt3.c2) as view; 
=========================================================
|ID|OPERATOR                     |NAME|EST. ROWS|COST   |
---------------------------------------------------------
|0 |MERGE JOIN                   |    |1000000  |1472888|
|1 | NESTED-LOOP JOIN CARTESIAN  |    |1000000  |741573 |
|2 |  TABLE SCAN                 |tt2 |100      |88     |
|3 |  MATERIAL                   |    |10000    |12957  |
|4 |   NESTED-LOOP JOIN CARTESIAN|    |10000    |7445   |
|5 |    MERGE JOIN               |    |100      |262    |
|6 |     TABLE SCAN              |t1  |100      |88     |
|7 |     TABLE SCAN              |t2  |100      |88     |
|8 |    MATERIAL                 |    |100      |106    |
|9 |     TABLE SCAN              |tt  |100      |88     |
|10| SORT                        |    |100      |198    |
|11|  TABLE SCAN                 |tt3 |100      |90     |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1]), filter(nil), 
      equal_conds([tt2.c1 = tt3.c2]), other_conds(nil)
  1 - output([t1.c1], [tt2.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([tt2.c1]), filter(nil), 
      access([tt2.c1]), partitions(p0)
  3 - output([t1.c1]), filter(nil)
  4 - output([t1.c1]), filter(nil), 
      conds(nil), nl_params_(nil)
  5 - output([t1.c1]), filter(nil), 
      equal_conds([t1.c1 = t2.c1]), other_conds(nil)
  6 - output([t1.c1]), filter(nil), 
      access([t1.c1]), partitions(p0)
  7 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  8 - output([1]), filter(nil)
  9 - output([tt.c1]), filter(nil), 
      access([tt.c1]), partitions(p0)
  10 - output([tt3.c2]), filter(nil), sort_keys([tt3.c2, ASC])
  11 - output([tt3.c2]), filter(nil), 
      access([tt3.c2]), partitions(p0)

Outline Data:
-------------------------------------
  /*+
      BEGIN_OUTLINE_DATA
      LEADING(@"SEL$2" (("opt.tt2"@"SEL$2" (("opt.t1"@"SEL$2" "opt.t2"@"SEL$2" )"opt.tt"@"SEL$2" ))"opt.tt3"@"SEL$2" ))
      USE_MERGE(@"SEL$2" ("opt.tt3"@"SEL$2" ))
      USE_NL(@"SEL$2" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$2" "opt.tt"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("opt.t1"@"SEL$2" "opt.t2"@"SEL$2" "opt.tt"@"SEL$2" ))
      FULL(@"SEL$2" "opt.tt2"@"SEL$2")
      USE_NL(@"SEL$2" ("opt.tt"@"SEL$2" ))
      USE_NL_MATERIALIZATION(@"SEL$2" ("opt.tt"@"SEL$2" ))
      USE_MERGE(@"SEL$2" ("opt.t2"@"SEL$2" ))
      FULL(@"SEL$2" "opt.t1"@"SEL$2")
      FULL(@"SEL$2" "opt.t2"@"SEL$2")
      FULL(@"SEL$2" "opt.tt"@"SEL$2")
      FULL(@"SEL$2" "opt.tt3"@"SEL$2")
      END_OUTLINE_DATA
  */

